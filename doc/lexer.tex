% $Id$

\documentclass[11pt]{article}
\usepackage{geometry}

\begin{document}

\title{A syntax of lexers as parsers of streams of characters using Camlp4}
\date{}
\author{Daniel de Rauglaudre, Patrick Meumeu Yomsi, Omar Kermia\\
INRIA Rocquencourt,
78153 Le Chesnay Cedex \\
\{daniel.de\_rauglaudre, patrick.meumeu, omar.kermia\}@inria.fr}

\thispagestyle{empty}

\maketitle

\begin{abstract}
In this paper, we give a new simplified syntax, which has been
implemented in Camlp4, to program lexers, i.e. parsers analyzing
streams of characters. This syntax is shorter in length and more
readable than its equivalent version written with classical stream
parsers.
\end{abstract}

\section{Introduction}

Classical streams parsers apply to any kind of OCaml values. For
the specify type ``character'', it has been possible to shorten codes by
using the type string to represent several characters and to simplify
them by hidding the management of the lexing buffer.

The rest of the paper is structured as follows: section 2 gives the
new implemented syntax, section 3 describes the semantics and the
directives for use. We conclude and give future work in section 4.

In order to motivate our work, we give the following example:

\begin{verbatim}
          value rec ident =
            lexer [ "A..Za..z0..9_'\128..\255" ident! | ]
          ;
\end{verbatim}

which is equivalent to the following program using classical parsers:

\begin{verbatim}
           value rec ident buf =
             parser
             [ [: `('A'..'Z' | 'a'..'z' | '0'..'9' | '_' | ''' |
                  '\128'..'\255' as c);
                   buf = ident (B.add c buf) ! :] -> buf
             | [: :] -> buf ]
           ;
\end{verbatim}

We notice that, in the first version, the ``or'' pattern of characters
is represented by a simple string and that the implicit lexing buffer,
represented by variable buf, never appears.

\section{Syntax}

\begin{verbatim}
                 lexer ::= "lexer" "[" rules "]"
                 rules ::= rules rule
                         | rule
                  rule ::= symbols [ "->" action "]"
               symbols ::= symbols symbol error
                         |
                symbol ::= "_" no_record
                         | STRING no_record
                         | simple_expression
                         | "?=" "[" lookaheads "]"
                         | "[" rules "]"
             no_record ::= "/"
                         |
     simple_expression ::= LIDENT
                         | CHAR
                         | "(" <expression> ")"
            lookaheads ::= lookaheads "|" lookahead
                         | lookahead
             lookahead ::= lookahead_characters
                         | STRING
  lookahead_characters ::= lookahead_characters
                             lookahead_character
                         | lookahead_character
   lookahead_character ::= CHAR
                         | "_"
                 error ::= "?" STRING
                         | "?" simple_expression
                         | "!"
               action ::= <expression>
\end{verbatim}

The syntax of the entry $<$expression$>$ of the OCaml language is
extended this way:

\begin{verbatim}
            expression ::= "$" "add" STRING
                         | "$" "add" simple_expression
                         | "$" "buf"
                         | "$" "empty"
                         | "$" "pos"
\end{verbatim}

The identifiers ``add'', ``buf'', ``empty'' and ``pos'' are not keywords.

\section{Semantics}

A lexer defined in the syntax above is a shortcut version of a parser
applied to the specific case of streams of characters. They could be
written with normal parsers. The proposed syntax is much more short,
easy to use and understand, and silently takes care of the lexer
buffer for the programmer.

They are generally of the type:

\begin{verbatim}
      B.t -> Stream.t char -> B.t
\end{verbatim}

The module \verb/B/ must be defined by the user. It contains the
lexing buffer type \verb/t/ and some variables and functions:

\begin{itemize}
\item \verb/empty/: the empty buffer
\item \verb/add/: the way to add a character to a buffer
\item \verb/get/: the way to get a string from the buffer
\end{itemize}

A possible implementation, using \verb/list char/ as type \verb/t/ could be:

\begin{verbatim}
value rev_implode l =
  let s = String.create (List.length l) in
  loop (String.length s - 1) l where rec loop i =
    fun
    [ [c :: l] -> do { s.[i] := c; loop (i - 1) l }
    | [] -> s ]
;

module B =
  struct
    type t = list char;
    value empty = [];
    value add c l = [c :: l];
    value get = rev_implode;
  end
;
\end{verbatim}

The default semantic action returns the lexing buffer itself.

A lexer gets the initial lexing buffer as first parameter and returns,
by default, a lexing buffer with all characters found in the stream,
according to the applied rule. Some characters may not be inserted if
using the ``no record'' feature (see below). The second parameter of
a lexer is the stream itself, like any other Camlp4 parser.

\subsection{Symbols}

The different kinds or symbols in a rule are:

\begin{itemize}

\item The character ``underscore'', which represents any
  character. Fails only if the stream is empty.

\item A string which represent any character in the string. Notice
  that it is an ``or'' of all the characters, not all the characters
  found in the stream in the order. For example ``\verb/"01"/'' means
  ``the character 0 or the character 1''. Ranges can be inserted using
  the characters ``\verb/../''. Any letter or digit can be written
  \verb/"A..Za..z0..9"/''. To specify 2 characters the one behind the
  other, you have to write two symbols. For example, the beginning of
  a comment in OCaml must be written: \verb/"(" "*"/.

\item An expression corresponding to a call to another parser, which
  takes the buffer as first parameter and ought to return the buffer
  with all characters found in the stream added in the buffer.

\item The sequence ``\verb/?=/'' introducing lookahead characters.
  Remind that stream parsers use recursive descend parsing with the
  first symbol of a rule determining the definitive choice (otherwise
  it is syntax error). Lookahead allows to look at the first
  characters of the stream in advance to check if some characters
  appear or not. It never throws the characters found from the stream.
  See further for lookahead syntax.

\item A rule, recursively, between brackets, inlining a lexer.

\end{itemize}

In the first two cases (underscore or string), the symbol can be
followed by the character ``slash'' specifying that the found symbol
must not be added in the lexing buffer. By default, it is added.

A symbol can be followed by an optional error directive, which can be:

\begin{itemize}

\item The character \verb/?/ followed by a string expression, telling,
  like in stream parsers, that if there is a syntax error at this
  point (i.e. the character is not recognized although the beginning
  of the rule was), the exception \verb/Stream.Error/ is raised with
  that string as parameter.

\item The character \verb/!/, which is just a hint to the preprocessor
  that you know by sure that the previous symbol never fails (never
  raises \verb/Stream.Failure/), in particular if it contains the empty
  rule among its rules. If you gives a false indication, the behaviour
  of the lexer is undefined. Otherwise, the behaviour is not different
  as without this \verb/!/, but the code is shorter and faster.

\end{itemize}

\subsection{Specific expressions}

Some expressions can be used in the program starting with \verb/$/:

\begin{itemize}

\item \verb/$add/ followed by a string, specifing that you want to add
  all character of the string in the lexing buffer. It returns the new
  lexing buffer.

\item \verb/$buf/ which returns the string contents of the lexing buffer.

\item \verb/$empty/ which returns the empty lexing buffer.

\item \verb/$pos/ which return the current position in the stream in
  number of characters (the first one being zero).

\end{itemize}

\subsection{Lookahead syntax}

A lookahead as rule symbol starts with \verb/?=/ and is followed by
one or several lookaheads separated by the vertical bar \verb/|/ and
between braces.

If there are several lookahead, they must all be of the same size (the
same number of characters).

A lookahead can be a string. In this case, it correspond to all characters
of the string in the order. It can be also a list of characters or the
character \verb/_/. For example:

\begin{verbatim}
       ?= [ _ ''' | '\\' _ ]
\end{verbatim}

matches a stream whose second character is a quote or a stream whose
first character is a backslash, while:

\begin{verbatim}
       ?= [ "<<" | "<:" ]
\end{verbatim}

matches a stream starting with the two characters \verb/</ and
\verb/</ or a stream starting with the two characters \verb/</ and
\verb/:/.

\subsection{Semantic actions of rules}

It is actually possible to return another type as \verb/B.t/ in the
semantic action, provided that the type system agrees. In particular,
returning the value \verb/$buf/ returns a string corresponding of the
lexing buffer obtained.

\subsection{Compiling}

To compile a file containing lexers, just load \verb/pa_lex.cmo/ using
one of the following methods:

\begin{itemize}

\item Either by adding \verb/pa_lex.cmo/ in the camlp4 options.
\item Or by adding \verb/#load "pa_lex.cmo";/ in the file.

\end{itemize}

\subsection{How to see the generated code}

You can see the generated code, for a file ``bar.ml'' containing lexers, by
typing:

\begin{verbatim}
     camlp4r pr_r.cmo bar.ml
\end{verbatim}

\section{Conclusion and future work}

We hope that this new feature allows programmers to use recursive
descend parsing, which is natural in functional languages, with the
same comfort and the same readability as programming with ``lex''.

A good possible improvement is a way to extend these lexers
dynamically, to allow Camlp4 to be able to change the lexing of OCaml
programs on the fly, as it already does for the parsing with the
extensible grammars, with the statement EXTEND.

\end{document}
