% $Id$

\documentclass[11pt]{article}
\usepackage{geometry}

\begin{document}

\title{A syntax of lexers looked as parsers of streams of characters\\
  in OCaml using Camlp4}

\date{}
\author{Daniel de Rauglaudre, Patrick Meumeu Yomsi, Omar Kermia\\
INRIA Rocquencourt,
78153 Le Chesnay Cedex \\
\{daniel.de\_rauglaudre, patrick.meumeu, omar.kermia\}@inria.fr}

\thispagestyle{empty}

\maketitle

\begin{abstract}
In this paper, we give a new simplified syntax for lexers,
i.e. parsers analyzing streams of characters. It has been implemented
in Camlp4. This syntax is shorter in length and more readable than its
equivalent version written with classical stream parsers.
\end{abstract}

\section{Introduction}

Classical stream parsers apply to any kind of OCaml values. Buf for
the specify type ``character'', it is possible to shorten codes in
several ways, in particular by using strings to group several
characters together and by hidding the management of a buffer
gathering the characters read (the ``lexing buffer'').

In order to motivate our work, here is an example. With the new syntax,
we are able to write the following function definition:

\begin{verbatim}
       value rec ident = lexer [ "A..Za..z0..9_'\128..\255" ident! | ];
\end{verbatim}

This code is strictly equivalent to the following function, using classical
parsers:

\begin{verbatim}
       value rec ident buf =
         parser
         [ [: `('A'..'Z' | 'a'..'z' | '0'..'9' | '_' | ''' | '\128'..'\255' as c);
               buf = ident (B.add c buf) ! :] -> buf
         | [: :] -> buf ];
\end{verbatim}

We notice that, in the first version, the pattern representing several
kinds of characters (an ``or'' pattern) is written as a simple string,
and that the implicit lexing buffer, managed by variable ``buf'',
never appears: it is implicitely generated by the syntax expander.

The rest of the paper is structured as follows: section~\ref{syntax}
gives the description of this new syntax, section~\ref{semantics}
details the semantics and the directions for use. The future work
follows, section~\ref{future}. We give the conclusion
section~\ref{conclusion}.

\section{Syntax}
\label{syntax}

\begin{verbatim}
            expression ::= <usual expression>
                         | lexer
                 lexer ::= "lexer" "[" rules "]"
                 rules ::= rules rule
                         | <nothing>
                  rule ::= symbols [ "->" action "]"
               symbols ::= symbols symbol error
                         | <nothing>
                symbol ::= "_" no_record
                         | STRING no_record
                         | simple_expression
                         | "?=" "[" lookaheads "]"
                         | "[" rules "]"
             no_record ::= "/"
                         | <nothing>
     simple_expression ::= LIDENT
                         | CHAR
                         | "(" <expression> ")"
            lookaheads ::= lookaheads "|" lookahead_sequence
                         | lookahead_sequence
    lookahead_sequence ::= lookahead_symbols
                         | STRING
     lookahead_symbols ::= lookahead_symbols lookahead_symbol
                         | lookahead_symbol
      lookahead_symbol ::= CHAR
                         | "_"
                 error ::= "?" STRING
                         | "?" simple_expression
                         | "!"
                         | <nothing>
               action ::= <expression>
\end{verbatim}

The syntax of the entry $<$expression$>$ of the OCaml language is also
extended this way:

\begin{verbatim}
            expression ::= "$" "add" STRING
                         | "$" "buf"
                         | "$" "empty"
                         | "$" "pos"
\end{verbatim}

The identifiers ``add'', ``buf'', ``empty'' and ``pos'' are not
keywords, they do not become reserved words. On the contrary,
``\verb/lexer/'' is a new keyword and cannot be used as future
identifier.

\section{Semantics}
\label{semantics}

A lexer defined in the syntax above is a shortcut version of a parser
applied to the specific case of streams of characters. It could be
written with a normal parser. The proposed syntax is much shorter,
easier to use and to understand, and silently takes care of the lexing
buffer for the programmer. The lexing buffers are functional
structures, i.e. they are passed as parameter to called functions and
returned by them.

They are of the type:

\begin{verbatim}
      B.t -> Stream.t char -> t1
\end{verbatim}

... where ``\verb/t1/'' is some type, depending on what the lexer
returns. If there is no semantic action (since it it optional), it it
\verb/B.t/.

\verb/B/ is a module which must be defined by the user. It has to
contain the lexing buffer type \verb/t/ and some variables and
functions:

\begin{itemize}
\item \verb/empty/: the empty buffer
\item \verb/add/: the way to add a character to a buffer
\item \verb/get/: the way to get a string from the buffer
\end{itemize}

A possible implementation, using ``\verb/list char/'' as type
``\verb/t/'' could be:

\begin{verbatim}
       (* converting a reversed list of char into a string *)
       value rev_implode l =
         let s = String.create (List.length l) in
         loop (String.length s - 1) l where rec loop i =
           fun
           [ [c :: l] -> do { s.[i] := c; loop (i - 1) l }
           | [] -> s ]
       ;

       (* the lexing buffer module *)
       module B =
         struct
           type t = list char;
           value empty = [];
           value add c l = [c :: l];
           value get = rev_implode;
         end
       ;
\end{verbatim}

A lexer gets a lexing buffer as first parameter and returns, by
default, i.e. if it has no semantic action, a lexing buffer with all
characters found in the stream, according to the syntax rule it
applies. It is possible to prevent some characters to be inserted in
the lexing buffer by using the ``no record'' feature (see
further).

\subsection{Symbols}

The different kinds or symbols in a rule are:

\begin{itemize}

\item The token ``underscore'', which represents any
  character. Fails only if the stream is empty.

\item A string which represent a matching of any character in the
  string. Notice that it is a choice between all the characters, not
  the sequence of these characters. To indicate a sequence, you have
  to use several symbols, the ones behind the others. Character ranges
  can be inserted using the characters ``\verb/../''. For example, to
  specify a match of any letter or digit, you can write
  \verb/"A..Za..z0..9"/''. The beginning of a comment in the OCaml
  language must be written: \verb/"(" "*"/.

\item An expression corresponding to a call to another lexer, which
  takes the buffer as first parameter and has to return another lexing
  buffer with all characters found in the stream catened to the lexing
  buffer.

\item The sequence ``\verb/?=/'' introducing lookahead characters.
  See the section~\ref{lookahead}.

\item A rule, recursively, between brackets, inlining a lexer.

\end{itemize}

In the first two cases (underscore or string), the symbol can be
followed by the character ``slash'' specifying that the symbol found
has not to be added in the lexing buffer. By default, it is. Useful,
for example, when writing a lexer parsing strings, when the initial
double quote and final double quote have not to be part of the string
itself.

\

Moreover, a symbol can be followed by an optional error indicator,
which can be:

\begin{itemize}

\item The character \verb/?/ (question mark) followed by a string
  expression, telling that, if there is a syntax error at this point
  (i.e. the symbol is not matched although the beginning of the rule
  was), the exception \verb/Stream.Error/ is raised with that string
  as parameter. Without this indicator, it is raised with the empty
  string.

\item The character \verb/!/ (exclamation mark), which is just an
  indicator to let the syntax expander optimize the code. If the
  programmer is sure that the previous symbol never fails (i.e. never
  raises \verb/Stream.Failure/), in particular if this symbol
  recognizes the empty rule, she can add this exclamation mark. If it
  is used correctly (the compiler cannot check it), the behaviour is
  identical as without the \verb/!/, except that the code is shorter
  and faster, and can sometimes be tail recursive. If the indication
  is not correct, the behaviour of the lexer is undefined.

\end{itemize}

\subsection{Specific expressions}
\label{specific}

When loading this syntax extension, the entry \verb/<expression>/, at
level labelled ``simple'' of the OCaml language is extended with the
following rules:

\begin{itemize}

\item \verb/$add/ followed by a string, specifing that the programmer
  wants to add all characters of the string in the lexing buffer. It
  returns the new lexing buffer. It corresponds to an iteration of
  calls to \verb/B.add/ with all characters of the string with the
  current lexing buffer as initial parameter.

\item \verb/$buf/ which returns the lexing buffer converted into
  string.

\item \verb/$empty/ which returns the empty lexing buffer.

\item \verb/$pos/ which return the current position in the stream in
  number of characters (starting at zero).

\end{itemize}

\subsection{Lookahead}
\label{lookahead}

Lookahead is useful in some cases, when factorization of rules is
impossible. To understand how it is useful, a first remark must
be done, about the usual behaviour of Camlp4 stream parsers.

Stream parsers (including these lexers) use a limited parsing
algorithm, in a way that when the first symbol of a rule is matched,
all the following symbols of the same rule must apply, otherwise it is
a syntax error. There is no backtrack. In most of the cases, left
factorization of rules resolve conflicting problems. For example, when
one writes a parser of tokens to recognize both the typicall grammar
rules ``if..then..else'' and the shorter ``if..then..'', the solution
is to write a rule starting with ``if..then..'' followed with a call
to a parser recognizing ``else..'' or nothing.

Sometimes, however, this left factorization is not possible. A
lookahead of the stream to check the presence of some elements (these
element being characters, if we are using this ``lexer'' syntax) might
be necessary to decide whether or not it is a good idea to continue
the rule. This lookahead feature may unfreeze the first stream
characters but does not remove them from the stream.

Syntactically, a lookahead starts with \verb/?=/ and is followed by
one or several lookahead sequences separated by the vertical bar
\verb/|/, the whole list being enclosed by braces.

If there are several lookaheads, they must all be of the same size
(contain the same number of characters).

If lookahead sequence is just a string, it corresponds to all characters
of this string in the order.

Examples of lookaheads:

\begin{verbatim}
       ?= [ _ ''' | '\\' _ ]
       ?= [ "<<" | "<:" ]
\end{verbatim}

The first line above matches a stream whose second character is a
quote or a stream whose first character is a backslash.  The second
line matches a stream starting with the two characters \verb/</ and
\verb/</ or starting with the two characters \verb/</ and \verb/:/.

\subsection{Semantic actions of rules}

By default, the result of a ``lexer'' is the current lexing buffer,
which is of type ``\verb/B.t/''. But it is possible to return other
values, by adding ``\verb/->/'' at end of rules followed by the
expression you want to return, like in usual pattern matching in
OCaml.

An interesting result, for example, could be the string corresponding
to the characters of the lexing buffer. This can be obtained by
returning the value ``\verb/$buf/'' (see section~\ref{specific})

\subsection{A complete example}

A complete example can be seen in the sources of Camlp4, file
``lib/plexer.ml''. This is the lexer of OCaml, either ``normal'' or
``revised'' syntax.

\subsection{Compiling}

To compile a file containing lexers, just load \verb/pa_lex.cmo/ using
one of the following methods:

\begin{itemize}

\item Either by adding \verb/pa_lex.cmo/ among the camlp4 options. See
  the camlp4 manual page or documentation.
\item Or by adding \verb/#load "pa_lex.cmo";/ anywhere in the file,
  before the usages of this ``lexer'' syntax.

\end{itemize}

\subsection{How to control the generated code}

You can see the generated code, for a file ``bar.ml'' containing
lexers, by typing in a command line:

\begin{verbatim}
     camlp4r pr_r.cmo bar.ml
\end{verbatim}

or, possibly, if ``\verb/pa_lex.cmo/'' is not loaded in the file ``bar.ml'':

\begin{verbatim}
     camlp4r pa_lex.cmo pr_r.cmo bar.ml
\end{verbatim}

\section{Future work}
\label{future}

We plan to experiment these lexer in real OCaml programs. Perhaps
syntax might change, or other features be added. An interesting one
could be a way to allow lexers to be extended at run time, to give to
lexers the same power as the Camlp4 extensible grammars offers at
parsing level.

\section{Conclusion}
\label{conclusion}

We think that this new feature can encourage programmers to use the
stream parsers technology for their lexers. Their shorter syntax has
almost the same comfort and the same readability as the programs
written in ``ocamllex''. Although these lexers are not as powerful as
``ocamllex'' since, sometimes, explicit left factorization or
characters lookaheads must be necessary, they are more functional
(they can have extra parameters, and the lexing buffer is not a
mutable variable) and are more included in the language, since they
are pure syntactic sugar.

\end{document}
