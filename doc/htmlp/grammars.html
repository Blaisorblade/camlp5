<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
  <!-- $Id: grammars.html,v 1.10 2007/07/15 10:33:42 deraugla Exp $ -->
  <!-- Copyright (c) 2007 INRIA -->
  <title>extensible grammars</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="shortcut icon" href="c4logo.png" />
  <link rel="stylesheet" type="text/css" href="styles/base.css" />
</head>
<body>

<div id="menu">
</div>

<div id="content">

<h1 class="top">Extensible grammars</h1>

<p>This chapter describes the whole syntax and semantics of the
extensible grammars of camlp5.</p>

<p>The extensible grammars are the most advanced parsing tool of
camlp5. They apply to streams of characters using a lexer which has to
be previously defined by the programmer. In camlp5, the syntax of the
ocaml language is defined with extensible grammars, which makes camlp5
a bootstrapped system (it compiles its own features by itself).</p>

<h2>Getting started</h2>

<p>The extensible grammars are a system to build <em>grammar
entries</em> which can be extended dynamically. A grammar entry is an
abstract value internally containing a stream parser. The type of a
grammar entry is <tt>"Grammar.Entry.e t"</tt> where <tt>"t"</tt> is
the type of the values returned by the grammar entry.</p>

<p>To start with extensible grammars, it is necessary to build
a <em>grammar</em>, a value of type "<tt>Grammar.g</tt>", using
the function "<tt>Grammar.gcreate</tt>":</p>

<pre>
value g = Grammar.gcreate lexer;
</pre>

<p>where "<tt>lexer</tt>" is a lexer previously defined. See the
chapter explaining how make lexers for extensible grammars (<em>to be
written</em>). In a first time, it is possible to use a lexer of the
module "<tt>Plexer</tt>" provided by camlp5:</p>

<pre>
value g = Grammar.gcreate (Plexer.gmake ());
</pre>

<p>Each grammar entry is associated with a grammar. Only grammar
entries of the same grammar can call each other. To create a grammar
entry, one has to use the function "<tt>Grammar.Entry.create</tt>" with
takes the grammar as first parameter and a name as second parameter. This
name is used in case of syntax errors. For example:</p>

<pre>
value exp = Grammar.Entry.create g "expression";
</pre>

<p>To apply a grammar entry, the function
"<tt>Grammar.Entry.parse</tt>" can be used. Its first parameter is the
grammar entry, the second one a stream of characters:</p>

<pre>
Grammar.Entry.parse exp (Stream.of_string "hello");
</pre>

<p>But if you experiment this, since the entry was just created
without any rules, you receive an error message:</p>

<pre>
Stream.Error "entry [expression] is empty"
</pre>

<p>To add grammar rules to the grammar entry, it is necessary
to <em>extend</em> it, using a specific syntactic statement:
"<tt>EXTEND</tt>".</p>

<h2>Syntax of the EXTEND statement</h2>

<p>The "<tt>EXTEND</tt>" statement is added in the expressions of the
ocaml language when the syntax extension kit "<tt>pa_extend.cmo</tt>"
is loaded. Its syntax is:</p>

<pre>
          expression ::= extend
              extend ::= "EXTEND" extend-body "END"
         extend-body ::= global-opt entries
          global-opt ::= "GLOBAL" ":" entry-names ";"
                       | &lt;nothing&gt;
         entry-names ::= entry-name entry-names
                       | entry-name
               entry ::= entry-name ":" position-opt "[" levels "]"
        position-opt ::= "FIRST"
                       | "LAST"
                       | "BEFORE" label
                       | "AFTER" label
                       | "LEVEL" label
                       | &lt;nothing&gt;
              levels ::= level "|" levels
                       | level
               level ::= label-opt assoc-opt "[" rules "]"
           label-opt ::= label
                       | &lt;nothing&gt;
           assoc-opt ::= "LEFTA"
                       | "RIGHTA"
                       | "NONA"
                       | &lt;nothing&gt;
               rules ::= rule "|" rules
                       | rule
                rule ::= psymbols-opt "->" expression
                       | psymbols-opt
        psymbols-opt ::= psymbols
                       | &lt;nothing&gt;
            psymbols ::= psymbol ";" psymbols
                       | psymbol
             psymbol ::= symbol
                       | pattern "=" symbol
              symbol ::= keyword
                       | entry-name
                       | entry-name "LEVEL" label
                       | "SELF"
                       | "NEXT"
                       | "LIST0" symbol
                       | "LIST0" symbol "SEP" symbol
                       | "LIST1" symbol
                       | "LIST1" symbol "SEP" symbol
                       | "OPT" symbol
                       | "(" symbol ")"
             keyword ::= string
               label ::= string
          entry-name ::= qualid
              qualid ::= qualid "." qualid
                       | uident
                       | lident
              uident ::= 'A'-'Z' ident
              lident ::= ('a'-'z' | '_' | utf8-char) ident
               ident ::= ident-char*
          ident-char ::= ('a'-'a' | 'A'-'Z' | '0'-'9' | '_' | ''' | utf8-char)
           utf8-char ::= '\128'-'\255'
</pre>

<p>Other statements, "<tt>GEXTEND</tt>", "<tt>DELETE_RULE</tt>",
"<tt>GDELETE_RULES</tt>" are also defined by the same syntax extension
kit. See further.</p>

<p>In the description above, ony "<tt>EXTEND</tt>" and "<tt>END</tt>"
are new keywords (reserved words which cannot be used in variables,
constructors or module names). The other strings
(e.g. "<tt>GLOBAL</tt>", "<tt>LEVEL</tt>", "<tt>LIST0</tt>",
"<tt>LEFTA</tt>", etc.) are not reserved.</p>

<h2>Semantics of the EXTEND statement</h2>

<p>The EXTEND statement starts with the "<tt>EXTEND</tt>" keyword and ends
with the "<tt>END</tt>" keyword.</p>

<h3>Global indicator</h3>

<p>After the first keyword, it is possible to see the identifier
"<tt>GLOBAL</tt>" followed by a colon, a list of entries names and a
semicolon. It says that these entries correspond to visible
(previously defined) entry variables, in the context of the EXTEND
statement, the other ones being locally and silently defined
inside.</p>

<ul>
<li>If an entry, which is extended in the EXTEND statement, is in the
  GLOBAL list, but is not defined in the context of the EXTEND
  statement, the ocaml compiler will fail with the error "unbound
  value".</li>
<li>If there is no GLOBAL indicator, and an entry, which is extended
  in the EXTEND statement, is not defined in the contex of the EXTEND
  statement, the ocaml compiler will also fail with the error "unbound
  value".</li>
</ul>

<p>Example:</p>

<pre>
value exp = Grammar.Entry.create g "exp";
EXTEND
  GLOBAL: exp;
  exp: [ [ x = foo; y = bar ] ];
  foo: [ [ "foo" ] ];
  bar: [ [ "bar" ] ];
END;
</pre>

<p>The entry "exp" is an existing variable (defined by value exp =
...). On the other hand, the entries "foo" and "bar" have not been
defined. Because of the GLOBAL indicator, the system define them
locally.</p>

<p>Without the GLOBAL indicator, the three entries would have been
considered as global variables, therefore the ocaml compiler would
say "unbound variable" under the first undefined entry, "foo".</p>

<h3>Entries list</h3>

<p>Then the list of entries extensions follow. An entry extension
starts with the entry name followed by a colon. An entry may have
several levels corresponding to several stream parsers which call the
ones the others (see further).</p>

<h4>Optional position</h4>

<p>After the colon, it is possible to specify a where to insert the
defined levels:</p>

<ul>
  <li>The identifier "<tt>FIRST</tt>" (resp. "<tt>LAST</tt>")
    indicates that the level must be inserted before (resp. after) all
    possibly existing levels of the entry. They become their first
    (resp. last) levels.</li>
  <li>The identifier "<tt>BEFORE</tt>" (resp. "<tt>AFTER</tt>")
    followed by a level label (a string) indicates that the levels
    must be inserted before (resp. after) that level, if it exists. If
    it does not exist, the extend statement fails at run time.</li>
  <li>The identifier "<tt>LEVEL</tt>" followed by a level label
    indicates that the first level defined in the extend statement
    must be inserted at the given level, extending and modifying
    it. The other levels defined in the statement are inserted after
    this level, and before the possible levels following this
    level. If there is no level with this label, the extend statement
    fails at run time.</li>
  <li>By default, if the entry has no level, the levels defined in the
    statement are inserted in the entry. Otherwise the first defined
    level is inserted at the first level of the entry, extending or
    modifying it. The other levels are inserted afterwards (before the
    possible second level which may previously exist in the entry).</li>
</ul>

<h4>Levels</h4>

<p>After the optional "position", the <em>level</em> list follow. The
levels are separated by vertical bars, the whole list being between
brackets.</p>

<p>A level starts with an optional label, which corresponds to its name.
This label is useful to specify this level in case of future extension,
using the <em>position</em> (see previous section).</p>

<p>The level continues with an optional associativity indicator, which
can be:</p>

<ul>
  <li>LEFTA for left associativity (default),</li>
  <li>RIGHTA for right associativity,</li>
  <li>NONA for no associativity.</li>
</ul>

<h4>Rules</h4>

<p>At last, the grammar <em>rule</em> list appear. The rules are
separated by vertical bars, the whole list being brackets.</p>

<p>A rule looks like a match case in the "<tt>match</tt>" statement or
a parser case in the "<tt>parser</tt>" statement: a list of psymbols
(see next paragraph) separated by semicolons, followed by a right
arrow and an expression, the semantic action. Actually, the right
arrow and expression are optional: in this case, it is equivalent to
an expression which would be the unit "<tt>()</tt>" constructor.</p>

<p>A psymbol is either a pattern, followed with the equal sign and a
symbol, or by a symbol alone. It corresponds to a test of this symbol,
whose value is bound to the pattern if any.</p>

<h4>Symbols</h4>

<p>A symbol is either:</p>

<ul>
  <li>a keyword (a string): the input must match this keyword,</li>
  <li>an entry name, which correspond to a call to this entry,</li>
  <li>an entry name followed by the identifier "<tt>LEVEL</tt>" and a
    level label, which correspond to the call to this entry at that
    level,</li>
  <li>the identifier "<tt>SELF</tt>" which is a recursive call to the
    present entry, according to the associativity (i.e. it may be a
    call at the current level, to the next level, or to the top level
    of the entry): "<tt>SELF</tt>" is equivalent to the name of the
    entry itself,</li>
  <li>the identifier "<tt>NEXT</tt>", which is a call to the next level
    of the current entry,</li>
  <li>a meta symbol (see further),</li>
  <li>a symbol between parentheses.</li>
</ul>

<p>The syntactic analysis follow the list of symbols. If it fails,
depending on the first items of the rule (see the section about the
kind of grammars recognized (<em>to be written</em>)):</p>

<ul>
  <li>the parsing may fail by raising the exception
    "<tt>Stream.Error</tt>"</li>
  <li>the parsing may continue with the next rule.</li>
</ul>

<h4>Rules insertion</h4>

<p>Remember that "<tt>EXTEND</tt>" is a statement, not a declaration:
the rules are added in the entries at run time. Each rule is
internally inserted in a tree, allowing the left factorization of the
rule. For example, if two rules have as list of symbols:</p>

<pre>
"if"; e1 = expr; "then"; e2 = expr
"if"; e1 = expr; "then"; e2 = expr; "else"; e3 = expr
</pre>

<p>the rules are inserted in a tree and the result look like:<p>

<pre>
"if"
   expr
     "then"
       expr
         "else"
           expr
         &lt;nothing&gt;
</pre>

<p>This tree is built as long as rules are inserted. When used, by
applying the function "<tt>Grammar.Entry.parse</tt>" to the current
entry, the input is matched with that tree, starting from the tree
root, descending on it as long as the parsing advances.</p>

<p>There is a different tree by entry level.</p>

<h4>Meta symbols</h4>

<p>Extra symbols exist, allowing to manipulate lists or optional
symbols. They are:</p>

<p>... to be completed ...</p>

<div class="trailer">
</div>

</div>

</body>
</html>
