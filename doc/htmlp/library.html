<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <!-- $Id: library.html,v 1.4 2007/08/19 18:24:21 deraugla Exp $ -->
  <!-- Copyright (c) 2007 INRIA -->
  <title>Library</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="styles/base.css"
        title="Normal" />
</head>
<body>

<div id="menu">
</div>

<div id="content">

<h1 class="top">Library</h1>

<div id="tableofcontents">
</div>

<h2>Stdpp module</h2>

<p>Building and combining locations (this module should be renamed
  [Ploc] one day).</p>

<dl>
  <dt><tt>type location = 'abstract;</tt></dt>
</dl>

<h3>located exceptions</h3>

<dl>
  <dt><tt>exception Exc_located of location and exn;</tt></dt>
  <dd>[Exc_located loc e] is an encapsulation of the exception [e] with
    the input location [loc]. To be used to specify a location
    for an error. This exception must not be raised by [raise] but
    rather by [raise_with_loc] (see below), to prevent the risk of
    several encapsulations of [Exc_located].</dd>
  <dt><tt>value raise_with_loc : location -> exn -> 'a;</tt></dt>
  <dd>[raise_with_loc loc e], if [e] is already the exception [Exc_located],
    re-raise it (ignoring the new location [loc]), else raise the
    exception [Exc_located loc e].</dd>
</dl>

<h3>making locations</h3>

<dl>
  <dt><tt>value make_lined_loc : int -> int -> (int * int) ->
      location;</tt></dt>
  <dd>[make_lined_loc line_nb bol_pos (bp, ep)] creates a location
    starting at line number [line_nb], where the position of the
    beginning of the line is [bol_pos] and between the positions [bp]
    (included) and [ep] excluded. The positions are in number of
    characters since the begin of the stream.</dd>
  <dt><tt>value make_loc : (int * int) -> location;</tt></dt>
  <dd>[make_loc] is like [make_lined_loc] except that the line number
    is not provided (to be used e.g. when the line number is
    unknown).</dd>
</dl>

<dl>
  <dt><tt>value dummy_loc : location;</tt></dt>
  <dd>[dummy_loc] is a dummy location, used in situations when
    location has no meaning.</dd>
</dl>

<h3>getting location info</h3>

<dl>
  <dt><tt>value first_pos : location -> int;</tt></dt>
  <dd>[first_pos loc] returns the position of the begin of the location in
    number of characters since the beginning of the stream.</dd>
  <dt><tt>value last_pos : location -> int;</tt></dt>
  <dd>[first_pos loc] returns the position of the first character not
    of the location in number of characters since the beginning of
    the stream.</dd>
  <dt><tt>value line_nb : location -> int;</tt></dt>
  <dd>[line_nb loc] returns the line number of the location or [-1] if
    the location does not contain a line number (i.e. built the old
    way with [make_loc] above.</dd>
  <dt><tt>value bol_pos : location -> int;</tt></dt>
  <dd>[line_nb loc] returns the position of the beginning of the line
    of the location in number of characters since the beginning of
    the stream, or [0] if the location does not contain a line number
    (i.e. built the old with with [make_loc] above.</dd>
</dl>

<h3>combining locations</h3>

<dl>
  <dt><tt>value encl_loc : location -> location -> location;</tt></dt>
  <dd>[encl_loc loc1 loc2] returns the location starting at the smallest
    start and ending at the greatest end of the locations [loc1] and
    [loc2]. In other words, it is the location enclosing [loc1] and
    [loc2].</dd>
  <dt><tt>value shift_loc : int -> location -> location;</tt></dt>
  <dd>[shift_loc sh loc] returns the location [loc] shifted with [sh]
    characters. The line number is not recomputed.</dd>
  <dt><tt>value sub_loc : location -> int -> int -> location;</tt></dt>
  <dd>[sub_loc loc sh len] is the location [loc] shifted with [sh] characters
    and with length [len]. The previous ending position of the location
    is lost.</dd>
  <dt><tt>value after_loc : location -> int -> int -> location;</tt></dt>
  <dd>[after_loc loc sh len] is the location just after loc (starting at
    the end position of [loc]) shifted with [sh] characters and of length
    [len].</dd>
</dl>

<h3>miscellaneous</h3>

<dl>
  <dt><tt>value loc_name : ref string;</tt></dt>
  <dd>[loc_name.val] is the name of the location variable used in
    grammars and in the predefined quotations for OCaml syntax
    trees. Default: ["loc"].</dd>
</dl>

<dl>
  <dt><tt>value line_of_loc : string -> location -> (string * int *
      int * int);</tt></dt>
  <dd>[line_of_loc fname loc] reads the file [fname] up to the
    location [loc] and returns the real input file, the line number and
    the characters location in the line; the real input file can be
    different from [fname] because of possibility of line directives
    typically generated by /lib/cpp.</dd>
</dl>

<h2>Token module</h2>

<p>Lexing for camlp5 grammars.</p>

<p>This module defines the Camlp5 lexer type to be used in extensible
  grammars (see module [Grammar]). It also provides some useful
  functions to create lexers (this module should be renamed [Plexing]
  one day).</p>

<dl>
  <dt><tt>type pattern = (string * string);</tt></dt>
  <dd>Type for values used by the generated code of the EXTEND
    statement to represent terminals in entry rules.
  <ul>
    <li>The first string is the constructor name (must start with an
      uppercase character). When it is empty, the second string is
      supposed to be a keyword.</li>
    <li>The second string is the constructor parameter. Empty if it
      has no parameter (corresponding to the 'wildcard' pattern).</li>
    <li>The way tokens patterns are interpreted to parse tokens is
      done by the lexer, function [tok_match] below.</li>
    </ul>
  </dd>
</dl>

<dl>
  <dt><tt>exception Error of string;</tt></dt>
  <dd>A lexing error exception to be used by lexers.</dd>
</dl>

<h3>Lexer type</h3>

<pre style="border:0; margin-left: 1cm">
type glexer 'te =
  { tok_func : lexer_func 'te;
    tok_using : pattern -> unit;
    tok_removing : pattern -> unit;
    tok_match : mutable pattern -> 'te -> string;
    tok_text : pattern -> string;
    tok_comm : mutable option (list location) }
</pre>

<dl><dd>
    The type for lexers compatible with camlp5 grammars. The parameter
    type ['te] is the type of the tokens.
    <ul>
      <li>The field [tok_func] is the main lexer function. See
        [lexer_func] type below.</li>
      <li>The field [tok_using] is a function called by the [EXTEND]
        statement to warn the lexer that a rule uses this pattern
        (given as parameter). This allow the lexer 1/ to check that
        the pattern constructor is really among its possible
        constructors 2/ to enter the keywords in its tables.</li>
      <li>The field [tok_removing] is a function called by the
        [DELETE_RULE] statement to warn the lexer that a rule using
        this pattern (given as parameter) has been deleted. This allow
        the lexer to possibly remove this keyword from its tables if
        there are no more rules using it.</li>
      <li>The field [tok_match] is a function called by the camlp5
        grammar system to ask the lexer how the input tokens have to
        be matched against the patterns. Warning: for efficiency, this
        function has to be written as a function taking patterns as
        parameters and, for each pattern value, returning a function
        matching a token, <em>not</em> as a function with two
        parameters.</li>
      <li>The field [tok_text] is a function called by the grammar
        system to get the name of the tokens for the error messages,
        in case of syntax error, or for the displaying of the rules
        of an entry.</li>
      <li>The field [tok_comm] is a mutable place where the lexer can
        put the locations of the comments, if its initial value is not
        [None]. If it is [None], nothing has to be done by the
        lexer.</li>
    </ul>
</dd></dl>

<dl>
  <dt><tt>and lexer_func 'te = Stream.t char -> (Stream.t 'te *
      location_function);</tt></dt>
  <dd>The type of a lexer function (field [tok_func] of the type
    [glexer]). The character stream is the input stream to be
    lexed. The result is a pair of a token stream and a location
    function (see below) for this tokens stream.</dd>
</dl>

<dl>
  <dt><tt>and location_function = int -> location;</tt></dt>
  <dd>The type of a function giving the location of a token in the
    source from the token number in the stream (starting from
    zero).</dd>
</dl>

<p>... the following lines have to be restructured ...</p>

<pre>

type location = Stdpp.location;
value make_loc : (int * int) -> location;
value dummy_loc : location;
  (** compatibility camlp5 distributed with ocaml *)

value lexer_text : pattern -> string;
   (** A simple [tok_text] function for lexers *)

value default_match : pattern -> (string * string) -> string;
   (** A simple [tok_match] function for lexers, appling to token type
       [(string * string)] *)

(** {6 Lexers from char stream parsers or ocamllex function}

   The functions below create lexer functions either from a [char stream]
   parser or for an [ocamllex] function. With the returned function [f],
   the simplest [Token.lexer] can be written:
   {[
          { Token.tok_func = f;
            Token.tok_using = (fun _ -> ());
            Token.tok_removing = (fun _ -> ());
            Token.tok_match = Token.default_match;
            Token.tok_text = Token.lexer_text }
   ]}
   Note that a better [tok_using] function should check the used tokens
   and raise [Token.Error] for incorrect ones. The other functions
   [tok_removing], [tok_match] and [tok_text] may have other implementations
   as well. *)

value lexer_func_of_parser :
  ((Stream.t char * ref int * ref int) -> ('te * location)) -> lexer_func 'te;
   (** A lexer function from a lexer written as a char stream parser
       returning the next token and its location. The two references
       with the char stream contain the current line number and the
       position of the beginning of the current line. *)
value lexer_func_of_ocamllex : (Lexing.lexbuf -> 'te) -> lexer_func 'te;
   (** A lexer function from a lexer created by [ocamllex] *)

value make_stream_and_location :
  (unit -> ('te * location)) -> (Stream.t 'te * location_function);
   (** General function *)

(** {6 Useful functions and values} *)

value eval_char : string -> char;
value eval_string : location -> string -> string;
   (** Convert a char or a string token, where the backslashes had not
       been interpreted into a real char or string; raise [Failure] if
       bad backslash sequence found; [Token.eval_char (Char.escaped c)]
       returns [c] and [Token.eval_string (String.escaped s)] returns [s] *)

value restore_lexing_info : ref (option (int * int));
value line_nb : ref (ref int);
value bol_pos : ref (ref int);
   (** Special variables used to reinitialize line numbers and position
       of beginning of line with their correct current values when a parser
       is called several times with the same character stream. Necessary
       for directives (e.g. #load or #use) which interrupt the parsing.
       Without usage of these variables, locations after the directives
       can be wrong. *)
</pre>

<h2>Plexer module</h2>

<p>This module contains the lexer used for ocaml syntax (revised and
  normal).</p>

<p>... to be continued ...</p>

<h2>Gramext module</h2>

<p>... to be written ...</p>

<h2>Grammar module</h2>

<p>... to be written ...</p>

<h2>Extfold module</h2>

<p>... to be written ...</p>

<h2>Extfun module</h2>

<p>... to be written ...</p>

<h2>Eprinter module</h2>

<p>... to be written ...</p>

<h2>Fstream module</h2>

<p>... to be written ...</p>

<h2>Pretty module</h2>

<p>... to be written ...</p>

<div class="trailer">
</div>

</div>

</body>
</html>
