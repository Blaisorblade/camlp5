<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
  <!-- $Id: quot.html,v 1.6 2007/07/25 10:12:21 deraugla Exp $ -->
  <!-- Copyright (c) 2007 INRIA -->
  <title>quotations</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="styles/base.css"
        title="Normal" />
</head>
<body>

<div id="menu">
</div>

<div id="content">

<h1 class="top">Quotations</h1>

<p>The quotations are a syntax extension in camlp5 allowing to build
  expressions and patterns in any syntax independant from the one of
  ocaml. Quotations are <em>expanded</em>, i.e. transformed, at parse
  time to produce normal syntax trees, like the rest of the program.
  Quotations <em>expanders</em> are normal ocaml functions writable by
  any programmer.</p>

<p>The aim of quotations is to use concrete syntax for manipulating
  abstract values, what make programs easier to write, read, modify,
  and understand. Their drawback is that they are isolated from the
  rest of the program, in opposition to <a href="syntext.html">syntax
  extensions</a>, which are included in the language.</p>

<div id="tableofcontents">
</div>

<h2>Introduction</h2>

<p>A quotation is syntactically enclosed by specific quotes formed by
  less (<tt>&lt;</tt>) and greater (<tt>&gt;</tt>) signs. Namely:</p>

<ul>
  <li>starting with either "<tt>&lt;&lt;</tt>" or "<tt>&lt;:ident&lt;</tt>"
    where "<tt>ident</tt>" is the quotation name,</li>
  <li>ending with "<tt>>></tt>"</li>
</ul>

<p>Examples:</p>

<pre>
  &lt;&lt; \x.x x >>
  &lt;:foo&lt; hello, world >>
  &lt;:bar&lt; @#$%;* >>
</pre>

<p>The text between these particular parentheses can be any text. It
  may contain enclosing quotations and the characters "<tt>&lt;</tt>",
  "<tt>&gt;</tt>" and "<tt>\</tt>" can be escaped by
  "<tt>\</tt>". Notice that possible double-quote, parentheses, ocaml
  comments do not have necessary to balance inside them.</p>

<p>As far as the lexer is concerned, a quotation is just a kind of
  string.</p>

<h2>Quotation expander</h2>

<p>The quotations are treated at parse time. Each quotation name is
  associated with a <em>quotation expander</em>, a function
  transforming the content of the quotation into a syntax tree. There
  are actually two expanding functions, depending on the fact that the
  quotation is in the context of an expression or if it is in the
  context of a pattern.</p>

<p>If a quotation has no associated quotation expander, a parsing
  error is displayed and the compilation fails.</p>

<p>The quotation expander, or, rather, expanders, are functions taking
  the quotation string as parameter and returning a syntax tree. There
  is no constraint about which parsing technology is used. It can be
  <a href="parsers.html">stream
  parsers</a>, <a href="grammars.html">extensible grammars</a>, string
  scanning, ocamllex and yacc, any.</p>

<p>To build syntax trees, camlp5 provides a way to easily build them:n
  see the <a href="ml_ast.html">chapter</a> about them: it is possible
  to build abstract syntax through concrete syntax using,
  precisely... quotations.</p>

<h2>Defining a quotation</h2>

<h3>By syntax tree</h3>

<p>To define a quotation, it is necessary to program the quotation
  expanders and to, finally, end the source code with a call to:</p>

<pre>
  Quotation.add name (Quotation.ExAst (f_expr, f_patt));
</pre>

<p>where "<tt>name</tt>" is the name of the quotation, and
  "<tt>f_expr</tt>" and "<tt>f_patt</tt>" the respective quotations
  expanders for expressions and patterns.</p>

<p>Then, after compilation of the source file (without linking, i.e.
  using option "-c" of the ocaml compiler), an object file is created
  (ending with ".cmo"), which can be used as syntax
  extension <em>kit</em> of camlp5.</p>

<h3>By string</h3>

<p>There is, actually, another way to program the expander: an alone
  function which returns, not a syntax tree, but just a string which is
  parsed, afterwards, by the system. This function takes a boolean as
  first parameter telling whether the quotation is in position of
  expression (True) or in position of a pattern (False).</p>

<p>If using that way, the source file must end with:</p>

<pre>
  Quotation.add name (Quotation.ExStr f);
</pre>

<p>where "<tt>f</tt>" is that quotation expander. The advantage of
  this second approach is that it is simple to understand and use.
  The drawback is that there is no way to specify different source
  locations for different parts of the quotation (what may be
  important in semantic error messages).</p>

<h3>Default quotation</h3>

<p>It is possible to use some quotation without its name. Use for that
  the variable "<tt>Quotation.default_quotation</tt>". For example,
  ending a file by:</p>

<pre>
  Quotation.add "foo" (Quotation.ExAst (f_expr, f_patt));
  Quotation.default.val := "foo";
</pre>

<p>allows to use the quotation "foo" without its name, i.e.:</p>

<pre>
  &lt;&lt; ... >>
</pre>

<p>instead of:</p>

<pre>
  &lt;:foo&lt; ... >>
</pre>

<p>If several files set the variable "<tt>Quotation.default</tt>", the
  default quotation applies to the last loaded one.</p>

<h2>Antiquotations</h2>

<p>A quotation obeys its own rules of lexing and parsing. Its result is
  a syntax tree, of type "<tt>Pcaml.expr</tt>" if the quotation is in the
  context of an expression, or "<tt>Pcaml.patt</tt>" if the quotation is
  in the context of a pattern.</p>

<p>But it can be interesting to insert portions of expressions or
  patterns of the enclosing context in its own quotations. For that,
  the syntax of the quotation must define a syntax
  for <em>antiquotations areas</em>. It can be, for example:</p>

<ul>
  <li>A character introducing a variable: in this case the antiquotation
    can just be a variable.</li>
  <li>A couple of characters enclosing the antiquotations. For
    example, in the predefined <a href="ml_ast.html">syntax tree
    quotations</a>, the antiquotations are enclosed with dollar
    ("<tt>$</tt>") signs.</li>
</ul>

<p>In quotations, the locations in the resulting syntax tree are all
  set to the location of the quotation itself (if this resulting tree
  contains locations, they are overwritten with this
  location). Consequently, if there are semantic (typing) errors, the
  ocaml compiler will underline the entire quotation.</p>

<p>But in antiquotations, since they can be inserted in the resulting
  syntax tree, it is interesting to keep their initial quotations. For
  that, the nodes:</p>

<pre>
  &lt;:expr&lt; $anti:...$ >>
  &lt;:patt&lt; $anti:...$ >>
</pre>

<p>equivalent to:</p>

<pre>
  MLast.ExAnt loc ...
  MLast.PaAnt loc ...
</pre>

<p>are provided (see <a href="ml_ast.html">syntax tree
    quotations</a>).</p>

<p>Let us take an example, without this node, and with this specific
  node.</p>

<p>Let us consider an elementary quotation system whose contents is just
  an antiquotation. This is just a school example, since the quotations
  brackets are not necessary, in this case. But we are going to see how
  the source code is underlined in errors messages.</p>

<h3>Example without antiquotation node</h3>

<p>The code for this quotation is (file "qa.ml"):</p>

<pre>
  #load "q_MLast.cmo";
  let expr s = Grammar.Entry.parse Pcaml.expr (Stream.of_string s) in
  Quotation.add "a" (Quotation.ExAst (expr, fun []));
</pre>

<p>The quotation expander "<tt>expr</tt>" just takes the string
  parameter (the contents of the quotation), and returns the result
  of the expression   parser of the ocaml language.</p>

<p>Compilation:</p>

<pre>
  ocamlc -pp camlp5r -I +camlp5 -c qa.ml
</pre>

<p>Let us test it in the toplevel with a voluntary typing error:</p>

<pre>
  $ ocaml -I +camlp5 camlp5r.cma
          Objective Caml version ...

          Camlp5 Parsing version ...

  # #load "qa.cmo";
  # let x = "abc" and y = 25 in &lt;:a&lt; x ^ y >>;
  Characters 28-41:
    let x = "abc" and y = 25 in &lt;:a&lt; x ^ y >>;
                                ^^^^^^^^^^^^^
  This expression has type int but is here used with type string
</pre>

<p>We observe that the full quotation is underlined, although it concerns
  only the variable "<tt>y</tt>".</p>

<h3>Example with antiquotation node</h3>

<p>Let us consider this second version (file "qb.ml"):</p>

<pre>
  #load "q_MLast.cmo";
  let expr s =
    let ast = Grammar.Entry.parse Pcaml.expr (Stream.of_string s) in
    let loc = Stdpp.make_lined_loc 1 0 (0, String.length s) in
    &lt;:expr&lt; $anti:ast$ >>
  in
  Quotation.add "b" (Quotation.ExAst (expr, fun []));
</pre>

<p>Like above, the quotation expander "<tt>expr</tt>" takes the string
  parameter (the contents of the quotation) and applies the expression
  parser of the ocaml language. But its result, instead of being
  returned ast it is, is enclosed with the antiquotation node. (The
  location built is the location of the whole string.)</p>

<p>Compilation:</p>

<pre>
  ocamlc -pp camlp5r -I +camlp5 -c qb.ml
</pre>

<p>Now the same test gives:</p>

<pre>
  $ ocaml -I +camlp5 camlp5r.cma
          Objective Caml version ...

          Camlp5 Parsing version ...

  # #load "qb.cmo";
  # let x = "abc" and y = 25 in &lt;:b&lt; x ^ y >>;
  Characters 37-38:
    let x = "abc" and y = 25 in &lt;:b&lt; x ^ y >>;
                                         ^
  This expression has type int but is here used with type string
</pre>

<p>Notice that, now, only the variable "<tt>y</tt>" is underlined.</p>

<h3>In conclusion</h3>

<p>In the resulting tree of the quotation expander:</p>

<ul>
  <li>only portions of this tree, which are sons of the expr and patt
    antiquotation nodes, have the right location they have in the
    quotation (provided the quotation expander gives it the right
    location of the antiquation in the quotation),</li>
  <li>the other nodes inherit, as location, the location of the full
    quotation.</li>
</ul>

<h2>A full example: lambda terms</h2>

<p>This example allows to represent lambda terms by a concrete syntax
  and to be able to combine them using antiquotations.</p>

<p>A lambda term is defined like this:</p>

<pre>
  type term =
    [ Lam of string and term
    | App of term and term
    | Var of string ]
  ;
</pre>

<p>Examples:</p>

<pre>
  value fst = Lam "x" (Lam "y" (Var "x"));
  value snd = Lam "x" (Lam "y" (Var "y"));
  value delta = Lam "x" (App (Var "x") (Var "x"));
  value omega = App delta delta;
  value comb_s =
    Lam "x"
      (Lamb "y"
         (Lamb "z"
            (App (App (Var "x") (Var "y")) (App (Var "x") (Var "z")))));
</pre>

<p>Since combinations of lambda term may be complicated, The idea is to
  represent them by quotations in concrete syntax. We want to be able to
  write the examples above like this:</p>

<pre>
  value fst = &lt;&lt; \x.\y.x >>;
  value snd = &lt;&lt; \x.\y.y >>;
  value delta = &lt;&lt; \x.x x >>
  value omega = &lt;&lt; ^delta ^delta >>;
  value comb_s = &lt;&lt; \x.\y.\z.(x y)(x z) >>;
</pre>

<p>which is a classic representation of lambda terms.</p>

<p>Notice, in the definition of "<tt>omega</tt>", the usage of the
  caret ("<tt>^</tt>") sign to specify antiquotations. Notice also the
  simplicity of the representation of the expression defining
  "<tt>comb_s</tt>".</p>

<p>Here is the code of the quotation expander, term.ml. The expander
  uses the <a href="grammars.html">extensible grammars</a>. It has its
  own lexer (using the <a href="lexers.html">stream lexers</a>)
  because the lexer of ocaml programs ("<tt>Plexer.gmake ()</tt>"),
  cannot recognize the backslashes alone.</p>

<pre>
  (* lexer *)

  #load "pa_lex.cmo";

  value rev_implode l =
    let s = String.create (List.length l) in
    loop (String.length s - 1) l where rec loop i =
      fun
      [ [c :: l] -> do { String.unsafe_set s i c; loop (i - 1) l }
      | [] -> s ]
  ;

  module B =
    struct
      value empty = [];
      value add x l = [x :: l];
      value get = rev_implode;
    end
  ;

  value rec ident =
    lexer
    [ "a..zA..Z0..9-_'\128..\255" ident! | ]
  ;

  value empty _ = parser [: _ = Stream.empty :] -> [];

  value rec next_tok =
    lexer
    [ "\\" -> ("BSLASH", "")
    | "^" -> ("CARET", "")
    | "a..z" ident! -> ("IDENT", $buf)
    | "(" -> ("", "(")
    | ")" -> ("", ")")
    | "." -> ("", ".")
    | empty -> ("EOS", "")
    | -> raise (Stream.Error "lexing error: bad character") ]
  ;

  value rec skip_spaces = lexer [ " \n\r"/ skip_spaces! | ];

  value record_loc loct i (bp, ep) = do {
    if i >= Array.length loct.val then do {
      let newt =
        Array.init (2 * Array.length loct.val + 1)
          (fun i ->
             if i &lt; Array.length loct.val then loct.val.(i)
             else Stdpp.dummy_loc)
      in
      loct.val := newt;
    }
    else ();
    loct.val.(i) := Stdpp.make_loc (bp, ep)
  };

  value lex_func cs =
    let loct = ref [| |] in
    let ts =
      Stream.from
        (fun i -> do {
           ignore (skip_spaces $empty cs : list char);
           let bp = Stream.count cs in
           let r = next_tok $empty cs in
           let ep = Stream.count cs in
           record_loc loct i (bp, ep);
           Some r
         })
    in
    (ts, fun i -> loct.val.(i))
  ;

  value lam_lex =
    {Token.tok_func = lex_func;
     Token.tok_using _ = (); Token.tok_removing _ = ();
     Token.tok_match = Token.default_match;
     Token.tok_text = Token.lexer_text;
     Token.tok_comm = None}
  ;

  (* parser *)

  #load "pa_extend.cmo";
  #load "q_MLast.cmo";

  value g = Grammar.gcreate lam_lex;
  value expr_term_eos = Grammar.Entry.create g "term";
  value patt_term_eos = Grammar.Entry.create g "term";

  EXTEND
    GLOBAL: expr_term_eos patt_term_eos;
    expr_term_eos:
      [ [ x = expr_term; EOS -> x ] ]
    ;
    expr_term:
      [ [ BSLASH; i = IDENT; "."; t = SELF -> &lt;:expr&lt; Lam $str:i$ $t$ >> ]
      | [ x = SELF; y = SELF -> &lt;:expr&lt; App $x$ $y$ >> ]
      | [ i = IDENT -> &lt;:expr&lt; Var $str:i$ >>
        | CARET; r = expr_antiquot -> r
        | "("; t = SELF; ")" -> t ] ]
    ;
    expr_antiquot:
      [ [ i = IDENT ->
           let r =
             let loc = Stdpp.make_loc (0, String.length i) in
             &lt;:expr&lt; $lid:i$ >>
           in
           &lt;:expr&lt; $anti:r$ >> ] ]
    ;
    patt_term_eos:
      [ [ x = patt_term; EOS -> x ] ]
    ;
    patt_term:
      [ [ BSLASH; i = IDENT; "."; t = SELF -> &lt;:patt&lt; Lam $str:i$ $t$ >> ]
      | [ x = SELF; y = SELF -> &lt;:patt&lt; App $x$ $y$ >> ]
      | [ i = IDENT -> &lt;:patt&lt; Var $str:i$ >>
        | CARET; r = patt_antiquot -> r
        | "("; t = SELF; ")" -> t ] ]
    ;
    patt_antiquot:
      [ [ i = IDENT ->
           let r =
             let loc = Stdpp.make_loc (0, String.length i) in
             &lt;:patt&lt; $lid:i$ >>
           in
           &lt;:patt&lt; $anti:r$ >> ] ]
    ;
  END;

  value expand_expr s = Grammar.Entry.parse expr_term_eos (Stream.of_string s);
  value expand_patt s = Grammar.Entry.parse patt_term_eos (Stream.of_string s);

  Quotation.add "term" (Quotation.ExAst (expand_expr, expand_patt));
  Quotation.default.val := "term";
</pre>

<p>Compilation:</p>

<pre>
  ocamlc -pp camlp5r -I +camlp5 -c term.ml 
</pre>

<p>Example, in the toplevel, including a semantic error, correctly
  underlined, thanks to the antiquotation nodes:</p>

<pre>
  $ ocaml -I +camlp5 camlp5r.cma
          Objective Caml version ...

          Camlp5 Parsing version ...

  # #load "term.cmo";
  # type term =
     [ Lam of string and term
     | App of term and term
     |   Var of string ]
    ;
  type term = [ Lam of string and term | App of term and term | Var of string ]
  # value comb_s = &lt;&lt; \x.\y.\z.(x y)(x z) >>;
  value comb_s : term =
    Lam "x"
     (Lam "y"
       (Lam "z" (App (App (Var "x") (Var "y")) (App (Var "x") (Var "z")))))
  # value omega = &lt;&lt; ^delta ^delta >>;
  Characters 18-23:
    value omega = &lt;&lt; ^delta ^delta >>;
                      ^^^^^
  Unbound value delta
  # value delta = &lt;&lt; \x.x x >>;
  value delta : term = Lam "x" (App (Var "x") (Var "x"))
  # value omega = &lt;&lt; ^delta ^delta >>;
  value omega : term =
    App (Lam "x" (App (Var "x") (Var "x"))) (Lam "x" (App (Var "x") (Var "x")))
</pre>

<div class="trailer">
</div>

</div>

</body>
</html>
