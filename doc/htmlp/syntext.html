<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
  <!-- $Id: syntext.html,v 1.7 2007/07/22 11:18:16 deraugla Exp $ -->
  <!-- Copyright (c) 2007 INRIA -->
  <title>syntax extensions</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="styles/base.css"
        title="Normal" />
</head>
<body>

<div id="menu">
</div>

<div id="content">

<h1 class="top">Syntax extensions</h1>

<p>Camlp5 allows to extend the syntax of the ocaml language, and even
  change the whole syntax.</p>

<p>It uses for that one of its parsing tools:
  the <a href="grammars.html">extensible grammars</a>.</p>

<p>To understand the whole syntax in the examples given in this chapter,
  it is a good thing to know this parsing tool, but we shall try to give
  some minimal explanations to allow the reader to follow them.</p>

<p>A syntax extension is an ocaml object file (ending with ".cmo" or
  ".cma") which is loaded inside camlp5. The source of this file uses
  calls to the specific statement EXTEND applied to entries defined in
  the camlp5 module "<tt>Pcaml</tt>".</p>

<div id="tableofcontents">
</div>

<h2>Entries</h2>

<p>The grammar of ocaml contains several entries, corresponding to the
  major notions of the language, which are modifiable this way, and
  even erasable. They are defined in this module "<tt>Pcaml</tt>".</p>

<p>Most important entries:</p>

<ul>
  <li><tt>expr</tt>: the expressions.</li>
  <li><tt>patt</tt>: the patterns.</li>
  <li><tt>ctyp</tt>: the types.</li>
  <li><tt>str_item</tt>: the structure items, i.e. the items between
    "struct" and "end", and the toplevel phrases in a ".ml" file.</li>
  <li><tt>sig_item</tt>: the signature items, i.e. the items between
    "sig" and "end", and the toplevel phrases in a ".mli" file.</li>
  <li><tt>module_expr</tt>: the module expressions.</li>
  <li><tt>module_type</tt>: the module types.</li>
</ul>

<p>Entries of object programming:</p>

<ul>
  <li><tt>class_expr</tt>: the class expressions.</li>
  <li><tt>class_type</tt>: the class types.</li>
  <li><tt>class_str_item</tt>: the objects items.</li>
  <li><tt>class_sig_item</tt>: the objects types items.</li>
</ul>

<p>Main entries of files and interactive toplevel parsing:</p>

<ul>
  <li><tt>implem</tt>: the phrases that can be found in a ".ml" file.</li>
  <li><tt>interf</tt>: the phrases that can be found in a ".mli" file.</li>
  <li><tt>top_phrase</tt>: the phrases of the interactive toplevel.</li>
  <li><tt>use_file</tt>: the phrases that can be found in a file
    included by the directive "use".</li>
</ul>

<p>Extra useful entries also accessible:</p>

<ul>
  <li><tt>let_binding</tt>: the bindings "expression = pattern" found in
    the "let" statement.</li>
  <li><tt>type_declaration</tt>: the bindings "name = type" found in
    the "type" statement.</li>
</ul>

<h2>Syntax tree quotations</h2>

<p>A grammar rule is a list of rule symbols followed by the semantic
  action, i.e. the result of the rule. This result is a syntax tree,
  whose type is the type of the extended entry. The description of the
  types of the syntax tree are in the camlp5 module
  "<tt>MLast</tt>".</p>

<p>However, there is a simpler way to make values of these syntax tree
  types: the system <a href="quot.html">quotations</a>. With this system,
  it is possible to represent syntax tree in concrete syntax, between
  specific parentheses.</p>

<p>For example, the syntax node of the "if" statement, supposing you
  know the meaning of the constructors of the "<tt>MLast</tt>" module
  would be:</p>

<pre>
  MLast.ExIfe loc e1 e2 e3
</pre>

<p>where loc is the source location, and e1, e2, e3 are the expressions
  constituting the if statement. With quotations, we could write it like
  this:</p>

<pre>
  &lt;:expr&lt; if $e1$ then $e2$ else $e3$ >>
</pre>

<p>With quotations, it is possible to build pieces of program as
  complex as desired. See the chapter
  about <a href="ml_ast.html">syntax trees</a>.</p>

<h2>An example</h2>

<p>A classical extension is the programmation of the "repeat" statement.
  The "repeat" statement is like a "while" except that the loop is executed
  at least one time and that the test is at the end of the loop and is
  inverted. The equivalent of:</p>

<pre>
  repeat x; y; z until c
</pre>

<p>is:</p>

<pre>
  do {
    x; y; z;
    while not c do { x; y; z }
  }
</pre>

<p>or, with a loop:</p>

<pre>
  loop () where rec loop () = do {
    x; y; z;
    if c then () else loop ()
  }
</pre>

<h3>The code</h3>

<p>This syntax extension could be written like this (see the detail of
  syntax in the chapter about <a href="grammars.html">extensible
  grammars</a> and the syntax tree quotations in the chapter
  about <a href="ml_ast.html">them</a>):</p>

<pre>
  #load "pa_extend.cmo";
  #load "q_MLast.cmo";
  open Pcaml;
  EXTEND
    expr:
      [ [ "repeat"; el = LIST1 expr SEP ";"; "until"; c = expr ->
            let el = el @ [&lt;:expr&lt; while not $c$ do { $list:el$ } >>] in
            &lt;:expr&lt; do { $list:el$ } >> ] ]
    ;
  END;
</pre>

<p>Alternatively, with the loop version:</p>

<pre>
  #load "pa_extend.cmo";
  #load "q_MLast.cmo";
  open Pcaml;
  EXTEND
    expr:
      [ [ "repeat"; el = LIST1 expr SEP ";"; "until"; c = expr ->
            let el = el @ [&lt;:expr&lt; if $c$ then () else loop () >>] in
            &lt;:expr&lt; loop () where rec loop () = do { $list:el$ } >> ] ]
    ;
  END;
</pre>

<p>The first "#load" in the code means that a syntax extension has been
  used in the file, namely the "EXTEND" statement. The second "#load"
  means that abstract tree <a href="quot.html">quotations</a> has been
  used, namely the "<tt>&lt;:expr&lt; ... >></tt>".</p>

<p>The quotation in the second version is especially interesting. If
  we wanted to write it with the abstract syntax tree, we would have to
  write it like this:</p>

<pre>
  MLast.ExLet loc True
    [(MLast.PaLid loc "loop",
      MLast.ExFun loc [(MLast.PaUid loc "()", None, MLast.ExSeq loc el)])]
    (MLast.ExApp loc (MLast.ExLid loc "loop") (MLast.ExUid loc "()"));
</pre>

<p>which is less easy for the programmer and less readable.</p>

<h3>Compilation</h3>

<p>If the file "foo.ml" contains one of these versions, it is possible to
  compile it like this:</p>

<pre>
  ocamlc -pp camlp5r -I +camlp5 -c foo.ml
</pre>

<p>Notice that the ocamlc option "-c" means that we are interested
  only in generating the object file "foo.cmo", not achieving the
  compilation which, anyway, would not link because of usage of
  modules specific to camlp5.</p>

<h3>Testing</h3>

<h4>In the ocaml toplevel</h4>

<pre>
  ocaml -I +camlp5 camlp5r.cma
          Objective Caml version ...

          Camlp5 Parsing version ...

  # #load "foo.cmo";
  # value x = ref 42;                                                     
  value x : ref int = {val=42}
  # repeat
      print_int x.val; print_endline ""; x.val := x.val + 3
    until x.val > 70;
  42
  45
  48
  51
  54
  57
  60
  63
  66
  69
  - : unit = ()
</pre>

<h4>In a file</h4>

<p>The code, above, used in the toplevel, can be written in a file,
  say "bar.ml":</p>

<pre>
  #load "./foo.cmo";
  value x = ref 42;                                                  
  repeat
    print_int x.val;
    print_endline "";
    x.val := x.val + 3
  until x.val > 70;
</pre>

<p>with a subtile difference: the loaded file must be "<tt>./foo.cmo</tt>"
  and not just "<tt>foo.cmo</tt>" because camlp5 does not have, by default,
  the current directory in its path.</p>

<p>The file can be compiled like this:</p>

<pre>
  ocamlc -pp camlp5r bar.ml
</pre>

<p>or in native code:</p>

<pre>
  ocamlopt -pp camlp5r bar.ml
</pre>

<p>... work in progress ...</p>

<div class="trailer">
</div>

</div>

</body>
</html>
