<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
  <!-- $Id$ -->
  <!-- Copyright (c) 2007 INRIA -->
  <title>parsing and printing tools</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="shortcut icon" href="c4logo.png" />
  <link rel="stylesheet" type="text/css" href="styles/base.css" />
</head>
<body>

<div id="menu">
</div>

<div id="content">

<h1 class="top">Parsing and Printing tools</h1>

<p>Camlp5 provides two original parsing tools:</p>

<ul>

<li>stream parsers</li>

<li>extensible grammars</li>

</ul>

<p>The first parsing tool, the stream parsers, is the elementary
system. It is pure syntactic sugar, i.e. the code is directly
converted into basic ocaml statements: functions, pattern matchings,
try. A stream parser is a function. But the system does not take care
of associativity, nor parsing level, and left recursion result on
infinite loops, just like functions whose first action would be a call
to itself.</p>

<p>The second parsing tool, the extensible grammars, are more
sophisticated. A grammar written with them is more readable, and look
like grammars written with tools like "yacc". They take care of
associativity, left recursion, and level of parsing. They are
dynamically extensible, what allows the syntax extensions what camlp5
provides for ocaml syntax.</p>

<p>In both cases, the input data are streams.</p>

<p>Camlp5 also provides a pretty printing tool, a module allowing to
control the lines length.</p>

<p>The next sections give an overview of the two parsing and the
pretty tools.</p>

<a id="Parsers"></a>
<h2>Stream parsers</h2>

<p>The stream parsers are a system of elementary recursive descendant
parsing. Streams are actually lazy lists. At each step, the head of
the list is compared against a <em>stream pattern</em>. There are two
kinds of streams parsers:</p>

<ul>

<li>The imperative <a href="parsers.html">streams parsers</a>, where
the elements are removed from the stream as long as they are parsed.
Parsers return either:

  <ul>
    <li>A value, in case of success,</li>
    <li>The exception "<tt>Stream.Failure</tt>" when the parser does not
      apply and no elements have been removed from the stream, indicating
      that, possibly, other parsers may apply,</li>
    <li>The exception "<tt>Stream.Error</tt>" when the parser does not
      apply, but one or several elements have been removed from the
      stream, indicating that nothing can to be done to make up the
      error.</li>
  </ul>

</li>

<li>The purely <a href="fparsers.html">functional stream parsers</a>
where the elements are not removed from the stream during the parsing.
These parsers return a value of type "option", i.e either:

  <ul>
    <li>"Some" a value and the remaining stream, in case of success,</li>
    <li>"None", in case of failure.</li>
  </ul>

</li>

</ul>

<p>The differences are about:</p>

<ul>
  <li><span class="u">Syntax errors</span>: in the imperative version,
    the location of the error is clear, it is at the current position
    of the stream, and the system allows to provide a specific error
    message (typically, that some "element" was "expected"). On the
    other hand, in the functional version, the position is not clear
    since it returns with nothing more than the initial stream. The
    only solution to know where the error happened is to analyze that
    stream to see how many elements have be unfrozen, and no clear
    error message is available, just "syntax error".</li>
  <li><span class="u">Power</span>: in the imperative version, when a
    rule raises the exception "<tt>Stream.Error</tt>", the parsing
    cannot continue.  In the functional version, the parsing can
    continue by analyzing the next rule with the initial unaffected
    stream: this is a
    <em>limited backtrack</em>.</li>
  <li><span class="u">Neatness</span>: functional streams are neater,
    just like functional programming is neater than imperative
    programming.</li>
</ul>

<p>In the imperative version, there exists also
<a href="lexers.html">lexers</a>, a shorter syntax when the stream
elements are of the specific type '<tt>char</tt>'.</p>

<a id="Grammars"></a>
<h2>Extensible grammars</h2>

<a id="Pretty"></a>
<h2>Pretty module</h2>

<p>The "<tt>Pretty</tt>" module is an original tool allowing to
control the displaying of lines. The user has to specify two functions
where:</p>

<ul>

  <li>the data is printed in one only line</li>
  <li>the data is printed in several lines</li>

</ul>

<p>The system first tries the first function. At any time, it the line
overflows, i.e. if its size is greater than some "line length"
specified in the module interface, or if it contains newlines, the
function is aborted and control is given to the second function.</p>

<p>This is a basic, but powerful, system. It supposes that the programmer
takes care of the current indentation, and the beginning and the end of
its lines.</p>

<p>The module will be extended in the future to hide the management of
indendations and line continuations, and by the supply of functions
combinating the two cases above, in which the programmer can specify the
possible places where newlines can be inserted.</p>

<div class="trailer">

  <hr style="margin:0" /><div style="font-size: 80%"><em>Copyright 2007
      Daniel de Rauglaudre (INRIA)</em></div>

  <p class="bottom">
    <a href="http://validator.w3.org/check?uri=referer"><img
       src="http://www.w3.org/Icons/valid-xhtml11" style="border:0"
       alt="Valid XHTML 1.1" height="31" width="88" /></a>
  </p>

</div>

</div>

</body>
</html>
