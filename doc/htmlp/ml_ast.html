<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
  <!-- $Id: ml_ast.html,v 1.9 2007/07/22 21:24:13 deraugla Exp $ -->
  <!-- Copyright (c) 2007 INRIA -->
  <title>Abstract tree in concrete syntax</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="styles/base.css"
        title="Normal" />
</head>
<body>

<div id="menu">
</div>

<div id="content">

<h1 class="top">Syntax tree</h1>

<div id="tableofcontents">
</div>

<h2>Introduction</h2>

<p>In Camlp5, one often uses syntax trees. For example, in grammars of
  the language (semantic actions), in pretty printing (as patterns), in
  optimizing syntax code (typically streams parsers). Syntax trees are
  mainly defined by sum types, one for each kind of tree:
  "<code>expr</code>" for expressions, "<code>patt</code>" for patterns,
  "<code>ctyp</code>" for types, "<code>str_item</code>" for structure
  items, and so on. Each node corresponds to a possible value of this
  type.</p>

<p>This syntax tree is defined in the module "<code>MLast</code>"
  provided by Camlp5.</p>

<p>For example, the syntax tree of the statement "<code>if</code>" can
  be written:</p>

<pre>
  MLast.ExIfe loc e1 e2 e3
</pre>

<p>where "<code>loc</code>" is the location in the source, and
  "<code>e1</code>", "<code>e2</code>" and "<code>e3</code>" are
  respectively the expression after the "<code>if</code>", the one after
  the "<code>then</code>" and the one after the "<code>else</code>".</p>

<p>In all programs, it is possible to manipulate syntax trees like
  that.</p>

<p>However, the quotations systems of Camlp5 provides a quotation kit
  named "<code>q_MLast.cmo</code>". When loaded, it is possible to
  represent the syntax trees in concrete syntax. The example above can
  be written:</p>

<pre>
  &lt;:expr&lt; if $e1$ then $e2$ else $e3$ >>
</pre>

<p>The interest of this representation is when one must manipulate
  complicated syntax trees. An example taken from the Camlp5 sources is
  this quotation (found in a pattern):</p>

<pre>
  &lt;:expr&lt;
    match try Some $f$ with [ Stream.Failure -> None ] with
    [ Some $p$ -> $e$
    | _ -> raise (Stream.Error $e2$) ]
  >>
</pre>

<p>In abstract syntax, it should have been written:</p>

<pre>
  MLast.ExMat _
    (MLast.ExTry _ (MLast.ExApp _ (MLast.ExUid _ "Some") f)
       [(MLast.PaAcc _ (MLast.PaUid _ "Stream") (MLast.PaUid _ "Failure"),
         None, MLast.ExUid _ "None")])
    [(MLast.PaApp _ (MLast.PaUid _ "Some") p, None, e);
     (MLast.PaAny _, None,
      MLast.ExApp _ (MLast.ExLid _ "raise")
        (MLast.ExApp _
           (MLast.ExAcc _ (MLast.ExUid _ "Stream") (MLast.ExUid _ "Error"))
           e2))]
</pre>

<p>Which is less readable.</p>

<p>Instead of thinking of "a syntax tree", the programmer has to think
  of "a piece of program".</p>

<h2>Nodes</h2>

<p>A way to know what the nodes represent it to read the source file
  q_MLast.ml of the camlp5 distribution. It is a version of the
  revised syntax grammar (pa_r.ml) where the semantic action contain
  their explicit names. Otherwise, you can read the following
  sections.</p>

<h3>expr</h3>

<table border="1" style="margin-left: 1cm; white-space: nowrap">
  <tr>
    <td><tt>ExAcc loc e1 e2</tt></td>
    <td><tt>&lt;:expr&lt; $e1$ . $e2$ >></tt></td>
    <td>dot</td>
  </tr>
  <tr>
    <td><tt>ExAnt loc e</tt></td>
    <td>...internal use...</td>
    <td></td>
  </tr>
  <tr>
    <td><tt>ExApp loc e1 e2</tt></td>
    <td><tt>&lt;:expr&lt; $e1$ $e2$ >></tt></td>
    <td>application</td>
  </tr>
  <tr>
    <td><tt>ExAre loc e1 e2</tt></td>
    <td><tt>&lt;:expr&lt; $e1$ .( $e2$ ) >></tt></td>
    <td>array access</td>
  </tr>
  <tr>
    <td><tt>ExArr loc el</tt></td>
    <td><tt>&lt;:expr&lt; [| $list:el$ |] >></tt></td>
    <td>array</td>
  </tr>
  <tr>
    <td><tt>ExAsr loc e</tt></td>
    <td><tt>&lt;:expr&lt; assert $e$ >></tt></td>
    <td>assert</td>
  </tr>
  <tr>
    <td><tt>ExAss loc e1 e2</tt></td>
    <td><tt>&lt;:expr&lt; $e1$ := $e2$ >></tt></td>
    <td>assignment</td>
  </tr>
  <tr>
    <td><tt>ExBae loc e el</tt></td>
    <td><tt>&lt;:expr&lt; $e$ .{ $el$ } >></tt></td>
    <td>big array access</td>
  </tr>
  <tr>
    <td><tt>ExChr loc s</tt></td>
    <td><tt>&lt;:expr&lt; $chr:s$ >></tt></td>
    <td>character constant</td>
  </tr>
  <tr>
    <td><tt>ExCoe loc e1 (Some t1) t2</tt></td>
    <td><tt>&lt;:expr&lt; ($e1$ : $t1$ :> $t2$) >></tt></td>
    <td>coercion</td>
  </tr>
  <tr>
    <td><tt>ExCoe loc e1 None t2</tt></td>
    <td><tt>&lt;:expr&lt; ($e1$ :> $t2$) >></tt></td>
    <td>coercion</td>
  </tr>
  <tr>
    <td><tt>ExFlo loc s</tt></td>
    <td><tt>&lt;:expr&lt; $flo:s$ >></tt></td>
    <td>float constant</td>
  </tr>
  <tr>
    <td><tt>ExFor loc s e1 e2 d el</tt></td>
    <td><tt>&lt;:expr&lt; for $s$ = $e1$ to $e2$ do { $list:el$ } >></tt></td>
    <td>for</td>
  </tr>
  <tr>
    <td><tt>ExFun loc pwel</tt></td>
    <td><tt>&lt;:expr&lt; fun [ $list:pwel$ ] >></tt></td>
    <td>function</td>
  </tr>
  <tr>
    <td><tt>ExIfe loc e1 e2 e3</tt></td>
    <td><tt>&lt;:expr&lt; if $e1$ then $e2$ else $e3$ >></tt></td>
    <td>if</td>
  </tr>
  <tr>
    <td><tt>ExInt loc s ""</tt></td>
    <td><tt>&lt;:expr&lt; $int:s$ >></tt></td>
    <td>integer constant</td>
  </tr>
  <tr>
    <td><tt>ExInt loc s "l"</tt></td>
    <td><tt>&lt;:expr&lt; $int32:s$ >></tt></td>
    <td>integer 32 bits</td>
  </tr>
  <tr>
    <td><tt>ExInt loc s "L"</tt></td>
    <td><tt>&lt;:expr&lt; $int64:s$ >></tt></td>
    <td>integer 64 bits</td>
  </tr>
  <tr>
    <td><tt>ExInt loc s "n"</tt></td>
    <td><tt>&lt;:expr&lt; $nativeint:s$ >></tt></td>
    <td>native integer</td>
  </tr>
  <tr>
    <td><tt>ExLab loc s None</tt></td>
    <td><tt>&lt;:expr&lt; ~ $s$ >></tt></td>
    <td>label</td>
  </tr>
  <tr>
    <td><tt>ExLab loc s (Some e)</tt></td>
    <td><tt>&lt;:expr&lt; ~ $s$ : $e$ >></tt></td>
    <td>label</td>
  </tr>
  <tr>
    <td><tt>ExLaz loc e</tt></td>
    <td><tt>&lt;:expr&lt; lazy $e$ >></tt></td>
    <td>lazy</td>
  </tr>
  <tr>
    <td><tt>ExLet loc r pel e</tt></td>
    <td><tt>&lt;:expr&lt; let $opt:r$ $list:pel$ in $e$ >></tt></td>
    <td>let binding</td>
  </tr>
  <tr>
    <td><tt>ExLid loc s</tt></td>
    <td><tt>&lt;:expr&lt; $lid:s$ >></tt></td>
    <td>lowercase identifier</td>
  </tr>
  <tr>
    <td><tt>ExLmd loc s me e</tt></td>
    <td><tt>&lt;:expr&lt; let module $s$ = $me$ in $e$ >></tt></td>
    <td>let module</td>
  </tr>
  <tr>
    <td><tt>ExMat loc e pwel</tt></td>
    <td><tt>&lt;:expr&lt; match $e$ with [ $list:pwel$ ] >></tt></td>
    <td>match</td>
  </tr>
  <tr>
    <td><tt>ExNew loc sl</tt></td>
    <td><tt>&lt;:expr&lt; new $list:sl$ >></tt></td>
    <td>new</td>
  </tr>
  <tr>
    <td><tt>ExObj loc po csil</tt></td>
    <td><tt>&lt;:expr&lt; object ($opt:p$) $list:csil$ end >></tt></td>
    <td>object expression</td>
  </tr>
  <tr>
    <td><tt>ExOlb loc s None</tt></td>
    <td><tt>&lt;:expr&lt; ? $s$ >></tt></td>
    <td>option label</td>
  </tr>
  <tr>
    <td><tt>ExOlb loc s (Some e)</tt></td>
    <td><tt>&lt;:expr&lt; ? $s$ : $e$ >></tt></td>
    <td>option label</td>
  </tr>
  <tr>
    <td><tt>ExOvr loc sel</tt></td>
    <td><tt>&lt;:expr&lt; {&lt; $sel$ >} >></tt></td>
    <td>override</td>
  </tr>
  <tr>
    <td><tt>ExRec loc pel None</tt></td>
    <td><tt>&lt;:expr&lt; { $list:pel$ } >></tt></td>
    <td>record</td>
  </tr>
  <tr>
    <td><tt>ExRec loc pel (Some e)</tt></td>
    <td><tt>&lt;:expr&lt; { ($e$) with { $list:pel$ } >></tt></td>
    <td>record</td>
  </tr>
  <tr>
    <td><tt>ExSeq loc el</tt></td>
    <td><tt>&lt;:expr&lt; do { $list:el$ } >></tt></td>
    <td>sequence</td>
  </tr>
  <tr>
    <td><tt>ExSnd loc e s</tt></td>
    <td><tt>&lt;:expr&lt; $e$ # $s$ >></tt></td>
    <td>method call</td>
  </tr>
  <tr>
    <td><tt>ExSte loc e1 e2</tt></td>
    <td><tt>&lt;:expr&lt; $e1$ .[ $e2$ ] >></tt></td>
    <td>string element</td>
  </tr>
  <tr>
    <td><tt>ExStr loc s</tt></td>
    <td><tt>&lt;:expr&lt; $str:s$ >></tt></td>
    <td>string</td>
  </tr>
  <tr>
    <td><tt>ExTry loc e pwel</tt></td>
    <td><tt>&lt;:expr&lt; try $e$ with [ $list:pwel$ ] >></tt></td>
    <td>try</td>
  </tr>
  <tr>
    <td><tt>ExTup loc el</tt></td>
    <td><tt>&lt;:expr&lt; ($list:el$) >></tt></td>
    <td>t-uple</td>
  </tr>
  <tr>
    <td><tt>ExTyc loc e t</tt></td>
    <td><tt>&lt;:expr&lt; ($e$ : $t$) >></tt></td>
    <td>type constraint</td>
  </tr>
  <tr>
    <td><tt>ExUid loc s</tt></td>
    <td><tt>&lt;:expr&lt; $uid:s$ >></tt></td>
    <td>uppercase identifier</td>
  </tr>
  <tr>
    <td><tt>ExVrn loc s</tt></td>
    <td><tt>&lt;:expr&lt; ` $s$ >></tt></td>
    <td>variant</td>
  </tr>
  <tr>
    <td><tt>ExWhi loc e el</tt></td>
    <td><tt>&lt;:expr&lt; while $e$ do { $list:el$ } >></tt></td>
    <td>while</td>
  </tr>
</table>

<div class="trailer">
</div>

</div>

</body>
</html>
