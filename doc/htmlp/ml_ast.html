<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
  <!-- $Id: ml_ast.html,v 1.14 2007/07/23 15:11:46 deraugla Exp $ -->
  <!-- Copyright (c) 2007 INRIA -->
  <title>Abstract tree in concrete syntax</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="styles/base.css"
        title="Normal" />
  <style type="text/css"><!--
    table { margin-left: 1cm }
    td { padding-right: 2mm }
  --></style>
</head>
<body>

<div id="menu">
</div>

<div id="content">

<h1 class="top">Syntax tree</h1>

<div id="tableofcontents">
</div>

<h2>Introduction</h2>

<p>In Camlp5, one often uses syntax trees. For example, in grammars of
  the language (semantic actions), in pretty printing (as patterns), in
  optimizing syntax code (typically streams parsers). Syntax trees are
  mainly defined by sum types, one for each kind of tree:
  "<code>expr</code>" for expressions, "<code>patt</code>" for patterns,
  "<code>ctyp</code>" for types, "<code>str_item</code>" for structure
  items, and so on. Each node corresponds to a possible value of this
  type.</p>

<p>This syntax tree is defined in the module "<code>MLast</code>"
  provided by Camlp5.</p>

<p>For example, the syntax tree of the statement "<code>if</code>" can
  be written:</p>

<pre>
  MLast.ExIfe loc e1 e2 e3
</pre>

<p>where "<code>loc</code>" is the location in the source, and
  "<code>e1</code>", "<code>e2</code>" and "<code>e3</code>" are
  respectively the expression after the "<code>if</code>", the one after
  the "<code>then</code>" and the one after the "<code>else</code>".</p>

<p>In all programs, it is possible to manipulate syntax trees like
  that.</p>

<p>However, the quotations systems of Camlp5 provides a quotation kit
  named "<code>q_MLast.cmo</code>". When loaded, it is possible to
  represent the syntax trees in concrete syntax. The example above can
  be written:</p>

<pre>
  &lt;:expr&lt; if $e1$ then $e2$ else $e3$ >>
</pre>

<p>The interest of this representation is when one must manipulate
  complicated syntax trees. An example taken from the Camlp5 sources is
  this quotation (found in a pattern):</p>

<pre>
  &lt;:expr&lt;
    match try Some $f$ with [ Stream.Failure -> None ] with
    [ Some $p$ -> $e$
    | _ -> raise (Stream.Error $e2$) ]
  >>
</pre>

<p>In abstract syntax, it should have been written:</p>

<pre>
  MLast.ExMat _
    (MLast.ExTry _ (MLast.ExApp _ (MLast.ExUid _ "Some") f)
       [(MLast.PaAcc _ (MLast.PaUid _ "Stream") (MLast.PaUid _ "Failure"),
         None, MLast.ExUid _ "None")])
    [(MLast.PaApp _ (MLast.PaUid _ "Some") p, None, e);
     (MLast.PaAny _, None,
      MLast.ExApp _ (MLast.ExLid _ "raise")
        (MLast.ExApp _
           (MLast.ExAcc _ (MLast.ExUid _ "Stream") (MLast.ExUid _ "Error"))
           e2))]
</pre>

<p>Which is less readable.</p>

<p>Instead of thinking of "a syntax tree", the programmer has to think
  of "a piece of program".</p>

<h2>Antiquotations</h2>

<p>The expressions or patterns between dollar ($) characters
  are <em>antiquotations</em>. If the quotation is an expression, they
  are expressions, if it is in a pattern, they are patterns.  Any
  acceptable expression or pattern is allowed, except quotations
  themselves.</p>

<p>Examples of expressions:</p>

<pre>
  <:expr< [$e$ :: $loop False el$] >>
  <:patt< ( $list:[p::pl]$) >>
</pre>

<p>Examples of patterns (in their contexts):</p>

<pre>
   fun [ <:expr< $lid:op$ $_$ $_$ >> -> op ]
   match p with [ <:patt< $_$ | $_$ >> -> Some p ]
</pre>

<h2>Nodes</h2>

<p>This section describes all nodes defined in the module "MLast" of
  camlp5 and how to write them with quotations. Notice that, inside
  quotations, one is not restricted to these elementary cases, but
  any complex value can be used, resulting on possibly complex combined
  nodes.</p>

<p>Variables names give information to their types:</p>

<ul>
  <li><tt>e</tt>, <tt>e1</tt>, <tt>e2</tt>, <tt>e3</tt>: expr</li>
  <li><tt>p</tt>, <tt>p1</tt>, <tt>p2</tt>, <tt>p3</tt>: patt</li>
  <li><tt>t</tt>, <tt>t1</tt>, <tt>t2</tt>, <tt>e3</tt>: ctyp</li>
  <li><tt>s</tt>: string</li>
  <li><tt>b</tt>: bool</li>
  <li><tt>me</tt>: module_expr</li>
  <li><tt>le</tt>: list expr</li>
  <li><tt>lp</tt>: list patt</li>
  <li><tt>ls</tt>: list string</li>
  <li><tt>lse</tt>: list (string * expr)</li>
  <li><tt>lpe</tt>: list (patt * expr)</li>
  <li><tt>lpp</tt>: list (patt * patt)</li>
  <li><tt>lpoee</tt>: list (patt * option expr * expr)</li>
  <li><tt>op</tt>: option patt</li>
  <li><tt>lcsi</tt>: list class_str_item</li>
</ul>

<h3>expr</h3>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:expr&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>ExAcc loc e1 e2</tt></td>
    <td align="center"><tt>$e1$ . $e2$</tt></td>
    <td>dot</td>
  </tr>
  <tr>
    <td><tt>ExAnt loc e</tt></td>
    <td align="center">...internal use...</td>
    <td></td>
  </tr>
  <tr>
    <td><tt>ExApp loc e1 e2</tt></td>
    <td align="center"><tt>$e1$ $e2$</tt></td>
    <td>application</td>
  </tr>
  <tr>
    <td><tt>ExAre loc e1 e2</tt></td>
    <td align="center"><tt>$e1$ .( $e2$ )</tt></td>
    <td>array access</td>
  </tr>
  <tr>
    <td><tt>ExArr loc le</tt></td>
    <td align="center"><tt>[| $list:le$ |]</tt></td>
    <td>array</td>
  </tr>
  <tr>
    <td><tt>ExAsr loc e</tt></td>
    <td align="center"><tt>assert $e$</tt></td>
    <td>assert</td>
  </tr>
  <tr>
    <td><tt>ExAss loc e1 e2</tt></td>
    <td align="center"><tt>$e1$ := $e2$</tt></td>
    <td>assignment</td>
  </tr>
  <tr>
    <td><tt>ExBae loc e le</tt></td>
    <td align="center"><tt>$e$ .{ $le$ }</tt></td>
    <td>big array access</td>
  </tr>
  <tr>
    <td><tt>ExChr loc s</tt></td>
    <td align="center"><tt>$chr:s$</tt></td>
    <td>character constant</td>
  </tr>
  <tr>
    <td><tt>ExCoe loc e (Some t1) t2</tt></td>
    <td align="center"><tt>($e1$ : $t1$ :> $t2$)</tt></td>
    <td>coercion</td>
  </tr>
  <tr>
    <td><tt>ExCoe loc e None t2</tt></td>
    <td align="center"><tt>($e1$ :> $t2$)</tt></td>
    <td>coercion</td>
  </tr>
  <tr>
    <td><tt>ExFlo loc s</tt></td>
    <td align="center"><tt>$flo:s$</tt></td>
    <td>float constant</td>
  </tr>
  <tr>
    <td><tt>ExFor loc s e1 e2 b le</tt></td>
    <td align="center"><tt>for $s$ = $e1$ $to:b$ $e2$ do { $list:le$ }</tt></td>
    <td>for</td>
  </tr>
  <tr>
    <td><tt>ExFun loc lopee</tt></td>
    <td align="center"><tt>fun [ $list:lpoee$ ]</tt></td>
    <td>function</td>
  </tr>
  <tr>
    <td><tt>ExIfe loc e1 e2 e3</tt></td>
    <td align="center"><tt>if $e1$ then $e2$ else $e3$</tt></td>
    <td>if</td>
  </tr>
  <tr>
    <td><tt>ExInt loc s ""</tt></td>
    <td align="center"><tt>$int:s$</tt></td>
    <td>integer constant</td>
  </tr>
  <tr>
    <td><tt>ExInt loc s "l"</tt></td>
    <td align="center"><tt>$int32:s$</tt></td>
    <td>integer 32 bits</td>
  </tr>
  <tr>
    <td><tt>ExInt loc s "L"</tt></td>
    <td align="center"><tt>$int64:s$</tt></td>
    <td>integer 64 bits</td>
  </tr>
  <tr>
    <td><tt>ExInt loc s "n"</tt></td>
    <td align="center"><tt>$nativeint:s$</tt></td>
    <td>native integer</td>
  </tr>
  <tr>
    <td><tt>ExLab loc s None</tt></td>
    <td align="center"><tt>~ $s$</tt></td>
    <td>label</td>
  </tr>
  <tr>
    <td><tt>ExLab loc s (Some e)</tt></td>
    <td align="center"><tt>~ $s$ : $e$</tt></td>
    <td>label</td>
  </tr>
  <tr>
    <td><tt>ExLaz loc e</tt></td>
    <td align="center"><tt>lazy $e$</tt></td>
    <td>lazy</td>
  </tr>
  <tr>
    <td><tt>ExLet loc b lpe e</tt></td>
    <td align="center"><tt>let $opt:b$ $list:lpe$ in $e$</tt></td>
    <td>let binding</td>
  </tr>
  <tr>
    <td><tt>ExLid loc s</tt></td>
    <td align="center"><tt>$lid:s$</tt></td>
    <td>lowercase identifier</td>
  </tr>
  <tr>
    <td><tt>ExLmd loc s me e</tt></td>
    <td align="center"><tt>let module $s$ = $me$ in $e$</tt></td>
    <td>let module</td>
  </tr>
  <tr>
    <td><tt>ExMat loc e lpoee</tt></td>
    <td align="center"><tt>match $e$ with [ $list:lpoee$ ]</tt></td>
    <td>match</td>
  </tr>
  <tr>
    <td><tt>ExNew loc ls</tt></td>
    <td align="center"><tt>new $list:ls$</tt></td>
    <td>new</td>
  </tr>
  <tr>
    <td><tt>ExObj loc op lcsi</tt></td>
    <td align="center"><tt>object ($opt:op$) $list:lcsi$ end</tt></td>
    <td>object expression</td>
  </tr>
  <tr>
    <td><tt>ExOlb loc s None</tt></td>
    <td align="center"><tt>? $s$</tt></td>
    <td>option label</td>
  </tr>
  <tr>
    <td><tt>ExOlb loc s (Some e)</tt></td>
    <td align="center"><tt>? $s$ : $e$</tt></td>
    <td>option label</td>
  </tr>
  <tr>
    <td><tt>ExOvr loc lse</tt></td>
    <td align="center"><tt>{&lt; $lse$ >}</tt></td>
    <td>override</td>
  </tr>
  <tr>
    <td><tt>ExRec loc lpe None</tt></td>
    <td align="center"><tt>{ $list:lpe$ }</tt></td>
    <td>record</td>
  </tr>
  <tr>
    <td><tt>ExRec loc lpe (Some e)</tt></td>
    <td align="center"><tt>{ ($e$) with { $list:lpe$ }</tt></td>
    <td>record</td>
  </tr>
  <tr>
    <td><tt>ExSeq loc le</tt></td>
    <td align="center"><tt>do { $list:le$ }</tt></td>
    <td>sequence</td>
  </tr>
  <tr>
    <td><tt>ExSnd loc e s</tt></td>
    <td align="center"><tt>$e$ # $s$</tt></td>
    <td>method call</td>
  </tr>
  <tr>
    <td><tt>ExSte loc e1 e2</tt></td>
    <td align="center"><tt>$e1$ .[ $e2$ ]</tt></td>
    <td>string element</td>
  </tr>
  <tr>
    <td><tt>ExStr loc s</tt></td>
    <td align="center"><tt>$str:s$</tt></td>
    <td>string</td>
  </tr>
  <tr>
    <td><tt>ExTry loc e lpoee</tt></td>
    <td align="center"><tt>try $e$ with [ $list:lpoee$ ]</tt></td>
    <td>try</td>
  </tr>
  <tr>
    <td><tt>ExTup loc le</tt></td>
    <td align="center"><tt>($list:le$)</tt></td>
    <td>t-uple</td>
  </tr>
  <tr>
    <td><tt>ExTyc loc e t</tt></td>
    <td align="center"><tt>($e$ : $t$)</tt></td>
    <td>type constraint</td>
  </tr>
  <tr>
    <td><tt>ExUid loc s</tt></td>
    <td align="center"><tt>$uid:s$</tt></td>
    <td>uppercase identifier</td>
  </tr>
  <tr>
    <td><tt>ExVrn loc s</tt></td>
    <td align="center"><tt>` $s$</tt></td>
    <td>variant</td>
  </tr>
  <tr>
    <td><tt>ExWhi loc e le</tt></td>
    <td align="center"><tt>while $e$ do { $list:le$ }</tt></td>
    <td>while</td>
  </tr>
</table>

<h3>patt</h3>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:patt&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>PaAcc loc p1 p2</tt></td>
    <td align="center"><tt>$p1$ . $p2$</tt></td>
    <td>dot</td>
  </tr>
  <tr>
    <td><tt>PaAli loc p1 p2</tt></td>
    <td align="center"><tt>($p1$ as $p2$)</tt></td>
    <td>alias</td>
  </tr>
  <tr>
    <td><tt>PaAnt loc p</tt></td>
    <td align="center">...internal use...</td>
    <td></td>
  </tr>
  <tr>
    <td><tt>PaAny loc</tt></td>
    <td align="center"><tt>_</tt></td>
    <td>wildcard</td>
  </tr>
  <tr>
    <td><tt>PaApp loc p1 p2</tt></td>
    <td align="center"><tt>$p1$ $p2$</tt></td>
    <td>application</td>
  </tr>
  <tr>
    <td><tt>PaArr loc lp</tt></td>
    <td align="center"><tt>[| $list:lp$ |]</tt></td>
    <td>array</td>
  </tr>
  <tr>
    <td><tt>PaChr loc s</tt></td>
    <td align="center"><tt>$chr:s$</tt></td>
    <td>character</td>
  </tr>
  <tr>
    <td><tt>PaInt loc s1 s2</tt></td>
    <td align="center"><tt>$int:s$</tt></td>
    <td>integer</td>
  </tr>
  <tr>
    <td><tt>PaFlo loc s</tt></td>
    <td align="center"><tt>$flo:s$</tt></td>
    <td>float</td>
  </tr>
  <tr>
    <td><tt>PaLab loc s None</tt></td>
    <td align="center"><tt>~ $s$</tt></td>
    <td>label</td>
  </tr>
  <tr>
    <td><tt>PaLab loc s (Some p)</tt></td>
    <td align="center"><tt>~ $s$ : $p$</tt></td>
    <td>label</td>
  </tr>
  <tr>
    <td><tt>PaLid loc s</tt></td>
    <td align="center"><tt>$lid:s$</tt></td>
    <td>lowercase identifier</td>
  </tr>
  <tr>
    <td><tt>PaOlb loc s None</tt></td>
    <td align="center"><tt>? $s$</tt></td>
    <td>option label</td>
  </tr>
  <tr>
    <td><tt>PaOlb loc s (Some (p, None))</tt></td>
    <td align="center"><tt>? $s$ : ($p$)</tt></td>
    <td>option label</td>
  </tr>
  <tr>
    <td><tt>PaOlb loc s (Some (p, Some e))</tt></td>
    <td align="center"><tt>? $s$ : ($p$ = $e$)</tt></td>
    <td>option label</td>
  </tr>
  <tr>
    <td><tt>PaOrp loc p1 p2</tt></td>
    <td align="center"><tt>$p1$ | $p2$</tt></td>
    <td>or</td>
  </tr>
  <tr>
    <td><tt>PaRng loc p1 p2</tt></td>
    <td align="center"><tt>$p1$ .. $p2$</tt></td>
    <td>range</td>
  </tr>
  <tr>
    <td><tt>PaRec loc lpp None</tt></td>
    <td align="center"><tt>{ $list:lpp$ }</tt></td>
    <td>record</td>
  </tr>
  <tr>
    <td><tt>PaStr loc s</tt></td>
    <td align="center"><tt>$str:s$</tt></td>
    <td>string</td>
  </tr>
  <tr>
    <td><tt>PaTup loc lp</tt></td>
    <td align="center"><tt>($list:lp$)</tt></td>
    <td>t-uple</td>
  </tr>
  <tr>
    <td><tt>PaTyc loc p t</tt></td>
    <td align="center"><tt>($p$ : $t$)</tt></td>
    <td>type constraint</td>
  </tr>
  <tr>
    <td><tt>PaTyp loc ls</tt></td>
    <td align="center"><tt># $list:ls$</tt></td>
    <td>pattern type</td>
  </tr>
  <tr>
    <td><tt>PaUid loc s</tt></td>
    <td align="center"><tt>$uid:s$</tt></td>
    <td>uppercase identifier</td>
  </tr>
  <tr>
    <td><tt>PaVrn loc s</tt></td>
    <td align="center"><tt>` $s$</tt></td>
    <td>variant</td>
  </tr>
</table>

<h3>ctyp</h3>

<p>...to be completed...</p>

<div class="trailer">
</div>

</div>

</body>
</html>
