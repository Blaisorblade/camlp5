<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <!-- $Id: ast_strict.html,v 1.9 2007/09/22 14:44:35 deraugla Exp $ -->
  <!-- Copyright (c) 2007 INRIA -->
  <title>AST - strict</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="styles/base.css"
        title="Normal" />
  <style type="text/css">
    .nodelist { margin-left: 2cm }
    table { margin-left: 1cm }
    td { padding-right: 2mm }
  </style>
</head>
<body>

<div id="menu">
</div>

<div id="content">

<h1 class="top">Syntax tree - strict mode</h1>

<p>This chapter presents the Camlp5 syntax tree when Camlp5 is installed
  in <em>strict</em> mode.</p>

<div id="tableofcontents">
</div>

<h2>Introduction</h2>

<p>This syntax tree is defined in the module "<tt>MLast</tt>" provided
  by Camlp5. Each node corresponds to a syntactic entity of the
  corresponding type.</p>

<p>For example, the syntax tree of the statement "<tt>if</tt>" can
  be written:</p>

<pre>
  MLast.ExIfe loc e1 e2 e3
</pre>

<p>where "<tt>loc</tt>" is the location in the source, and
  "<tt>e1</tt>", "<tt>e2</tt>" and "<tt>e3</tt>" are
  respectively the expression after the "<tt>if</tt>", the one after
  the "<tt>then</tt>" and the one after the "<tt>else</tt>".</p>

<p>If a program needs to manipulate syntax trees, it can use the
  nodes defined in the module "<tt>MLast</tt>". It supposes to
  know how the concrete syntax is transformed in to this abstract
  syntax.<p>

<p>However, a simpler solution is to use one of the quotation kits
  "<tt>q_MLast.cmo</tt>" or "<tt>q_ast.cmo</tt>". Both propose
  <a href="quot.html">quotations</a> which represent the abstract
  syntax (the nodes of the module "<tt>MLast</tt>") into concrete
  syntax with antiquotations to bind variables inside. The example
  above can be written:</p>

<pre>
  &lt;:expr&lt; if $e1$ then $e2$ else $e3$ >>
</pre>

<p>This representation is very interesting when one wants to
  manipulate complicated syntax trees. Here is an example taken from
  the Camlp5 sources themselves:</p>

<pre>
  &lt;:expr&lt;
    match try Some $f$ with [ Stream.Failure -> None ] with
    [ Some $p$ -> $e$
    | _ -> raise (Stream.Error $e2$) ]
  >>
</pre>

<p>This example was in a position of a pattern. In abstract syntax, it
  should have been written:</p>

<pre>
  MLast.ExMat _
    (MLast.ExTry _ (MLast.ExApp _ (MLast.ExUid _ (Ploc.VaVal "Some")) f)
       (Ploc.VaVal
          [(MLast.PaAcc _ (MLast.PaUid _ (Ploc.VaVal "Stream"))
             (MLast.PaUid _ (Ploc.VaVal "Failure")),
            Ploc.VaVal None, MLast.ExUid _ (Ploc.VaVal "None"))]))
    (Ploc.VaVal
       [(MLast.PaApp _ (MLast.PaUid _ (Ploc.VaVal "Some")) p,
         Ploc.VaVal None, e);
        (MLast.PaAny _, Ploc.VaVal None,
         MLast.ExApp _ (MLast.ExLid _ (Ploc.VaVal "raise"))
           (MLast.ExApp _
              (MLast.ExAcc _ (MLast.ExUid _ (Ploc.VaVal "Stream"))
                 (MLast.ExUid _ (Ploc.VaVal "Error")))
              e2))])
</pre>

<p>Which is less readable and much more complicated to build and
  update.</p>

<p>Instead of thinking of "a syntax tree", the programmer has to think
  of "a piece of program".</p>

<h2>Location</h2>

<p>In all syntax tree nodes, the first parameter is the source
  location of the node.</p>

<h3>In expressions</h3>

<p>When a quotation is in the context of an expression, the location
  parameter is "<tt>loc</tt>" in the node and in all its possible
  sub-nodes. Example: if we consider the quotation:</p>

<pre>
  &lt;:sig_item&lt; value foo : int -> bool >>
</pre>

<p>This quotation, in a context of an expression, is equivalent
  to:</p>

<pre>
  MLast.SgVal loc (Ploc.VaVal "foo")
    (MLast.TyArr loc (MLast.TyLid loc (Ploc.VaVal "int"))
       (MLast.TyLid loc (Ploc.VaVal "bool")));
</pre>

<p>The name "<tt>loc</tt>" is predefined. However, it is possible to
  change it, using the argument "<tt>-loc</tt>" of the Camlp5 shell
  commands.</p>

<p>Consequently, if there is no variable "<tt>loc</tt>" defined in the
  context of the quotation, or if it is not of the good type, a
  semantic error occur in the OCaml compiler ("Unbound value
  loc").</p>

<p>Note that in the <a href="grammars.html">extensible grammars</a>,
  the variable "<tt>loc</tt>" is bound, in all semantic actions, to
  the location of the rule.</p>

<p>If the created node has no location, the programmer can define a
  variable named "<tt>loc</tt>" equal to "<tt>Ploc.dummy</tt>".</p>

<h3>In patterns</h3>

<p>When a quotation is in the context of a pattern, the location
  parameter of all nodes and possible sub-nodes is set to the wildcard
  ("<tt>_</tt>"). The same example above:</p>

<pre>
  &lt;:sig_item&lt; value foo : int -> bool >>
</pre>

<p>is equivalent, in a pattern, to:</p>

<pre>
  MLast.SgVal _ (Ploc.VaVal "foo")
    (MLast.TyArr _ (MLast.TyLid _ (Ploc.VaVal "int"))
       (MLast.TyLid _ (Ploc.VaVal "bool")))
</pre>

<h2>Antiquotations</h2>

<p>The expressions or patterns between dollar ($) characters are
  called <em>antiquotations</em>. In opposition to quotations which
  has its own syntax rules, the antiquotation is an area in the syntax
  of the enclosing context (expression or pattern). See the chapter
  about <a href="quot.html">quotations</a>.</p>

<p>If a quotation is in the context of an expression, the
  antiquotation must be an expression. It could be any expression,
  including function calls. Examples:</p>

<pre>
  value f e el = &lt;:expr&lt; [$e$ :: $loop False el$] >>;
  value patt_list p pl = &lt;:patt&lt; ( $list:[p::pl]$) >>;
</pre>

<p>If a quotation is in the context of an pattern, the antiquotation
  is a pattern. Any pattern is possible, including the wildcard
  character ("<tt>_</tt>"). Examples:</p>

<pre>
   fun [ &lt;:expr&lt; $lid:op$ $_$ $_$ >> -> op ]
   match p with [ &lt;:patt&lt; $_$ | $_$ >> -> Some p ]
</pre>

<h2>Two kinds of antiquotations</h2>

<h3>Preliminary remark</h3>

<p>In strict mode, we remark that most constructors defined of the
  module "<tt>MLast</tt>" are of type "<tt>Ploc.vala</tt>". This type
  is defined like this:</p>

<pre>
  type vala 'a =
    [ VaAnt of string
    | VaVal of 'a ]
  ;
</pre>

<p>The type argument is the real type of the node. For example, a
  value of type "<tt>bool</tt>" in transitional mode is frequently
  represented by a value of type "<tt>Ploc.vala bool</tt>".</p>

<p>The first case of the type "<tt>vala</tt>" corresponds to an
  antiquotation in the concrete syntax. The second case to a normal
  syntax situation, without antiquotation.</p>

<p>Example: in the "let" statement, the fact that it is "rec" or not
  is represented by a boolean. This boolean is, in the syntax tree,
  encapsulated with the type "<tt>Ploc.vala</tt>". The syntax tree of
  the two following lines:</p>

<pre>
  let x = y in z
  let rec x = y in z
</pre>

<p>start with, respectively:</p>

<pre>
  MLast.ExLet loc (Ploc.VaVal False)
    ... (* and so on *)
</pre>

<p>and:</p>

<pre>
  MLast.ExLet loc (Ploc.VaVal True)
    ... (* and so on *)
</pre>

<p>The case "<tt>Ploc.VaAnt s</tt>" is internally used by the parsers
  and by the quotation kit "<tt>q_ast.cmo</tt>" to record
  antiquotation strings representing the expression or the patterns
  having this value. For example, in this "let" statement:</p>

<pre>
  MLast.ExLet loc (Ploc.VaAnt s)
    ... (* and so on *)
</pre>

<p>The contents of this "<tt>s</tt>" is internally handled. For
  information, it contains the antiquotation string (kind included)
  together with representation of the location of the antiquotation
  in the quotation. See the next section.</p>

<h3>Antiquoting</h3>

<p>To antiquotate the fact that the "let" is with or without rec (a flag
  of type boolean), there are two ways.</p>

<h4>direct antiquoting</h4>

<p>The first way, hidding the type "<tt>Ploc.val</tt>", can be
  written with the antiquotation kind "flag":</p>

<pre>
  &lt;:expr&lt; let $flag:rf$ x = y in z >>
</pre>

<p>This corresponds to the syntax tree:</p>

<pre>
  MLast.ExLet loc (Ploc.VaVal rf)
     ... (* and so on *)
</pre>

<p>And, therefore, the type of the variable "<tt>rf</tt>" is simply
  "<tt>bool</tt>".</p>

<h4>general antiquoting</h4>

<p>The second way, introducing variables of type "<tt>Ploc.vala</tt>"
  can be written a kind prefixed by "<tt>_</tt>", namely here
  "<tt>_flag</tt>":</p>

<pre>
  &lt;:expr&lt; let $_flag:rf$ x = y in z >>
</pre>

<p>In that case, it corresponds to the syntax tree:</p>

<pre>
  MLast.ExLet loc rf
     ... (* and so on *)
</pre>

<p>And, therefore, the type of the variable "<tt>rf</tt>" is now
  "<tt>Ploc.vala bool</tt>".</p>

<h3>Remarks</h3>

<p>The first form of antiquotation ensures the compatibility with
  previous versions of Camlp5. The syntax tree is <em>not</em> the
  same, but the bound variables keep the same type.<p>

<p>All antiquotations kinds have these two forms: one with some name
  (e.g. "flag") and one with the same name prefixed by "a"
  (e.g. "aflag").</p>

<h2>Nodes and Quotations</h2>

<p>This section describes all nodes defined in the module "MLast" of
  Camlp5 and how to write them with quotations. Notice that, inside
  quotations, one is not restricted to these elementary cases, but
  any complex value can be used, resulting on possibly complex combined
  nodes.</p>

<p>The quotation forms are described here
    in <a href="revsynt.html">revised syntax</a> (like the rest of
    this document). In reality, it depends on which quotation kit is
    loaded:</p>

<ul>
  <li>If "<tt>q_MLast.cmo</tt>" is used, the revised syntax is
    mandatory: the quotations must be in that syntax without any
    extension.</li>
  <li>If "<tt>q_ast.cmo</tt>" is used, the quotation
    syntax <em>must</em> be in the current user syntax with
    all extensions added to compile the file.</li>
</ul>

<p>Last remark: in the following tables, the variables names give
  information of their types. The details can be found in the
  distributed source file "<tt>mLast.mli</tt>".</p>

<ul>
  <li><tt>e</tt>, <tt>e1</tt>, <tt>e2</tt>, <tt>e3</tt>: expr</li>
  <li><tt>p</tt>, <tt>p1</tt>, <tt>p2</tt>, <tt>p3</tt>: patt</li>
  <li><tt>t</tt>, <tt>t1</tt>, <tt>t2</tt>, <tt>e3</tt>: ctyp</li>
  <li><tt>s</tt>: string</li>
  <li><tt>b</tt>: bool</li>
  <li><tt>me</tt>, <tt>me1</tt>, <tt>me2</tt>: module_expr</li>
  <li><tt>mt</tt>, <tt>mt1</tt>, <tt>mt2</tt>: module_type</li>
  <li><tt>le</tt>: list expr</li>
  <li><tt>lp</tt>: list patt</li>
  <li><tt>lt</tt>: list ctyp</li>
  <li><tt>ls</tt>: list string</li>
  <li><tt>lse</tt>: list (string * expr)</li>
  <li><tt>lpe</tt>: list (patt * expr)</li>
  <li><tt>lpp</tt>: list (patt * patt)</li>
  <li><tt>lpoee</tt>: list (patt * option expr * expr)</li>
  <li><tt>op</tt>: option patt</li>
  <li><tt>lcstri</tt>: list class_str_item</li>
  <li><tt>lcsigi</tt>: list class_sig_item</li>
</ul>

<h3>expr</h3>

<p>Expressions of the language.</p>

<dl class="nodelist">
  <dt>- access</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $e1$ . $e2$ >></tt><br/>
    <tt style="color:red">ExAcc loc e1 e2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- antiquotation <a href="#expr_1">(1)</a></dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $anti:e$ >></tt><br/>
    <tt style="color:red">ExAnt loc e</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- application</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $e1$ $e2$ >></tt><br/>
    <tt style="color:red">ExApp loc e1 e2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- array access</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $e1$ .( $e2$ ) >></tt><br/>
    <tt style="color:red">ExAre loc e1 e2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- array</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; [| $list:le$ |] >></tt><br/>
    <tt style="color:red">ExArr loc (Ploc.VaVal le)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; [| $_list:le$ |] >></tt><br/>
    <tt style="color:red">ExArr loc le</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- assert</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; assert $e$ >></tt><br/>
    <tt style="color:red">ExAsr loc e</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- assignment</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $e1$ := $e2$ >></tt><br/>
    <tt style="color:red">ExAss loc e1 e2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- big array access</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $e$ .{ $list:le$ } >></tt><br/>
    <tt style="color:red">ExBae loc e (Ploc.VaVal le)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $e$ .{ $_list:le$ } >></tt><br/>
    <tt style="color:red">ExBae loc e le</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- character constant</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $chr:s$ >></tt><br/>
    <tt style="color:red">ExChr loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_chr:s$ >></tt><br/>
    <tt style="color:red">ExChr loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- coercion with type constraint</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; ($e$ : $t1$ :> $t2$) >></tt><br/>
    <tt style="color:red">ExCoe loc e (Some t1) t2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- coercion without type constraint</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; ($e$ :> $t2$) >></tt><br/>
    <tt style="color:red">ExCoe loc e None t2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- float constant</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $flo:s$ >></tt><br/>
    <tt style="color:red">ExFlo loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_flo:s$ >></tt><br/>
    <tt style="color:red">ExFlo loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- for</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; for $lid:s$ = $e1$ $to:b$ $e2$ do { $list:le$ } >></tt><br/>
    <tt style="color:red">ExFor loc (Ploc.VaVal s) e1 e2 (Ploc.VaVal b) (Ploc.VaVal le)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; for $_lid:s$ = $e1$ $_to:b$ $e2$ do { $_list:le$ } >></tt><br/>
    <tt style="color:red">ExFor loc s e1 e2 b le</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- function</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; fun [ $list:lpwe$ ] >></tt><br/>
    <tt style="color:red">ExFun loc (Ploc.VaVal lpwe)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; fun [ $_list:lpwe$ ] >></tt><br/>
    <tt style="color:red">ExFun loc lpwe</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- if</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; if $e1$ then $e2$ else $e3$ >></tt><br/>
    <tt style="color:red">ExIfe loc e1 e2 e3</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- integer constant</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $int:s$ >></tt><br/>
    <tt style="color:red">ExInt loc (Ploc.VaVal s) ""</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_int:s$ >></tt><br/>
    <tt style="color:red">ExInt loc s ""</tt><br/>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- integer 32 bits</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $int32:s$ >></tt><br/>
    <tt style="color:red">ExInt loc (Ploc.VaVal s) "l"</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_int32:s$ >></tt><br/>
    <tt style="color:red">ExInt loc s "l"</tt><br/>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- integer 64 bits</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $int64:s$ >></tt><br/>
    <tt style="color:red">ExInt loc (Ploc.VaVal s) "L"</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_int64:s$ >></tt><br/>
    <tt style="color:red">ExInt loc s "L"</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- native integer</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $nativeint:s$ >></tt><br/>
    <tt style="color:red">ExInt loc (Ploc.VaVal s) "n"</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_nativeint:s$ >></tt><br/>
    <tt style="color:red">ExInt loc s "n"</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- label</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; ~$s$ >></tt><br/>
    <tt style="color:red">ExLab loc (Ploc.VaVal s) None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; ~$_:s$ >></tt><br/>
    <tt style="color:red">ExLab loc s None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; ~$s$: $e$ >></tt><br/>
    <tt style="color:red">ExLab loc (Ploc.VaVal s) (Some e)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; ~$_:s$: $e$ >></tt><br/>
    <tt style="color:red">ExLab loc s (Some e)</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- lazy</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; lazy $e$ >></tt><br/>
    <tt style="color:red">ExLaz loc e</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- let binding</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; let $flag:b$ $list:lpe$ in $e$ >></tt><br/>
    <tt style="color:red">ExLet loc (Ploc.VaVal b) (Ploc.VaVal lpe) e</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; let $_flag:b$ $_list:lpe$ in $e$ >></tt><br/>
    <tt style="color:red">ExLet loc b lpe e</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- lowercase identifier</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $lid:s$ >></tt><br/>
    <tt style="color:red">ExLid loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_lid:s$ >></tt><br/>
    <tt style="color:red">ExLid loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- let module</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; let module $uid:s$ = $me$ in $e$ >></tt><br/>
    <tt style="color:red">ExLmd loc (Ploc.VaVal s) me e</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; let module $_uid:s$ = $me$ in $e$ >></tt><br/>
    <tt style="color:red">ExLmd loc s me e</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- match</a></dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; match $e$ with [ $list:lpwe$ ] >></tt><br/>
    <tt style="color:red">ExMat loc e (Ploc.VaVal lpwe)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; match $e$ with [ $_list:lpwe$ ] >></tt><br/>
    <tt style="color:red">ExMat loc e lpwe</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- new</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; new $list:ls$ >></tt><br/>
    <tt style="color:red">ExNew loc (Ploc.VaVal ls)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; new $_list:ls$ >></tt><br/>
    <tt style="color:red">ExNew loc ls</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- object expression</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; object $opt:op$ $list:lcstri$ end >></tt><br/>
    <tt style="color:red">ExObj loc (Ploc.VaVal op) (Ploc.VaVal lcstri)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; object $_opt:op$ $_list:lcstri$ end >></tt><br/>
    <tt style="color:red">ExObj loc op lcstri</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- option label</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; ?$s$ >></tt><br/>
    <tt style="color:red">ExOlb loc (Ploc.VaVal s) None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; ?$_:s$ >></tt><br/>
    <tt style="color:red">ExOlb loc s None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; ?$s$: $e$ >></tt><br/>
    <tt style="color:red">ExOlb loc (Ploc.VaVal s) (Some e)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; ?$_:s$: $e$ >></tt><br/>
    <tt style="color:red">ExOlb loc s (Some e)</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- override</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; {&lt; $list:lse$ >} >></tt><br/>
    <tt style="color:red">ExOvr loc (Ploc.VaVal lse)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; {&lt; $_list:lse$ >} >></tt><br/>
    <tt style="color:red">ExOvr loc lse</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- record</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; { $list:lpe$ } >></tt><br/>
    <tt style="color:red">ExRec loc (Ploc.VaVal lpe) None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; { $_list:lpe$ } >></tt><br/>
    <tt style="color:red">ExRec loc lpe None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; { ($e$) with $list:lpe$ } >></tt><br/>
    <tt style="color:red">ExRec loc (Ploc.VaVal lpe) (Some e)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; { ($e$) with $_list:lpe$ } >></tt><br/>
    <tt style="color:red">ExRec loc lpe (Some e)</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- sequence</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; do { $list:le$ } >></tt><br/>
    <tt style="color:red">ExSeq loc (Ploc.VaVal le)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; do { $_list:le$ } >></tt><br/>
    <tt style="color:red">ExSeq loc le</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- send</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $e$ # $lid:s$ >></tt><br/>
    <tt style="color:red">ExSnd loc e (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $e$ # $_lid:s$ >></tt><br/>
    <tt style="color:red">ExSnd loc e s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- string element</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $e1$ .[ $e2$ ] >></tt><br/>
    <tt style="color:red">ExSte loc e1 e2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- string</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $str:s$ >></tt><br/>
    <tt style="color:red">ExStr loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_str:s$ >></tt><br/>
    <tt style="color:red">ExStr loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- try</a></dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; try $e$ with [ $list:lpwe$ ] >></tt><br/>
    <tt style="color:red">ExTry loc e (Ploc.VaVal lpwe)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; try $e$ with [ $_list:lpwe$ ] >></tt><br/>
    <tt style="color:red">ExTry loc e lpwe</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- t-uple</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; ($list:le$) >></tt><br/>
    <tt style="color:red">ExTup loc (Ploc.VaVal le)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; ($_list:le$) >></tt><br/>
    <tt style="color:red">ExTup loc le</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- type constraint</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; ($e$ : $t$) >></tt><br/>
    <tt style="color:red">ExTyc loc e t</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- uppercase identifier</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $uid:s$ >></tt><br/>
    <tt style="color:red">ExUid loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_uid:s$ >></tt><br/>
    <tt style="color:red">ExUid loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- variant</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; `$s$ >></tt><br/>
    <tt style="color:red">ExVrn loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; `$_:s$ >></tt><br/>
    <tt style="color:red">ExVrn loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- while</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; while $e$ do { $list:le$ } >></tt><br/>
    <tt style="color:red">ExWhi loc e (Ploc.VaVal le)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; while $e$ do { $_list:le$ } >></tt><br/>
    <tt style="color:red">ExWhi loc e le</tt>
  </dd>
</dl>

<div id="expr_1" style="margin: 5mm 0 0 1cm">(1)
  <p>Node used in the quotation expanders to tells at conversion to
    OCaml compiler syntax tree time, that all locations of the
    sub-tree is correcty located in the quotation. By default, in
    quotations, the locations of all generated nodes are the location
    of the whole quotation. This node allows to make an exception to
    this rule, since we know that the antiquotation belongs to the
    universe of the enclosing program. See the chapter
    about <a href="quot.html">quotations</a> and, in particular, its
    section about antiquotations.</p>
</div>

<h3>patt</h3>

<p>Patterns of the language.</p>

<dl class="nodelist">
  <dt>- access</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $p1$ . $p2$ >></tt><br/>
    <tt style="color:red">PaAcc loc p1 p2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- alias</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; ($p1$ as $p2$) >></tt><br/>
    <tt style="color:red">PaAli loc p1 p2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- antiquotation <a href="#patt_1">(1)</a></dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $anti:p$ >></tt><br/>
    <tt style="color:red">PaAnt loc p</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- any</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; _ >></tt><br/>
    <tt style="color:red">PaAny loc</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- application</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $p1$ $p2$ >></tt><br/>
    <tt style="color:red">PaApp loc p1 p2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- array</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; [| $list:lp$ |] >></tt><br/>
    <tt style="color:red">PaArr loc (Ploc.VaVal lp)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; [| $_list:lp$ |] >></tt><br/>
    <tt style="color:red">PaArr loc lp</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- character</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $chr:s$ >></tt><br/>
    <tt style="color:red">PaChr loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_chr:s$ >></tt><br/>
    <tt style="color:red">PaChr loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- integer constant</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $int:s$ >></tt><br/>
    <tt style="color:red">PaInt loc (Ploc.VaVal s) ""</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_int:s$ >></tt><br/>
    <tt style="color:red">PaInt loc s ""</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- integer 32 bits</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $int32:s$ >></tt><br/>
    <tt style="color:red">PaInt loc (Ploc.VaVal s) "l"</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_int32:s$ >></tt><br/>
    <tt style="color:red">PaInt loc s "l"</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- integer 64 bits</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $int64:s$ >></tt><br/>
    <tt style="color:red">PaInt loc (Ploc.VaVal s) "L"</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_int:s$ >></tt><br/>
    <tt style="color:red">PaInt loc s "L"</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- native integer</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $nativeint:s$ >></tt><br/>
    <tt style="color:red">PaInt loc (Ploc.VaVal s) "n"</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_nativeint:s$ >></tt><br/>
    <tt style="color:red">PaInt loc s "n"</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- float</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $flo:s$ >></tt><br/>
    <tt style="color:red">PaFlo loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_flo:s$ >></tt><br/>
    <tt style="color:red">PaFlo loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- label</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; ~$s$ >></tt><br/>
    <tt style="color:red">PaLab loc (Ploc.VaVal s) None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ~$_:s$ >></tt><br/>
    <tt style="color:red">PaLab loc s None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ~$s$: $p$ >></tt><br/>
    <tt style="color:red">PaLab loc (Ploc.VaVal s) (Some p)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ~$_s$: $p$ >></tt><br/>
    <tt style="color:red">PaLab loc s (Some p)</tt><br/>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- lowercase identifier</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $lid:s$ >></tt><br/>
    <tt style="color:red">PaLid loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_lid:s$ >></tt><br/>
    <tt style="color:red">PaLid loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- option label</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; ?$s$ >></tt><br/>
    <tt style="color:red">PaOlb loc (Ploc.VaVal s) None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ?$_:s$ >></tt><br/>
    <tt style="color:red">PaOlb loc s None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ?$s$: ($p$) >></tt><br/>
    <tt style="color:red">PaOlb loc (Ploc.VaVal s) (Some (p, Ploc.VaVal None))</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ?$_:s$: ($p$) >></tt><br/>
    <tt style="color:red">PaOlb loc s (Some (p, Ploc.VaVal None))</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ?$s$: ($p$ = $e$) >></tt><br/>
    <tt style="color:red">PaOlb loc (Ploc.VaVal s) (Some (p, Ploc.VaVal (Some e)))</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ?$_:s$: ($p$ = $e$) >></tt><br/>
    <tt style="color:red">PaOlb loc s (Some (p, Ploc.VaVal (Some e)))</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- or</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $p1$ | $p2$ >></tt><br/>
    <tt style="color:red">PaOrp loc p1 p2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- range</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $p1$ .. $p2$ >></tt><br/>
    <tt style="color:red">PaRng loc p1 p2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- record</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; { $list:lpp$ } >></tt><br/>
    <tt style="color:red">PaRec loc (Ploc.VaVal lpp)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; { $_list:lpp$ } >></tt><br/>
    <tt style="color:red">PaRec loc lpp</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- string</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $str:s$ >></tt><br/>
    <tt style="color:red">PaStr loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_str:s$ >></tt><br/>
    <tt style="color:red">PaStr loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- t-uple</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; ($list:lp$) >></tt><br/>
    <tt style="color:red">PaTup loc (Ploc.VaVal lp)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ($_list:lp$) >></tt><br/>
    <tt style="color:red">PaTup loc lp</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- type constraint</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; ($p$ : $t$) >></tt><br/>
    <tt style="color:red">PaTyc loc p t</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- type pattern</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; # $list:ls$ >></tt><br/>
    <tt style="color:red">PaTyp loc (Ploc.VaVal ls)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; # $_list:ls$ >></tt><br/>
    <tt style="color:red">PaTyp loc ls</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- uppercase identifier</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $uid:s$ >></tt><br/>
    <tt style="color:red">PaUid loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_uid:s$ >></tt><br/>
    <tt style="color:red">PaUid loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- variant</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; ` $s$ >></tt><br/>
    <tt style="color:red">PaVrn loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ` $_:s$ >></tt><br/>
    <tt style="color:red">PaVrn loc s</tt>
  </dd>
</dl>

<div id="patt_1" style="margin: 5mm 0 0 1cm">(1)
  Node used to specify an antiquotation area, like for the
  equivalent node in expressions. See above.
</div>

<h3>ctyp</h3>

<p>Type expressions of the language.</p>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:ctyp&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>TyAcc loc t1 t2</tt></td>
    <td align="center"><tt>$t1$ . $t2$</tt></td>
    <td>dot</td>
  </tr>
  <tr>
    <td><tt>TyAli loc t1 t2</tt></td>
    <td align="center"><tt>$t1$ as $t2$</tt></td>
    <td>alias</td>
  </tr>
  <tr>
    <td><tt>TyAny loc</tt></td>
    <td align="center"><tt>_</tt></td>
    <td>wildcard</td>
  </tr>
  <tr>
    <td><tt>TyApp loc t1 t2</tt></td>
    <td align="center"><tt>$t1$ $t2$</tt></td>
    <td>application</td>
  </tr>
  <tr>
    <td><tt>TyArr loc t1 t2</tt></td>
    <td align="center"><tt>$t1$ -> $t2$</tt></td>
    <td>arrow</td>
  </tr>
  <tr>
    <td><tt>TyCls loc ls</tt></td>
    <td align="center"><tt># $list:ls$</tt></td>
    <td>class</td>
  </tr>
  <tr>
    <td><tt>TyLab loc s t</tt></td>
    <td align="center"><tt>~ $s$ : $t$</tt></td>
    <td>label</td>
  </tr>
  <tr>
    <td><tt>TyLid loc s</tt></td>
    <td align="center"><tt>$lid:s$</tt></td>
    <td>lowercase identifier</td>
  </tr>
  <tr>
    <td><tt>TyMan loc t1 t2</tt></td>
    <td align="center"><tt>$t1$ == $t2$</tt></td>
    <td>manifest</td>
  </tr>
  <tr>
    <td><tt>TyObj loc lst False</tt></td>
    <td align="center"><tt>&lt; $list:lst$ ></tt></td>
    <td>object</td>
  </tr>
  <tr>
    <td><tt>TyObj loc lst True</tt></td>
    <td align="center"><tt>&lt; $list:lst$ .. ></tt></td>
    <td>object</td>
  </tr>
  <tr>
    <td><tt>TyObj loc lst b</tt></td>
    <td align="center"><tt>&lt; $list:lst$ $flag:b$ ></tt></td>
    <td>object (general)</td>
  </tr>
  <tr>
    <td><tt>TyOlb loc s t</tt></td>
    <td align="center"><tt>? $s$ : $t$</tt></td>
    <td>option label</td>
  </tr>
  <tr>
    <td><tt>TyPol loc ls t</tt></td>
    <td align="center"><tt>! $list:ls$ . $t$</tt></td>
    <td>polymorph</td>
  </tr>
  <tr>
    <td><tt>TyQuo loc s</tt></td>
    <td align="center"><tt>' $s$</tt></td>
    <td>variable</td>
  </tr>
  <tr>
    <td><tt>TyRec loc llsbt</tt></td>
    <td align="center"><tt>{ $list:llsbt$ }</tt></td>
    <td>record</td>
  </tr>
  <tr>
    <td><tt>TySum loc llslt</tt></td>
    <td align="center"><tt>[ $list:llslt$ ]</tt></td>
    <td>sum</td>
  </tr>
  <tr>
    <td><tt>TyTup loc lt</tt></td>
    <td align="center"><tt>( $list:lt$ )</tt></td>
    <td>t-uple</td>
  </tr>
  <tr>
    <td><tt>TyUid loc s</tt></td>
    <td align="center"><tt>$uid:s$</tt></td>
    <td>uppercase identifier</td>
  </tr>
  <tr>
    <td><tt>TyVrn loc lpv None</tt></td>
    <td align="center"><tt>[ = $list:lpv$ ]</tt></td>
    <td>variant</td>
  </tr>
  <tr>
    <td><tt>TyVrn loc lpv (Some None)</tt></td>
    <td align="center"><tt>[ > $list:lpv$ ]</tt></td>
    <td>variant</td>
  </tr>
  <tr>
    <td><tt>TyVrn loc lpv (Some (Some []))</tt></td>
    <td align="center"><tt>[ &lt; $list:lpv$ ]</tt></td>
    <td>variant</td>
  </tr>
  <tr>
    <td><tt>TyVrn loc lpv (Some (Some ls))</tt></td>
    <td align="center"><tt>[ &lt; $list:lpv$ > $list:ls$ ]</tt></td>
    <td>variant</td>
  </tr>
</table>

<h3>modules...</h3>

<h4>str_item</h4>

<p>Structure items, i.e. phrases in a ".ml" file or "struct"s
  elements.</p>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:str_item&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>StCls loc lcd</tt></td>
    <td align="center"><tt>class $list:lcd$</tt></td>
    <td>class declaration</td>
  </tr>
  <tr>
    <td><tt>StClt loc lcdt</tt></td>
    <td align="center"><tt>class type $list:lctd$</tt></td>
    <td>class type declaration</td>
  </tr>
  <tr>
    <td><tt>StDcl loc lstri</tt></td>
    <td align="center"><tt>declare $list:lstri$ end</tt></td>
    <td>declare</td>
  </tr>
  <tr>
    <td><tt>StDir loc s None</tt></td>
    <td align="center"><tt># $s$</tt></td>
    <td>directive</td>
  </tr>
  <tr>
    <td><tt>StDir loc s (Some e)</tt></td>
    <td align="center"><tt># $s$ $e$</tt></td>
    <td>directive</td>
  </tr>
  <tr>
    <td><tt>StDir loc s oe</tt></td>
    <td align="center"><tt># $s$ $opt:oe$</tt></td>
    <td>directive (general)</td>
  </tr>
  <tr>
    <td><tt>StExc loc s lt []</tt></td>
    <td align="center"><tt>exception $s$ of $list:lt$</tt></td>
    <td>exception</td>
  </tr>
  <tr>
    <td><tt>StExc loc s lt ls</tt></td>
    <td align="center"><tt>exception $s$ of $list:lt$ = $list:ls$</tt></td>
    <td>exception</td>
  </tr>
  <tr>
    <td><tt>StExp loc e</tt></td>
    <td align="center"><tt>$exp:e$</tt></td>
    <td>expression</td>
  </tr>
  <tr>
    <td><tt>StExt loc s t ls</tt></td>
    <td align="center"><tt>external $s$ : $t$ = $list:ls$</tt></td>
    <td>external</td>
  </tr>
  <tr>
    <td><tt>StInc loc me</tt></td>
    <td align="center"><tt>include $me$</tt></td>
    <td>include</td>
  </tr>
  <tr>
    <td><tt>StMod loc b lsme</tt></td>
    <td align="center"><tt>module $flag:b$ $list:lsme$</tt></td>
    <td>module</td>
  </tr>
  <tr>
    <td><tt>StMty loc s mt</tt></td>
    <td align="center"><tt>module type $s$ = $mt$</tt></td>
    <td>module type</td>
  </tr>
  <tr>
    <td><tt>StOpn loc ls</tt></td>
    <td align="center"><tt>open $list:ls$</tt></td>
    <td>open</td>
  </tr>
  <tr>
    <td><tt>StTyp loc ltd</tt></td>
    <td align="center"><tt>type $list:ltd$</tt></td>
    <td>type declaration</td>
  </tr>
  <tr>
    <td><tt>StUse loc s lstrib</tt></td>
    <td align="center"><tt>...internal use...</tt></td>
    <td><a href="#str_item_1">(1)</a></td>
  </tr>
  <tr>
    <td><tt>StVal loc b lpe</tt></td>
    <td align="center"><tt>value $flag:b$ $list:lpe$</tt></td>
    <td>value</td>
  </tr>
</table>

<div id="t_str_item_1" style="margin: 5mm 0 0 1cm">(1)
  <p>Node internally used to specify a different file name applying to
    the whole subtree. This is generated by the directive "use" and
    used when converting to the OCaml syntax tree which needs the file
    name in its location type.</p>
</div>

<h4>sig_item</h4>

<p>Signature items, i.e. phrases in a ".mli" file or "sig"s
  elements.</p>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:sig_item&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>SgCls loc lcd</tt></td>
    <td align="center"><tt>class $list:lcd$</tt></td>
    <td>class</td>
  </tr>
  <tr>
    <td><tt>SgClt loc lct</tt></td>
    <td align="center"><tt>class type $list:lct$</tt></td>
    <td>class type</td>
  </tr>
  <tr>
    <td><tt>SgDcl loc lsigi</tt></td>
    <td align="center"><tt>declare $list:lsigi$ end</tt></td>
    <td>declare</td>
  </tr>
  <tr>
    <td><tt>SgDir loc s None</tt></td>
    <td align="center"><tt># $s$</tt></td>
    <td>directive</td>
  </tr>
  <tr>
    <td><tt>SgDir loc s (Some e)</tt></td>
    <td align="center"><tt># $s$ $e$</tt></td>
    <td>directive</td>
  </tr>
  <tr>
    <td><tt>SgDir loc s oe</tt></td>
    <td align="center"><tt># $s$ $opt:oe$</tt></td>
    <td>directive (general)</td>
  </tr>
  <tr>
    <td><tt>SgExc loc s []</tt></td>
    <td align="center"><tt>exception $s$</tt></td>
    <td>exception</td>
  </tr>
  <tr>
    <td><tt>SgExc loc s lt</tt></td>
    <td align="center"><tt>exception $s$ of $list:lt$</tt></td>
    <td>exception</td>
  </tr>
  <tr>
    <td><tt>SgExt loc s t ls</tt></td>
    <td align="center"><tt>external $s$ : $t$ = $list:ls$</tt></td>
    <td>external</td>
  </tr>
  <tr>
    <td><tt>SgInc loc me</tt></td>
    <td align="center"><tt>include $me$</tt></td>
    <td>include</td>
  </tr>
  <tr>
    <td><tt>SgMod loc b lsmt</tt></td>
    <td align="center"><tt>module $flag:b$ $list:lsmt$</tt></td>
    <td>module</td>
  </tr>
  <tr>
    <td><tt>SgMty loc s mt</tt></td>
    <td align="center"><tt>module type $s$ = $mt$</tt></td>
    <td>module type</td>
  </tr>
  <tr>
    <td><tt>SgOpn loc ls</tt></td>
    <td align="center"><tt>open $list:ls$</tt></td>
    <td>open</td>
  </tr>
  <tr>
    <td><tt>SgTyp loc ltd</tt></td>
    <td align="center"><tt>type $list:ltd$</tt></td>
    <td>type declaration</td>
  </tr>
  <tr>
    <td><tt>SgUse loc s lstrib</tt></td>
    <td align="center"><tt>...internal use...</tt></td>
    <td><a href="#sig_item_1">(1)</a></td>
  </tr>
  <tr>
    <td><tt>SgVal loc s t</tt></td>
    <td align="center"><tt>value $s$ : $t$</tt></td>
    <td>value</td>
  </tr>
</table>

<div id="t_sig_item_1" style="margin: 5mm 0 0 1cm">(1)
  <p>Same remark as for "<tt>str_item</tt>" above.</p>
</div>

<h4>module_expr</h4>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:module_expr&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>MeAcc loc me1 me2</tt></td>
    <td align="center"><tt>$me1$ . $me2$</tt></td>
    <td>dot</td>
  </tr>
  <tr>
    <td><tt>MeApp loc me1 me2</tt></td>
    <td align="center"><tt>$me1$ $me2$</tt></td>
    <td>application</td>
  </tr>
  <tr>
    <td><tt>MeFun loc s mt me</tt></td>
    <td align="center"><tt>functor ( $s$ : $mt$ ) ->  $me$</tt></td>
    <td>functor</td>
  </tr>
  <tr>
    <td><tt>MeStr loc lstri</tt></td>
    <td align="center"><tt>struct $list:lstri$ end</tt></td>
    <td>struct</td>
  </tr>
  <tr>
    <td><tt>MeTyc loc me mt</tt></td>
    <td align="center"><tt>( $me$ : $mt$ )</tt></td>
    <td>module type constraint</td>
  </tr>
  <tr>
    <td><tt>MeUid loc s</tt></td>
    <td align="center"><tt>$uid:s$</tt></td>
    <td>uppercase identifier</td>
  </tr>
</table>

<h4>module_type</h4>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:module_type&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>MtAcc loc mt1 mt2</tt></td>
    <td align="center"><tt>$mt1$ . $mt2$</tt></td>
    <td>dot</td>
  </tr>
  <tr>
    <td><tt>MtApp loc mt1 mt2</tt></td>
    <td align="center"><tt>$mt1$ $mt2$</tt></td>
    <td>application</td>
  </tr>
  <tr>
    <td><tt>MtFun loc s mt1 mt2</tt></td>
    <td align="center"><tt>functor ( $s$ : $mt1$ ) -> $mt2$</tt></td>
    <td>functor</td>
  </tr>
  <tr>
    <td><tt>MtLid loc s</tt></td>
    <td align="center"><tt>$lid:s$</tt></td>
    <td>lowercase identifier</td>
  </tr>
  <tr>
    <td><tt>MtQuo loc s</tt></td>
    <td align="center"><tt>' $s$</tt></td>
    <td>abstract</td>
  </tr>
  <tr>
    <td><tt>MtSig loc lsigi</tt></td>
    <td align="center"><tt>sig $list:lsigi$ end</tt></td>
    <td>signature</td>
  </tr>
  <tr>
    <td><tt>MtUid loc s</tt></td>
    <td align="center"><tt>$uid:s$</tt></td>
    <td>uppercase identifier</td>
  </tr>
  <tr>
    <td><tt>MtWit loc mt lwc</tt></td>
    <td align="center"><tt>$mt$ with $list:lwc$</tt></td>
    <td>with construction</td>
  </tr>
</table>

<h3>classes...</h3>

<h4>class_expr</h4>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:class_expr&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>CeApp loc ce e</tt></td>
    <td align="center"><tt>$ce$ $e$</tt></td>
    <td>application</td>
  </tr>
  <tr>
    <td><tt>CeCon loc ls lt</tt></td>
    <td align="center"><tt>$list:ls$ [ $list:lt$ ]</tt></td>
    <td>constructor</td>
  </tr>
  <tr>
    <td><tt>CeFun loc p ce</tt></td>
    <td align="center"><tt>fun $p$ -> $ce$</tt></td>
    <td>function</td>
  </tr>
  <tr>
    <td><tt>CeLet loc b lpe ce</tt></td>
    <td align="center"><tt>let $flag:b$ $list:lpe$ in $ce$</tt></td>
    <td>let binding</td>
  </tr>
  <tr>
    <td><tt>CeStr loc po lcstri</tt></td>
    <td align="center"><tt>object $opt:op$ $list:lcstri$ end</tt></td>
    <td>object</td>
  </tr>
  <tr>
    <td><tt>CeTyc loc ce ct</tt></td>
    <td align="center"><tt>($ce$ : $ct$)</tt></td>
    <td>class type constraint</td>
  </tr>
</table>  

<h4>class_type</h4>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:class_type&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>CtCon loc ls lt</tt></td>
    <td align="center"><tt>$list:ls$ [ $list:lt$ ] </tt></td>
    <td>constructor</td>
  </tr>
  <tr>
    <td><tt>CtFun loc t ct</tt></td>
    <td align="center"><tt>[ $t$ ] -> $ct$</tt></td>
    <td>arrow</td>
  </tr>
  <tr>
    <td><tt>CtSig loc pt None lcsigi_item</tt></td>
    <td align="center"><tt>object $list:lcsigi$ end</tt></td>
    <td>object</td>
  </tr>
  <tr>
    <td><tt>CtSig loc pt (Some t) lcsigi_item</tt></td>
    <td align="center"><tt>object ($t$) $list:lcsigi$ end</tt></td>
    <td>object</td>
  </tr>
  <tr>
    <td><tt>CtSig loc pt ot lcsigi_item</tt></td>
    <td align="center"><tt>object $opt:ot$ $list:lcsigi$ end</tt></td>
    <td>object (general)</td>
  </tr>
</table>

<h4>class_str_item</h4>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:class_str_item&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>CrCtr loc t1 t2</tt></td>
    <td align="center"><tt>type $t1$ = $t2$</tt></td>
    <td>type constraint</td>
  </tr>
  <tr>
    <td><tt>CrDcl loc lcstri</tt></td>
    <td align="center"><tt>declare $list:lcstri$ end </tt></td>
    <td>declaration list</td>
  </tr>
  <tr>
    <td><tt>CrInh loc ce None</tt></td>
    <td align="center"><tt>inherit $ce$</tt></td>
    <td>inheritance</td>
  </tr>
  <tr>
    <td><tt>CrInh loc ce (Some s)</tt></td>
    <td align="center"><tt>inherit $ce$ as $s$</tt></td>
    <td>inheritance</td>
  </tr>
  <tr>
    <td><tt>CrInh loc ce os</tt></td>
    <td align="center"><tt>inherit $ce$ $opt:s$</tt></td>
    <td>inheritance (general)</td>
  </tr>
  <tr>
    <td><tt>CrIni loc e</tt></td>
    <td align="center"><tt>initializer $e$</tt></td>
    <td>initialization</td>
  </tr>
  <tr>
    <td><tt>CrMth loc s False e None</tt></td>
    <td align="center"><tt>method $s$ = $e$</tt></td>
    <td>method</td>
  </tr>
  <tr>
    <td><tt>CrMth loc s False e (Some t)</tt></td>
    <td align="center"><tt>method $s$ : $t$ = $e$</tt></td>
    <td>method</td>
  </tr>
  <tr>
    <td><tt>CrMth loc s True e None</tt></td>
    <td align="center"><tt>method private $s$ = $e$</tt></td>
    <td>method</td>
  </tr>
  <tr>
    <td><tt>CrMth loc s True e (Some t)</tt></td>
    <td align="center"><tt>method private $s$ : $t$ = $e$</tt></td>
    <td>method</td>
  </tr>
  <tr>
    <td><tt>CrMth loc s b e ot</tt></td>
    <td align="center"><tt>method $flag:b$ $s$ $opt:ot$ = $e$</tt></td>
    <td>method (general)</td>
  </tr>
  <tr>
    <td><tt>CrVal loc s False e</tt></td>
    <td align="center"><tt>value $s$ = $e$</tt></td>
    <td>value</td>
  </tr>
  <tr>
    <td><tt>CrVal loc s True e</tt></td>
    <td align="center"><tt>value mutable $s$ = $e$</tt></td>
    <td>value</td>
  </tr>
  <tr>
    <td><tt>CrVal loc s b e</tt></td>
    <td align="center"><tt>value $flag:b$ $s$ = $e$</tt></td>
    <td>value (general)</td>
  </tr>
  <tr>
    <td><tt>CrVir loc s False t</tt></td>
    <td align="center"><tt>method virtual $s$ : $t$</tt></td>
    <td>virtual method</td>
  </tr>
  <tr>
    <td><tt>CrVir loc s True t</tt></td>
    <td align="center"><tt>method virtual private $s$ : $t$</tt></td>
    <td>virtual method</td>
  </tr>
  <tr>
    <td><tt>CrVir loc s b t</tt></td>
    <td align="center"><tt>method virtual $flag:b$ $s$ : $t$</tt></td>
    <td>virtual method (general)</td>
  </tr>
</table>

<h4>class_sig_item</h4>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:class_sig_item&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>CgCtr loc t1 t2</tt></td>
    <td align="center"><tt>type $t1$ = $t2$</tt></td>
    <td>type constraint</td>
  </tr>
  <tr>
    <td><tt>CgDcl loc lcsigi</tt></td>
    <td align="center"><tt>declare $list:lcsigi$ end</tt></td>
    <td>declare</td>
  </tr>
  <tr>
    <td><tt>CgInh loc ct</tt></td>
    <td align="center"><tt>inherit $ct$</tt></td>
    <td>inheritance </td>
  </tr>
  <tr>
    <td><tt>CgMth loc s False t</tt></td>
    <td align="center"><tt>method $s$ : $t$</tt></td>
    <td>method</td>
  </tr>
  <tr>
    <td><tt>CgMth loc s True t</tt></td>
    <td align="center"><tt>method private $s$ : $t$</tt></td>
    <td>method</td>
  </tr>
  <tr>
    <td><tt>CgMth loc s b t</tt></td>
    <td align="center"><tt>method $flag:b$ $s$ : $t$</tt></td>
    <td>method (general)</td>
  </tr>
  <tr>
    <td><tt>CgVal loc s False t</tt></td>
    <td align="center"><tt>value $s$ : $t$</tt></td>
    <td>value</td>
  </tr>
  <tr>
    <td><tt>CgVal loc s True t</tt></td>
    <td align="center"><tt>value mutable $s$ : $t$</tt></td>
    <td>value</td>
  </tr>
  <tr>
    <td><tt>CgVal loc s b t</tt></td>
    <td align="center"><tt>value $flag:b$ $s$ : $t$</tt></td>
    <td>value (general)</td>
  </tr>
  <tr>
    <td><tt>CgVir loc s False t</tt></td>
    <td align="center"><tt>method virtual $s$ : $t$</tt></td>
    <td>method virtual</td>
  </tr>
  <tr>
    <td><tt>CgVir loc s True t</tt></td>
    <td align="center"><tt>method virtual private $s$ : $t$</tt></td>
    <td>method virtual</td>
  </tr>
  <tr>
    <td><tt>CgVir loc s b t</tt></td>
    <td align="center"><tt>method virtual $flag:b$ $s$ : $t$</tt></td>
    <td>method virtual (general)</td>
  </tr>
</table>

<h3>other</h3>

<h4>with_constr</h4>

<p>"With" possibly following a module type.</p>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:with_const&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>WcTyp loc s ltv False t</tt></td>
    <td align="center"><tt>type $s$ $list:ltv$ = $t$</tt></td>
    <td>with type</td>
  </tr>
  <tr>
    <td><tt>WcTyp loc s ltv True t</tt></td>
    <td align="center"><tt>type $s$ $list:ltv$ = private $t$</tt></td>
    <td>with type</td>
  </tr>
  <tr>
    <td><tt>WcTyp loc s ltv b t</tt></td>
    <td align="center"><tt>type $s$ $list:ltv$ = $flag:b$ $t$</tt></td>
    <td>with type (general)</td>
  </tr>
  <tr>
    <td><tt>WcMod loc ls me</tt></td>
    <td align="center"><tt>module $list:ls$ = $me$</tt></td>
    <td>with module</td>
  </tr>
</table>

<h4>poly_variant</h4>

<p>Polymorphic variants.</p>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:poly_variant&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>PvTag s False []</tt></td>
    <td align="center"><tt>` $i$</tt></td>
    <td>constructor</td>
  </tr>
  <tr>
    <td><tt>PvTag s True lt</tt></td>
    <td align="center"><tt>` $i$ of &amp; $list:lt$</tt></td>
    <td>constructor</td>
  </tr>
  <tr>
    <td><tt>PvTag s b lt</tt></td>
    <td align="center"><tt>` $i$ of $flag:b$ $list:lt$</tt></td>
    <td>constructor (general)</td>
  </tr>
  <tr>
    <td><tt>PvInh t</tt></td>
    <td align="center"><tt>$t$</tt></td>
    <td>type</td>
  </tr>
</table>

<p>... to be added: <tt>type_decl</tt>, <tt>type_var</tt>
  and <tt>class_infos</tt>)...</p>

<div class="trailer">
</div>

</div>

</body>
</html>
