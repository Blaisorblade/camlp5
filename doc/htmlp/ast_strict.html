<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <!-- $Id: ast_strict.html,v 1.14 2007/09/25 10:08:04 deraugla Exp $ -->
  <!-- Copyright (c) 2007 INRIA -->
  <title>AST - strict</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="styles/base.css"
        title="Normal" />
  <style type="text/css">
    .nodelist { margin-left: 2cm }
    table { margin-left: 1cm }
    td { padding-right: 2mm }
  </style>
</head>
<body>

<div id="menu">
</div>

<div id="content">

<h1 class="top">Syntax tree - strict mode</h1>

<p>This chapter presents the Camlp5 syntax tree when Camlp5 is installed
  in <em>strict</em> mode.</p>

<div id="tableofcontents">
</div>

<h2>Introduction</h2>

<p>This syntax tree is defined in the module "<tt>MLast</tt>" provided
  by Camlp5. Each node corresponds to a syntactic entity of the
  corresponding type.</p>

<p>For example, the syntax tree of the statement "<tt>if</tt>" can
  be written:</p>

<pre>
  MLast.ExIfe loc e1 e2 e3
</pre>

<p>where "<tt>loc</tt>" is the location in the source, and
  "<tt>e1</tt>", "<tt>e2</tt>" and "<tt>e3</tt>" are
  respectively the expression after the "<tt>if</tt>", the one after
  the "<tt>then</tt>" and the one after the "<tt>else</tt>".</p>

<p>If a program needs to manipulate syntax trees, it can use the
  nodes defined in the module "<tt>MLast</tt>". It supposes to
  know how the concrete syntax is transformed in to this abstract
  syntax.</p>

<p>However, a simpler solution is to use one of the quotation kits
  "<tt>q_MLast.cmo</tt>" or "<tt>q_ast.cmo</tt>". Both propose
  <a href="quot.html">quotations</a> which represent the abstract
  syntax (the nodes of the module "<tt>MLast</tt>") into concrete
  syntax with antiquotations to bind variables inside. The example
  above can be written:</p>

<pre>
  &lt;:expr&lt; if $e1$ then $e2$ else $e3$ >>
</pre>

<p>This representation is very interesting when one wants to
  manipulate complicated syntax trees. Here is an example taken from
  the Camlp5 sources themselves:</p>

<pre>
  &lt;:expr&lt;
    match try Some $f$ with [ Stream.Failure -> None ] with
    [ Some $p$ -> $e$
    | _ -> raise (Stream.Error $e2$) ]
  >>
</pre>

<p>This example was in a position of a pattern. In abstract syntax, it
  should have been written:</p>

<pre>
  MLast.ExMat _
    (MLast.ExTry _ (MLast.ExApp _ (MLast.ExUid _ (Ploc.VaVal "Some")) f)
       (Ploc.VaVal
          [(MLast.PaAcc _ (MLast.PaUid _ (Ploc.VaVal "Stream"))
             (MLast.PaUid _ (Ploc.VaVal "Failure")),
            Ploc.VaVal None, MLast.ExUid _ (Ploc.VaVal "None"))]))
    (Ploc.VaVal
       [(MLast.PaApp _ (MLast.PaUid _ (Ploc.VaVal "Some")) p,
         Ploc.VaVal None, e);
        (MLast.PaAny _, Ploc.VaVal None,
         MLast.ExApp _ (MLast.ExLid _ (Ploc.VaVal "raise"))
           (MLast.ExApp _
              (MLast.ExAcc _ (MLast.ExUid _ (Ploc.VaVal "Stream"))
                 (MLast.ExUid _ (Ploc.VaVal "Error")))
              e2))])
</pre>

<p>Which is less readable and much more complicated to build and
  update.</p>

<p>Instead of thinking of "a syntax tree", the programmer has to think
  of "a piece of program".</p>

<h2>Location</h2>

<p>In all syntax tree nodes, the first parameter is the source
  location of the node.</p>

<h3>In expressions</h3>

<p>When a quotation is in the context of an expression, the location
  parameter is "<tt>loc</tt>" in the node and in all its possible
  sub-nodes. Example: if we consider the quotation:</p>

<pre>
  &lt;:sig_item&lt; value foo : int -> bool >>
</pre>

<p>This quotation, in a context of an expression, is equivalent
  to:</p>

<pre>
  MLast.SgVal loc (Ploc.VaVal "foo")
    (MLast.TyArr loc (MLast.TyLid loc (Ploc.VaVal "int"))
       (MLast.TyLid loc (Ploc.VaVal "bool")));
</pre>

<p>The name "<tt>loc</tt>" is predefined. However, it is possible to
  change it, using the argument "<tt>-loc</tt>" of the Camlp5 shell
  commands.</p>

<p>Consequently, if there is no variable "<tt>loc</tt>" defined in the
  context of the quotation, or if it is not of the good type, a
  semantic error occur in the OCaml compiler ("Unbound value
  loc").</p>

<p>Note that in the <a href="grammars.html">extensible grammars</a>,
  the variable "<tt>loc</tt>" is bound, in all semantic actions, to
  the location of the rule.</p>

<p>If the created node has no location, the programmer can define a
  variable named "<tt>loc</tt>" equal to "<tt>Ploc.dummy</tt>".</p>

<h3>In patterns</h3>

<p>When a quotation is in the context of a pattern, the location
  parameter of all nodes and possible sub-nodes is set to the wildcard
  ("<tt>_</tt>"). The same example above:</p>

<pre>
  &lt;:sig_item&lt; value foo : int -> bool >>
</pre>

<p>is equivalent, in a pattern, to:</p>

<pre>
  MLast.SgVal _ (Ploc.VaVal "foo")
    (MLast.TyArr _ (MLast.TyLid _ (Ploc.VaVal "int"))
       (MLast.TyLid _ (Ploc.VaVal "bool")))
</pre>

<h2>Antiquotations</h2>

<p>The expressions or patterns between dollar ($) characters are
  called <em>antiquotations</em>. In opposition to quotations which
  has its own syntax rules, the antiquotation is an area in the syntax
  of the enclosing context (expression or pattern). See the chapter
  about <a href="quot.html">quotations</a>.</p>

<p>If a quotation is in the context of an expression, the
  antiquotation must be an expression. It could be any expression,
  including function calls. Examples:</p>

<pre>
  value f e el = &lt;:expr&lt; [$e$ :: $loop False el$] >>;
  value patt_list p pl = &lt;:patt&lt; ( $list:[p::pl]$) >>;
</pre>

<p>If a quotation is in the context of an pattern, the antiquotation
  is a pattern. Any pattern is possible, including the wildcard
  character ("<tt>_</tt>"). Examples:</p>

<pre>
   fun [ &lt;:expr&lt; $lid:op$ $_$ $_$ >> -> op ]
   match p with [ &lt;:patt&lt; $_$ | $_$ >> -> Some p ]
</pre>

<h2>Two kinds of antiquotations</h2>

<h3>Preliminary remark</h3>

<p>In strict mode, we remark that most constructors defined of the
  module "<tt>MLast</tt>" are of type "<tt>Ploc.vala</tt>". This type
  is defined like this:</p>

<pre>
  type vala 'a =
    [ VaAnt of string
    | VaVal of 'a ]
  ;
</pre>

<p>The type argument is the real type of the node. For example, a
  value of type "<tt>bool</tt>" in transitional mode is frequently
  represented by a value of type "<tt>Ploc.vala bool</tt>".</p>

<p>The first case of the type "<tt>vala</tt>" corresponds to an
  antiquotation in the concrete syntax. The second case to a normal
  syntax situation, without antiquotation.</p>

<p>Example: in the "let" statement, the fact that it is "rec" or not
  is represented by a boolean. This boolean is, in the syntax tree,
  encapsulated with the type "<tt>Ploc.vala</tt>". The syntax tree of
  the two following lines:</p>

<pre>
  let x = y in z
  let rec x = y in z
</pre>

<p>start with, respectively:</p>

<pre>
  MLast.ExLet loc (Ploc.VaVal False)
    ... (* and so on *)
</pre>

<p>and:</p>

<pre>
  MLast.ExLet loc (Ploc.VaVal True)
    ... (* and so on *)
</pre>

<p>The case "<tt>Ploc.VaAnt s</tt>" is internally used by the parsers
  and by the quotation kit "<tt>q_ast.cmo</tt>" to record
  antiquotation strings representing the expression or the patterns
  having this value. For example, in this "let" statement:</p>

<pre>
  MLast.ExLet loc (Ploc.VaAnt s)
    ... (* and so on *)
</pre>

<p>The contents of this "<tt>s</tt>" is internally handled. For
  information, it contains the antiquotation string (kind included)
  together with representation of the location of the antiquotation
  in the quotation. See the next section.</p>

<h3>Antiquoting</h3>

<p>To antiquotate the fact that the "let" is with or without rec (a flag
  of type boolean), there are two ways.</p>

<h4>direct antiquoting</h4>

<p>The first way, hidding the type "<tt>Ploc.val</tt>", can be
  written with the antiquotation kind "flag":</p>

<pre>
  &lt;:expr&lt; let $flag:rf$ x = y in z >>
</pre>

<p>This corresponds to the syntax tree:</p>

<pre>
  MLast.ExLet loc (Ploc.VaVal rf)
     ... (* and so on *)
</pre>

<p>And, therefore, the type of the variable "<tt>rf</tt>" is simply
  "<tt>bool</tt>".</p>

<h4>general antiquoting</h4>

<p>The second way, introducing variables of type "<tt>Ploc.vala</tt>"
  can be written a kind prefixed by "<tt>_</tt>", namely here
  "<tt>_flag</tt>":</p>

<pre>
  &lt;:expr&lt; let $_flag:rf$ x = y in z >>
</pre>

<p>In that case, it corresponds to the syntax tree:</p>

<pre>
  MLast.ExLet loc rf
     ... (* and so on *)
</pre>

<p>And, therefore, the type of the variable "<tt>rf</tt>" is now
  "<tt>Ploc.vala bool</tt>".</p>

<h3>Remarks</h3>

<p>The first form of antiquotation ensures the compatibility with
  previous versions of Camlp5. The syntax tree is <em>not</em> the
  same, but the bound variables keep the same type.</p>

<p>All antiquotations kinds have these two forms: one with some name
  (e.g. "flag") and one with the same name prefixed by "a"
  (e.g. "aflag").</p>

<h2>Nodes and Quotations</h2>

<p>This section describes all nodes defined in the module "MLast" of
  Camlp5 and how to write them with quotations. Notice that, inside
  quotations, one is not restricted to these elementary cases, but
  any complex value can be used, resulting on possibly complex combined
  nodes.</p>

<p>The quotation forms are described here
    in <a href="revsynt.html">revised syntax</a> (like the rest of
    this document). In reality, it depends on which quotation kit is
    loaded:</p>

<ul>
  <li>If "<tt>q_MLast.cmo</tt>" is used, the revised syntax is
    mandatory: the quotations must be in that syntax without any
    extension.</li>
  <li>If "<tt>q_ast.cmo</tt>" is used, the quotation
    syntax <em>must</em> be in the current user syntax with
    all extensions added to compile the file.</li>
</ul>

<p>Last remark: in the following tables, the variables names give
  information of their types. The details can be found in the
  distributed source file "<tt>mLast.mli</tt>".</p>

<ul>
  <li><tt>e</tt>, <tt>e1</tt>, <tt>e2</tt>, <tt>e3</tt>: expr</li>
  <li><tt>p</tt>, <tt>p1</tt>, <tt>p2</tt>, <tt>p3</tt>: patt</li>
  <li><tt>t</tt>, <tt>t1</tt>, <tt>t2</tt>, <tt>e3</tt>: ctyp</li>
  <li><tt>s</tt>: string</li>
  <li><tt>b</tt>: bool</li>
  <li><tt>me</tt>, <tt>me1</tt>, <tt>me2</tt>: module_expr</li>
  <li><tt>mt</tt>, <tt>mt1</tt>, <tt>mt2</tt>: module_type</li>
  <li><tt>le</tt>: list expr</li>
  <li><tt>lp</tt>: list patt</li>
  <li><tt>lt</tt>: list ctyp</li>
  <li><tt>ls</tt>: list string</li>
  <li><tt>lse</tt>: list (string * expr)</li>
  <li><tt>lpe</tt>: list (patt * expr)</li>
  <li><tt>lpp</tt>: list (patt * patt)</li>
  <li><tt>lpoee</tt>: list (patt * option expr * expr)</li>
  <li><tt>op</tt>: option patt</li>
  <li><tt>lcstri</tt>: list class_str_item</li>
  <li><tt>lcsigi</tt>: list class_sig_item</li>
</ul>

<h3>expr</h3>

<p>Expressions of the language.</p>

<dl class="nodelist">
  <dt>- access</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $e1$ . $e2$ >></tt><br/>
    <tt style="color:red">MLast.ExAcc loc e1 e2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- antiquotation <a href="#expr_1">(1)</a></dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $anti:e$ >></tt><br/>
    <tt style="color:red">MLast.ExAnt loc e</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- application</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $e1$ $e2$ >></tt><br/>
    <tt style="color:red">MLast.ExApp loc e1 e2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- array access</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $e1$ .( $e2$ ) >></tt><br/>
    <tt style="color:red">MLast.ExAre loc e1 e2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- array</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; [| $list:le$ |] >></tt><br/>
    <tt style="color:red">MLast.ExArr loc (Ploc.VaVal le)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; [| $_list:le$ |] >></tt><br/>
    <tt style="color:red">MLast.ExArr loc le</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- assert</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; assert $e$ >></tt><br/>
    <tt style="color:red">MLast.ExAsr loc e</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- assignment</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $e1$ := $e2$ >></tt><br/>
    <tt style="color:red">MLast.ExAss loc e1 e2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- big array access</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $e$ .{ $list:le$ } >></tt><br/>
    <tt style="color:red">MLast.ExBae loc e (Ploc.VaVal le)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $e$ .{ $_list:le$ } >></tt><br/>
    <tt style="color:red">MLast.ExBae loc e le</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- character constant</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $chr:s$ >></tt><br/>
    <tt style="color:red">MLast.ExChr loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_chr:s$ >></tt><br/>
    <tt style="color:red">MLast.ExChr loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- coercion with type constraint</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; ($e$ : $t1$ :> $t2$) >></tt><br/>
    <tt style="color:red">MLast.ExCoe loc e (Some t1) t2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- coercion without type constraint</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; ($e$ :> $t2$) >></tt><br/>
    <tt style="color:red">MLast.ExCoe loc e None t2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- float constant</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $flo:s$ >></tt><br/>
    <tt style="color:red">MLast.ExFlo loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_flo:s$ >></tt><br/>
    <tt style="color:red">MLast.ExFlo loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- for</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; for $lid:s$ = $e1$ $to:b$ $e2$ do { $list:le$ } >></tt><br/>
    <tt style="color:red">MLast.ExFor loc (Ploc.VaVal s) e1 e2 (Ploc.VaVal b) (Ploc.VaVal le)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; for $_lid:s$ = $e1$ $_to:b$ $e2$ do { $_list:le$ } >></tt><br/>
    <tt style="color:red">MLast.ExFor loc s e1 e2 b le</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- function</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; fun [ $list:lpwe$ ] >></tt><br/>
    <tt style="color:red">MLast.ExFun loc (Ploc.VaVal lpwe)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; fun [ $_list:lpwe$ ] >></tt><br/>
    <tt style="color:red">MLast.ExFun loc lpwe</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- if</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; if $e1$ then $e2$ else $e3$ >></tt><br/>
    <tt style="color:red">MLast.ExIfe loc e1 e2 e3</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- integer constant</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $int:s$ >></tt><br/>
    <tt style="color:red">MLast.ExInt loc (Ploc.VaVal s) ""</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_int:s$ >></tt><br/>
    <tt style="color:red">MLast.ExInt loc s ""</tt><br/>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- integer 32 bits</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $int32:s$ >></tt><br/>
    <tt style="color:red">MLast.ExInt loc (Ploc.VaVal s) "l"</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_int32:s$ >></tt><br/>
    <tt style="color:red">MLast.ExInt loc s "l"</tt><br/>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- integer 64 bits</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $int64:s$ >></tt><br/>
    <tt style="color:red">MLast.ExInt loc (Ploc.VaVal s) "L"</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_int64:s$ >></tt><br/>
    <tt style="color:red">MLast.ExInt loc s "L"</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- native integer</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $nativeint:s$ >></tt><br/>
    <tt style="color:red">MLast.ExInt loc (Ploc.VaVal s) "n"</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_nativeint:s$ >></tt><br/>
    <tt style="color:red">MLast.ExInt loc s "n"</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- label</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; ~$s$ >></tt><br/>
    <tt style="color:red">MLast.ExLab loc (Ploc.VaVal s) None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; ~$_:s$ >></tt><br/>
    <tt style="color:red">MLast.ExLab loc s None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; ~$s$: $e$ >></tt><br/>
    <tt style="color:red">MLast.ExLab loc (Ploc.VaVal s) (Some e)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; ~$_:s$: $e$ >></tt><br/>
    <tt style="color:red">MLast.ExLab loc s (Some e)</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- lazy</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; lazy $e$ >></tt><br/>
    <tt style="color:red">MLast.ExLaz loc e</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- let binding</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; let $flag:b$ $list:lpe$ in $e$ >></tt><br/>
    <tt style="color:red">MLast.ExLet loc (Ploc.VaVal b) (Ploc.VaVal lpe) e</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; let $_flag:b$ $_list:lpe$ in $e$ >></tt><br/>
    <tt style="color:red">MLast.ExLet loc b lpe e</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- lowercase identifier</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $lid:s$ >></tt><br/>
    <tt style="color:red">MLast.ExLid loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_lid:s$ >></tt><br/>
    <tt style="color:red">MLast.ExLid loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- let module</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; let module $uid:s$ = $me$ in $e$ >></tt><br/>
    <tt style="color:red">MLast.ExLmd loc (Ploc.VaVal s) me e</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; let module $_uid:s$ = $me$ in $e$ >></tt><br/>
    <tt style="color:red">MLast.ExLmd loc s me e</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- match</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; match $e$ with [ $list:lpwe$ ] >></tt><br/>
    <tt style="color:red">MLast.ExMat loc e (Ploc.VaVal lpwe)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; match $e$ with [ $_list:lpwe$ ] >></tt><br/>
    <tt style="color:red">MLast.ExMat loc e lpwe</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- new</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; new $list:ls$ >></tt><br/>
    <tt style="color:red">MLast.ExNew loc (Ploc.VaVal ls)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; new $_list:ls$ >></tt><br/>
    <tt style="color:red">MLast.ExNew loc ls</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- object expression</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; object $opt:op$ $list:lcstri$ end >></tt><br/>
    <tt style="color:red">MLast.ExObj loc (Ploc.VaVal op) (Ploc.VaVal lcstri)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; object $_opt:op$ $_list:lcstri$ end >></tt><br/>
    <tt style="color:red">MLast.ExObj loc op lcstri</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- option label</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; ?$s$ >></tt><br/>
    <tt style="color:red">MLast.ExOlb loc (Ploc.VaVal s) None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; ?$_:s$ >></tt><br/>
    <tt style="color:red">MLast.ExOlb loc s None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; ?$s$: $e$ >></tt><br/>
    <tt style="color:red">MLast.ExOlb loc (Ploc.VaVal s) (Some e)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; ?$_:s$: $e$ >></tt><br/>
    <tt style="color:red">MLast.ExOlb loc s (Some e)</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- override</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; {&lt; $list:lse$ >} >></tt><br/>
    <tt style="color:red">MLast.ExOvr loc (Ploc.VaVal lse)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; {&lt; $_list:lse$ >} >></tt><br/>
    <tt style="color:red">MLast.ExOvr loc lse</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- record</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; { $list:lpe$ } >></tt><br/>
    <tt style="color:red">MLast.ExRec loc (Ploc.VaVal lpe) None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; { $_list:lpe$ } >></tt><br/>
    <tt style="color:red">MLast.ExRec loc lpe None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; { ($e$) with $list:lpe$ } >></tt><br/>
    <tt style="color:red">MLast.ExRec loc (Ploc.VaVal lpe) (Some e)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; { ($e$) with $_list:lpe$ } >></tt><br/>
    <tt style="color:red">MLast.ExRec loc lpe (Some e)</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- sequence</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; do { $list:le$ } >></tt><br/>
    <tt style="color:red">MLast.ExSeq loc (Ploc.VaVal le)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; do { $_list:le$ } >></tt><br/>
    <tt style="color:red">MLast.ExSeq loc le</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- send</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $e$ # $lid:s$ >></tt><br/>
    <tt style="color:red">MLast.ExSnd loc e (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $e$ # $_lid:s$ >></tt><br/>
    <tt style="color:red">MLast.ExSnd loc e s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- string element</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $e1$ .[ $e2$ ] >></tt><br/>
    <tt style="color:red">MLast.ExSte loc e1 e2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- string</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $str:s$ >></tt><br/>
    <tt style="color:red">MLast.ExStr loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_str:s$ >></tt><br/>
    <tt style="color:red">MLast.ExStr loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- try</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; try $e$ with [ $list:lpwe$ ] >></tt><br/>
    <tt style="color:red">MLast.ExTry loc e (Ploc.VaVal lpwe)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; try $e$ with [ $_list:lpwe$ ] >></tt><br/>
    <tt style="color:red">MLast.ExTry loc e lpwe</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- t-uple</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; ($list:le$) >></tt><br/>
    <tt style="color:red">MLast.ExTup loc (Ploc.VaVal le)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; ($_list:le$) >></tt><br/>
    <tt style="color:red">MLast.ExTup loc le</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- type constraint</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; ($e$ : $t$) >></tt><br/>
    <tt style="color:red">MLast.ExTyc loc e t</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- uppercase identifier</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; $uid:s$ >></tt><br/>
    <tt style="color:red">MLast.ExUid loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; $_uid:s$ >></tt><br/>
    <tt style="color:red">MLast.ExUid loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- variant</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; `$s$ >></tt><br/>
    <tt style="color:red">MLast.ExVrn loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; `$_:s$ >></tt><br/>
    <tt style="color:red">MLast.ExVrn loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- while</dt>
  <dd>
    <tt style="color:blue">&lt;:expr&lt; while $e$ do { $list:le$ } >></tt><br/>
    <tt style="color:red">MLast.ExWhi loc e (Ploc.VaVal le)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:expr&lt; while $e$ do { $_list:le$ } >></tt><br/>
    <tt style="color:red">MLast.ExWhi loc e le</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- extra node <a href="#expr_2">(2)</a></dt>
  <dd>
    <tt style="color:blue">... no representation ...</tt><br/>
    <tt style="color:red">MLast.ExXtr loc s oe</tt>
  </dd>
</dl>

<div id="expr_1" style="margin: 5mm 0 0 1cm">(1)
  <p>Node used in the quotation expanders to tells at conversion to
    OCaml compiler syntax tree time, that all locations of the
    sub-tree is correcty located in the quotation. By default, in
    quotations, the locations of all generated nodes are the location
    of the whole quotation. This node allows to make an exception to
    this rule, since we know that the antiquotation belongs to the
    universe of the enclosing program. See the chapter
    about <a href="quot.html">quotations</a> and, in particular, its
    section about antiquotations.</p>
</div>

<div id="expr_2" style="margin: 5mm 0 0 1cm">(2)
  <p>Extra node internally used by the quotation kit
    "<tt>q_ast.cmo</tt>" to build antiquotations of expressions.</p>
</div>

<h3>patt</h3>

<p>Patterns of the language.</p>

<dl class="nodelist">
  <dt>- access</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $p1$ . $p2$ >></tt><br/>
    <tt style="color:red">MLast.PaAcc loc p1 p2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- alias</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; ($p1$ as $p2$) >></tt><br/>
    <tt style="color:red">MLast.PaAli loc p1 p2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- antiquotation <a href="#patt_1">(1)</a></dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $anti:p$ >></tt><br/>
    <tt style="color:red">MLast.PaAnt loc p</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- any</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; _ >></tt><br/>
    <tt style="color:red">MLast.PaAny loc</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- application</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $p1$ $p2$ >></tt><br/>
    <tt style="color:red">MLast.PaApp loc p1 p2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- array</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; [| $list:lp$ |] >></tt><br/>
    <tt style="color:red">MLast.PaArr loc (Ploc.VaVal lp)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; [| $_list:lp$ |] >></tt><br/>
    <tt style="color:red">MLast.PaArr loc lp</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- character</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $chr:s$ >></tt><br/>
    <tt style="color:red">MLast.PaChr loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_chr:s$ >></tt><br/>
    <tt style="color:red">MLast.PaChr loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- integer constant</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $int:s$ >></tt><br/>
    <tt style="color:red">MLast.PaInt loc (Ploc.VaVal s) ""</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_int:s$ >></tt><br/>
    <tt style="color:red">MLast.PaInt loc s ""</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- integer 32 bits</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $int32:s$ >></tt><br/>
    <tt style="color:red">MLast.PaInt loc (Ploc.VaVal s) "l"</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_int32:s$ >></tt><br/>
    <tt style="color:red">MLast.PaInt loc s "l"</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- integer 64 bits</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $int64:s$ >></tt><br/>
    <tt style="color:red">MLast.PaInt loc (Ploc.VaVal s) "L"</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_int:s$ >></tt><br/>
    <tt style="color:red">MLast.PaInt loc s "L"</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- native integer</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $nativeint:s$ >></tt><br/>
    <tt style="color:red">MLast.PaInt loc (Ploc.VaVal s) "n"</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_nativeint:s$ >></tt><br/>
    <tt style="color:red">MLast.PaInt loc s "n"</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- float</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $flo:s$ >></tt><br/>
    <tt style="color:red">MLast.PaFlo loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_flo:s$ >></tt><br/>
    <tt style="color:red">MLast.PaFlo loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- label</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; ~$s$ >></tt><br/>
    <tt style="color:red">MLast.PaLab loc (Ploc.VaVal s) None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ~$_:s$ >></tt><br/>
    <tt style="color:red">MLast.PaLab loc s None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ~$s$: $p$ >></tt><br/>
    <tt style="color:red">MLast.PaLab loc (Ploc.VaVal s) (Some p)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ~$_s$: $p$ >></tt><br/>
    <tt style="color:red">MLast.PaLab loc s (Some p)</tt><br/>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- lowercase identifier</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $lid:s$ >></tt><br/>
    <tt style="color:red">MLast.PaLid loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_lid:s$ >></tt><br/>
    <tt style="color:red">MLast.PaLid loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- option label</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; ?$s$ >></tt><br/>
    <tt style="color:red">MLast.PaOlb loc (Ploc.VaVal s) None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ?$_:s$ >></tt><br/>
    <tt style="color:red">MLast.PaOlb loc s None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ?$s$: ($p$) >></tt><br/>
    <tt style="color:red">MLast.PaOlb loc (Ploc.VaVal s) (Some (p, Ploc.VaVal None))</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ?$_:s$: ($p$) >></tt><br/>
    <tt style="color:red">MLast.PaOlb loc s (Some (p, Ploc.VaVal None))</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ?$s$: ($p$ = $e$) >></tt><br/>
    <tt style="color:red">MLast.PaOlb loc (Ploc.VaVal s) (Some (p, Ploc.VaVal (Some e)))</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ?$_:s$: ($p$ = $e$) >></tt><br/>
    <tt style="color:red">MLast.PaOlb loc s (Some (p, Ploc.VaVal (Some e)))</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- or</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $p1$ | $p2$ >></tt><br/>
    <tt style="color:red">MLast.PaOrp loc p1 p2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- range</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $p1$ .. $p2$ >></tt><br/>
    <tt style="color:red">MLast.PaRng loc p1 p2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- record</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; { $list:lpp$ } >></tt><br/>
    <tt style="color:red">MLast.PaRec loc (Ploc.VaVal lpp)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; { $_list:lpp$ } >></tt><br/>
    <tt style="color:red">MLast.PaRec loc lpp</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- string</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $str:s$ >></tt><br/>
    <tt style="color:red">MLast.PaStr loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_str:s$ >></tt><br/>
    <tt style="color:red">MLast.PaStr loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- t-uple</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; ($list:lp$) >></tt><br/>
    <tt style="color:red">MLast.PaTup loc (Ploc.VaVal lp)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ($_list:lp$) >></tt><br/>
    <tt style="color:red">MLast.PaTup loc lp</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- type constraint</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; ($p$ : $t$) >></tt><br/>
    <tt style="color:red">MLast.PaTyc loc p t</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- type pattern</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; # $list:ls$ >></tt><br/>
    <tt style="color:red">MLast.PaTyp loc (Ploc.VaVal ls)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; # $_list:ls$ >></tt><br/>
    <tt style="color:red">MLast.PaTyp loc ls</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- uppercase identifier</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; $uid:s$ >></tt><br/>
    <tt style="color:red">MLast.PaUid loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; $_uid:s$ >></tt><br/>
    <tt style="color:red">MLast.PaUid loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- variant</dt>
  <dd>
    <tt style="color:blue">&lt;:patt&lt; ` $s$ >></tt><br/>
    <tt style="color:red">MLast.PaVrn loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:patt&lt; ` $_:s$ >></tt><br/>
    <tt style="color:red">MLast.PaVrn loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- extra node <a href="#patt_2">(2)</a></dt>
  <dd>
    <tt style="color:blue">... no representation ...</tt><br/>
    <tt style="color:red">MLast.PaXtr loc s op</tt>
  </dd>
</dl>

<div id="patt_1" style="margin: 5mm 0 0 1cm">(1)
  Node used to specify an antiquotation area, like for the
  equivalent node in expressions. See above.
</div>

<div id="patt_2" style="margin: 5mm 0 0 1cm">(2)
  Extra node internally used by the quotation kit "<tt>q_ast.cmo</tt>"
    to build antiquotations of patterns.
</div>

<h3>ctyp</h3>

<p>Type expressions of the language.</p>

<dl class="nodelist">
  <dt>- access</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; $t1$ . $t2$ >></tt><br/>
    <tt style="color:red">MLast.TyAcc loc t1 t2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- alias</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; $t1$ as $t2$ >></tt><br/>
    <tt style="color:red">MLast.TyAli loc t1 t2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- any</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; _ >></tt><br/>
    <tt style="color:red">MLast.TyAny loc</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- application</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; $t1$ $t2$ >></tt><br/>
    <tt style="color:red">MLast.TyApp loc t1 t2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- arrow</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; $t1$ -> $t2$ >></tt><br/>
    <tt style="color:red">MLast.TyArr loc t1 t2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- class</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; # $list:ls$ >></tt><br/>
    <tt style="color:red">MLast.TyCls loc (Ploc.VaVal ls)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; # $_list:ls$ >></tt><br/>
    <tt style="color:red">MLast.TyCls loc ls</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- label</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; ~$s$: $t$ >></tt><br/>
    <tt style="color:red">MLast.TyLab loc (Ploc.VaVal s) t</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; ~$_:s$: $t$ >></tt><br/>
    <tt style="color:red">MLast.TyLab loc s t</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- lowercase identifier</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; $lid:s$ >></tt><br/>
    <tt style="color:red">MLast.TyLid loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; $_lid:s$ >></tt><br/>
    <tt style="color:red">MLast.TyLid loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- manifest</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; $t1$ == $t2$ >></tt><br/>
    <tt style="color:red">MLast.TyMan loc t1 t2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- object</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; &lt; $list:lst$ > >></tt><br/>
    <tt style="color:red">MLast.TyObj loc (Ploc.VaVal lst) (Ploc.VaVal False)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; &lt; $_list:lst$ > >></tt><br/>
    <tt style="color:red">MLast.TyObj loc lst (Ploc.VaVal False)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; &lt; $list:lst$ .. > >></tt><br/>
    <tt style="color:red">MLast.TyObj loc (Ploc.VaVal lst) (Ploc.VaVal True)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; &lt; $_list:lst$ .. > >></tt><br/>
    <tt style="color:red">MLast.TyObj loc lst (Ploc.VaVal True)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; &lt; $list:lst$ $flag:b$ > >></tt><br/>
    <tt style="color:red">MLast.TyObj loc (Ploc.VaVal lst) (Ploc.VaVal b)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; &lt; $_list:lst$ $_flag:b$ > >></tt><br/>
    <tt style="color:red">MLast.TyObj loc lst b</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- option label</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; ?$s$: $t$ >></tt><br/>
    <tt style="color:red">MLast.TyOlb loc (Ploc.VaVal s) t</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; ?$_:s$: $t$ >></tt><br/>
    <tt style="color:red">MLast.TyOlb loc s t</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- polymorph</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; ! $list:ls$ . $t$ >></tt><br/>
    <tt style="color:red">MLast.TyPol loc (Ploc.VaVal ls) t</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; ! $_list:ls$ . $t$ >></tt><br/>
    <tt style="color:red">MLast.TyPol loc ls t</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- variable</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; ' $s$ >></tt><br/>
    <tt style="color:red">MLast.TyQuo loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; ' $_:s$ >></tt><br/>
    <tt style="color:red">MLast.TyQuo loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- record</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; { $list:llsbt$ } >></tt><br/>
    <tt style="color:red">MLast.TyRec loc (Ploc.VaVal llsbt)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; { $_list:llsbt$ } >></tt><br/>
    <tt style="color:red">MLast.TyRec loc llsbt</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- sum</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; [ $list:llslt$ ] >></tt><br/>
    <tt style="color:red">MLast.TySum loc (Ploc.VaVal llslt)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; [ $_list:llslt$ ] >></tt><br/>
    <tt style="color:red">MLast.TySum loc llslt</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- t-uple</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; ( $list:lt$ ) >></tt><br/>
    <tt style="color:red">MLast.TyTup loc (Ploc.VaVal lt)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; ( $_list:lt$ ) >></tt><br/>
    <tt style="color:red">MLast.TyTup loc lt</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- uppercase identifier</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; $uid:s$ >></tt><br/>
    <tt style="color:red">MLast.TyUid loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; $_uid:s$ >></tt><br/>
    <tt style="color:red">MLast.TyUid loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- variant</dt>
  <dd>
    <tt style="color:blue">&lt;:ctyp&lt; [ = $list:lpv$ ] >></tt><br/>
    <tt style="color:red">MLast.TyVrn loc (Ploc.VaVal lpv) None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; [ = $_list:lpv$ ] >></tt><br/>
    <tt style="color:red">MLast.TyVrn loc lpv None</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; [ > $list:lpv$ ] >></tt><br/>
    <tt style="color:red">MLast.TyVrn loc (Ploc.VaVal lpv) (Some None)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; [ > $_list:lpv$ ] >></tt><br/>
    <tt style="color:red">MLast.TyVrn loc lpv (Some None)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; [ &lt; $list:lpv$ ] >></tt><br/>
    <tt style="color:red">MLast.TyVrn loc (Ploc.VaVal lpv) (Some(Some (Ploc.VaVal [])))</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; [ &lt; $_list:lpv$ ] >></tt><br/>
    <tt style="color:red">MLast.TyVrn loc lpv (Some (Some (Ploc.VaVal [])))</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; [ &lt; $list:lpv$ > $list:ls$ ] >></tt><br/>
    <tt style="color:red">MLast.TyVrn loc (Ploc.VaVal lpv) (Some (Some (Ploc.VaVal ls)))</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:ctyp&lt; [ &lt; $_list:lpv$ > $_list:ls$ ] >></tt><br/>
    <tt style="color:red">MLast.TyVrn loc lpv (Some (Some ls))</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- extra node <a href="#ctyp_1">(1)</a></dt>
  <dd>
    <tt style="color:blue">... no representation ...</tt><br/>
    <tt style="color:red">MLast.TyXtr loc s ot</tt>
  </dd>
</dl>

<div id="ctyp_1" style="margin: 5mm 0 0 1cm">(1)
  Extra node internally used by the quotation kit "<tt>q_ast.cmo</tt>"
    to build antiquotations of types.
</div>

<h3>modules...</h3>

<h4>str_item</h4>

<p>Structure items, i.e. phrases in a ".ml" file or "struct"s
  elements.</p>

<dl class="nodelist">
  <dt>- class declaration</dt>
  <dd>
    <tt style="color:blue">&lt;:str_item&lt; class $list:lcd$ >></tt><br/>
    <tt style="color:red">MLast.StCls loc (Ploc.VaVal lcd)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:str_item&lt; class $_list:lcd$ >></tt><br/>
    <tt style="color:red">MLast.StCls loc lcd</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- class type declaration</dt>
  <dd>
    <tt style="color:blue">&lt;:str_item&lt; class type $list:lctd$ >></tt><br/>
    <tt style="color:red">MLast.StClt loc (Ploc.VaVal lctd)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:str_item&lt; class type $_list:lctd$ >></tt><br/>
    <tt style="color:red">MLast.StClt loc lctd</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- declare</dt>
  <dd>
    <tt style="color:blue">&lt;:str_item&lt; declare $list:lstri$ end >></tt><br/>
    <tt style="color:red">MLast.StDcl loc (Ploc.VaVal lstri)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:str_item&lt; declare $_list:lstri$ end >></tt><br/>
    <tt style="color:red">MLast.StDcl loc lstri</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- directive</dt>
  <dd>
    <tt style="color:blue">&lt;:str_item&lt; # $s$ >></tt><br/>
    <tt style="color:red">MLast.StDir loc (Ploc.VaVal s) (Ploc.VaVal None)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:str_item&lt; # $_:s$ >></tt><br/>
    <tt style="color:red">MLast.StDir loc s (Ploc.VaVal None)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:str_item&lt; # $s$ $e$ >></tt><br/>
    <tt style="color:red">MLast.StDir loc (Ploc.VaVal s) (Ploc.VaVal (Some e))</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:str_item&lt; # $_:s$ $e$ >></tt><br/>
    <tt style="color:red">MLast.StDir loc s (Ploc.VaVal (Some e))</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:str_item&lt; # $s$ $opt:oe$ >></tt><br/>
    <tt style="color:red">MLast.StDir loc (Ploc.VaVal s) (Ploc.VaVal oe)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:str_item&lt; # $_:s$ $_opt:oe$ >></tt><br/>
    <tt style="color:red">MLast.StDir loc s oe</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- exception</dt>
  <dd>
    <tt style="color:blue">&lt;:str_item&lt; exception $s$ of $list:lt$ >></tt><br/>
    <tt style="color:red">MLast.StExc loc (Ploc.VaVal s) (Ploc.VaVal lt) (Ploc.VaVal [])</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:str_item&lt; exception $_:s$ of $_list:lt$ >></tt><br/>
    <tt style="color:red">MLast.StExc loc s lt (Ploc.VaVal [])</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:str_item&lt; exception $s$ of $list:lt$ = $list:ls$ >></tt><br/>
    <tt style="color:red">MLast.StExc loc (Ploc.VaVal s) (Ploc.VaVal lt) (Ploc.VaVal ls)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:str_item&lt; exception $_:s$ of $_list:lt$ = $_list:ls$ >></tt><br/>
    <tt style="color:red">MLast.StExc loc s lt ls</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- expression</dt>
  <dd>
    <tt style="color:blue">&lt;:str_item&lt; $exp:e$ >></tt><br/>
    <tt style="color:red">MLast.StExp loc e</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- external</dt>
  <dd>
    <tt style="color:blue">&lt;:str_item&lt; external $s$ : $t$ = $list:ls$ >></tt><br/>
    <tt style="color:red">MLast.StExt loc (Ploc.VaVal s) t (Ploc.VaVal ls)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:str_item&lt; external $_:s$ : $t$ = $_list:ls$ >></tt><br/>
    <tt style="color:red">MLast.StExt loc s t ls</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- include</dt>
  <dd>
    <tt style="color:blue">&lt;:str_item&lt; include $me$ >></tt><br/>
    <tt style="color:red">MLast.StInc loc me</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- module</dt>
  <dd>
    <tt style="color:blue">&lt;:str_item&lt; module $flag:b$ $list:lsme$ >></tt><br/>
    <tt style="color:red">MLast.StMod loc (Ploc.VaVal b) (Ploc.VaVal lsme)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:str_item&lt; module $_flag:b$ $_list:lsme$ >></tt><br/>
    <tt style="color:red">MLast.StMod loc b lsme</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- module type</dt>
  <dd>
    <tt style="color:blue">&lt;:str_item&lt; module type $s$ = $mt$ >></tt><br/>
    <tt style="color:red">MLast.StMty loc (Ploc.VaVal s) mt</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:str_item&lt; module type $_:s$ = $mt$ >></tt><br/>
    <tt style="color:red">MLast.StMty loc s mt</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- open</dt>
  <dd>
    <tt style="color:blue">&lt;:str_item&lt; open $list:ls$ >></tt><br/>
    <tt style="color:red">MLast.StOpn loc (Ploc.VaVal ls)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:str_item&lt; open $_list:ls$ >></tt><br/>
    <tt style="color:red">MLast.StOpn loc ls</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- type declaration</dt>
  <dd>
    <tt style="color:blue">&lt;:str_item&lt; type $list:ltd$ >></tt><br/>
    <tt style="color:red">MLast.StTyp loc (Ploc.VaVal ltd)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:str_item&lt; type $_list:ltd$ >></tt><br/>
    <tt style="color:red">MLast.StTyp loc ltd</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- use <a href="#str_item_1">(1)</a></dt>
  <dd>
    <tt style="color:blue">&lt;:str_item&lt; ...internal use... >></tt><br/>
    <tt style="color:red">MLast.StUse loc s lstrib</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- value</dt>
  <dd>
    <tt style="color:blue">&lt;:str_item&lt; value $flag:b$ $list:lpe$ >></tt><br/>
    <tt style="color:red">MLast.StVal loc (Ploc.VaVal b) (Ploc.VaVal lpe)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:str_item&lt; value $_flag:b$ $_list:lpe$ >></tt><br/>
    <tt style="color:red">MLast.StVal loc b lpe</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- extra node <a href="#str_item_2">(2)</a></dt>
  <dd>
    <tt style="color:blue">... no representation ...</tt><br/>
    <tt style="color:red">MLast.StXtr loc s ot</tt>
  </dd>
</dl>

<div id="str_item_1" style="margin: 5mm 0 0 1cm">(1)
  <p>Node internally used to specify a different file name applying to
    the whole subtree. This is generated by the directive "use" and
    used when converting to the OCaml syntax tree which needs the file
    name in its location type.</p>
</div>

<div id="str_item_2" style="margin: 5mm 0 0 1cm">(2)
  <p>Extra node internally used by the quotation kit
    "<tt>q_ast.cmo</tt>" to build antiquotations of structure
    items.</p>
</div>

<h4>sig_item</h4>

<p>Signature items, i.e. phrases in a ".mli" file or "sig"s
  elements.</p>

<dl class="nodelist">
  <dt>- class</dt>
  <dd>
    <tt style="color:blue">&lt;:sig_item&lt; class $list:lcd$ >></tt><br/>
    <tt style="color:red">MLast.SgCls loc (Ploc.VaVal lcd)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:sig_item&lt; class $_list:lcd$ >></tt><br/>
    <tt style="color:red">MLast.SgCls loc lcd</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- class type</dt>
  <dd>
    <tt style="color:blue">&lt;:sig_item&lt; class type $list:lct$ >></tt><br/>
    <tt style="color:red">MLast.SgClt loc (Ploc.VaVal lct)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:sig_item&lt; class type $_list:lct$ >></tt><br/>
    <tt style="color:red">MLast.SgClt loc lct</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- declare</dt>
  <dd>
    <tt style="color:blue">&lt;:sig_item&lt; declare $list:lsigi$ end >></tt><br/>
    <tt style="color:red">MLast.SgDcl loc (Ploc.VaVal lsigi)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:sig_item&lt; declare $_list:lsigi$ end >></tt><br/>
    <tt style="color:red">MLast.SgDcl loc lsigi</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- directive</dt>
  <dd>
    <tt style="color:blue">&lt;:sig_item&lt; # $s$ >></tt><br/>
    <tt style="color:red">MLast.SgDir loc (Ploc.VaVal s) (Ploc.VaVal None)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:sig_item&lt; # $_:s$ >></tt><br/>
    <tt style="color:red">MLast.SgDir loc s (Ploc.VaVal None)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:sig_item&lt; # $s$ $e$ >></tt><br/>
    <tt style="color:red">MLast.SgDir loc (Ploc.VaVal s) (Ploc.VaVal (Some e))</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:sig_item&lt; # $_:s$ $e$ >></tt><br/>
    <tt style="color:red">MLast.SgDir loc s (Ploc.VaVal (Some e))</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:sig_item&lt; # $s$ $opt:oe$ >></tt><br/>
    <tt style="color:red">MLast.SgDir loc (Ploc.VaVal s) (Ploc.VaVal oe)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:sig_item&lt; # $_:s$ $_opt:oe$ >></tt><br/>
    <tt style="color:red">MLast.SgDir loc s oe</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- exception</dt>
  <dd>
    <tt style="color:blue">&lt;:sig_item&lt; exception $s$ >></tt><br/>
    <tt style="color:red">MLast.SgExc loc (Ploc.VaVal s) (Ploc.VaVal [])</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:sig_item&lt; exception $_:s$ >></tt><br/>
    <tt style="color:red">MLast.SgExc loc s (Ploc.VaVal [])</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:sig_item&lt; exception $s$ of $list:lt$ >></tt><br/>
    <tt style="color:red">MLast.SgExc loc (Ploc.VaVal s) (Ploc.VaVal lt)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:sig_item&lt; exception $_:s$ of $_list:lt$ >></tt><br/>
    <tt style="color:red">MLast.SgExc loc s lt</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- external</dt>
  <dd>
    <tt style="color:blue">&lt;:sig_item&lt; external $s$ : $t$ = $list:ls$ >></tt><br/>
    <tt style="color:red">MLast.SgExt loc (Ploc.VaVal s) t (Ploc.VaVal ls)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:sig_item&lt; external $_:s$ : $t$ = $_list:ls$ >></tt><br/>
    <tt style="color:red">MLast.SgExt loc s t ls</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- include</dt>
  <dd>
    <tt style="color:blue">&lt;:sig_item&lt; include $me$ >></tt><br/>
    <tt style="color:red">MLast.SgInc loc me</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- module</dt>
  <dd>
    <tt style="color:blue">&lt;:sig_item&lt; module $flag:b$ $list:lsmt$ >></tt><br/>
    <tt style="color:red">MLast.SgMod loc (Ploc.VaVal b) (Ploc.VaVal lsmt)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:sig_item&lt; module $_flag:b$ $_list:lsmt$ >></tt><br/>
    <tt style="color:red">MLast.SgMod loc b lsmt</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- module type</dt>
  <dd>
    <tt style="color:blue">&lt;:sig_item&lt; module type $s$ = $mt$ >></tt><br/>
    <tt style="color:red">MLast.SgMty loc (Ploc.VaVal s) mt</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:sig_item&lt; module type $_:s$ = $mt$ >></tt><br/>
    <tt style="color:red">MLast.SgMty loc s mt</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- open</dt>
  <dd>
    <tt style="color:blue">&lt;:sig_item&lt; open $list:ls$ >></tt><br/>
    <tt style="color:red">MLast.SgOpn loc (Ploc.VaVal ls)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:sig_item&lt; open $_list:ls$ >></tt><br/>
    <tt style="color:red">MLast.SgOpn loc ls</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- type declaration</dt>
  <dd>
    <tt style="color:blue">&lt;:sig_item&lt; type $list:ltd$ >></tt><br/>
    <tt style="color:red">MLast.SgTyp loc (Ploc.VaVal ltd)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:sig_item&lt; type $_list:ltd$ >></tt><br/>
    <tt style="color:red">MLast.SgTyp loc ltd</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- use <a href="#sig_item_1">(1)</a></dt>
  <dd>
    <tt style="color:blue">&lt;:sig_item&lt; ...internal use... >></tt><br/>
    <tt style="color:red">MLast.SgUse loc s lstrib</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- value</dt>
  <dd>
    <tt style="color:blue">&lt;:sig_item&lt; value $s$ : $t$ >></tt><br/>
    <tt style="color:red">MLast.SgVal loc (Ploc.VaVal s) t</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:sig_item&lt; value $_:s$ : $t$ >></tt><br/>
    <tt style="color:red">MLast.SgVal loc s t</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- extra node <a href="#sig_item_2">(2)</a></dt>
  <dd>
    <tt style="color:blue">... no representation ...</tt><br/>
    <tt style="color:red">MLast.SgXtr loc s ot</tt>
  </dd>
</dl>

<div id="sig_item_1" style="margin: 5mm 0 0 1cm">(1)
  Same remark as for "<tt>str_item</tt>" above.
</div>

<div id="sig_item_2" style="margin: 5mm 0 0 1cm">(2)
  Extra node internally used by the quotation kit "<tt>q_ast.cmo</tt>"
    to build antiquotations of signature items.
</div>

<h4>module_expr</h4>

<dl class="nodelist">
  <dt> - access</dt>
  <dd>
    <tt style="color:blue">&lt;:module_expr&lt; $me1$ . $me2$ >></tt><br/>
    <tt style="color:red">MLast.MeAcc loc me1 me2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt> - application</dt>
  <dd>
    <tt style="color:blue">&lt;:module_expr&lt; $me1$ $me2$ >></tt><br/>
    <tt style="color:red">MLast.MeApp loc me1 me2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt> - functor</dt>
  <dd>
    <tt style="color:blue">&lt;:module_expr&lt; functor ($s$ : $mt$) ->  $me$ >></tt><br/>
    <tt style="color:red">MLast.MeFun loc (Ploc.VaVal s) mt me</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:module_expr&lt; functor ($_:s$ : $mt$) ->  $me$ >></tt><br/>
    <tt style="color:red">MLast.MeFun loc s mt me</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt> - struct</dt>
  <dd>
    <tt style="color:blue">&lt;:module_expr&lt; struct $list:lstri$ end >></tt><br/>
    <tt style="color:red">MLast.MeStr loc (Ploc.VaVal lstri)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:module_expr&lt; struct $_list:lstri$ end >></tt><br/>
    <tt style="color:red">MLast.MeStr loc lstri</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt> - module type constraint</dt>
  <dd>
    <tt style="color:blue">&lt;:module_expr&lt; ($me$ : $mt$) >></tt><br/>
    <tt style="color:red">MLast.MeTyc loc me mt</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt> - uppercase identifier</dt>
  <dd>
    <tt style="color:blue">&lt;:module_expr&lt; $uid:s$ >></tt><br/>
    <tt style="color:red">MLast.MeUid loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:module_expr&lt; $_uid:s$ >></tt><br/>
    <tt style="color:red">MLast.MeUid loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- extra node <a href="#module_expr_1">(1)</a></dt>
  <dd>
    <tt style="color:blue">... no representation ...</tt><br/>
    <tt style="color:red">MLast.MeXtr loc s ot</tt>
  </dd>
</dl>

<div id="module_expr_1" style="margin: 5mm 0 0 1cm">(1)
  Extra node internally used by the quotation kit "<tt>q_ast.cmo</tt>"
    to build antiquotations of module expressions.
</div>

<h4>module_type</h4>

<dl class="nodelist">
  <dt>- access</dt>
  <dd>
    <tt style="color:blue">&lt;:module_type&lt; $mt1$ . $mt2$ >></tt><br/>
    <tt style="color:red">MLast.MtAcc loc mt1 mt2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- application</dt>
  <dd>
    <tt style="color:blue">&lt;:module_type&lt; $mt1$ $mt2$ >></tt><br/>
    <tt style="color:red">MLast.MtApp loc mt1 mt2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- functor</dt>
  <dd>
    <tt style="color:blue">&lt;:module_type&lt; functor ($s$ : $mt1$) -> $mt2$ >></tt><br/>
    <tt style="color:red">MLast.MtFun loc (Ploc.VaVal s) mt1 mt2</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:module_type&lt; functor ($_:s$ : $mt1$) -> $mt2$ >></tt><br/>
    <tt style="color:red">MLast.MtFun loc s mt1 mt2</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- lowercase identifier</dt>
  <dd>
    <tt style="color:blue">&lt;:module_type&lt; $lid:s$ >></tt><br/>
    <tt style="color:red">MLast.MtLid loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:module_type&lt; $_lid:s$ >></tt><br/>
    <tt style="color:red">MLast.MtLid loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- abstract</dt>
  <dd>
    <tt style="color:blue">&lt;:module_type&lt; ' $s$ >></tt><br/>
    <tt style="color:red">MLast.MtQuo loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:module_type&lt; ' $_:s$ >></tt><br/>
    <tt style="color:red">MLast.MtQuo loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- signature</dt>
  <dd>
    <tt style="color:blue">&lt;:module_type&lt; sig $list:lsigi$ end >></tt><br/>
    <tt style="color:red">MLast.MtSig loc (Ploc.VaVal lsigi)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:module_type&lt; sig $_list:lsigi$ end >></tt><br/>
    <tt style="color:red">MLast.MtSig loc lsigi</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- uppercase identifier</dt>
  <dd>
    <tt style="color:blue">&lt;:module_type&lt; $uid:s$ >></tt><br/>
    <tt style="color:red">MLast.MtUid loc (Ploc.VaVal s)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:module_type&lt; $_uid:s$ >></tt><br/>
    <tt style="color:red">MLast.MtUid loc s</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- with construction</dt>
  <dd>
    <tt style="color:blue">&lt;:module_type&lt; $mt$ with $list:lwc$ >></tt><br/>
    <tt style="color:red">MLast.MtWit loc mt (Ploc.VaVal lwc)</tt><br/>
    <br/>
    <tt style="color:blue">&lt;:module_type&lt; $mt$ with $_list:lwc$ >></tt><br/>
    <tt style="color:red">MLast.MtWit loc mt lwc</tt>
  </dd>
</dl>
<dl class="nodelist">
  <dt>- extra node <a href="#module_type_1">(1)</a></dt>
  <dd>
    <tt style="color:blue">... no representation ...</tt><br/>
    <tt style="color:red">MLast.MtXtr loc s ot</tt>
  </dd>
</dl>

<div id="module_type_1" style="margin: 5mm 0 0 1cm">(1)
  Extra node internally used by the quotation kit "<tt>q_ast.cmo</tt>"
    to build antiquotations of module types.
</div>

<h3>classes...</h3>

<h4>class_expr</h4>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:class_expr&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>CeApp loc ce e</tt></td>
    <td align="center"><tt>$ce$ $e$</tt></td>
    <td>application</td>
  </tr>
  <tr>
    <td><tt>CeCon loc ls lt</tt></td>
    <td align="center"><tt>$list:ls$ [ $list:lt$ ]</tt></td>
    <td>constructor</td>
  </tr>
  <tr>
    <td><tt>CeFun loc p ce</tt></td>
    <td align="center"><tt>fun $p$ -> $ce$</tt></td>
    <td>function</td>
  </tr>
  <tr>
    <td><tt>CeLet loc b lpe ce</tt></td>
    <td align="center"><tt>let $flag:b$ $list:lpe$ in $ce$</tt></td>
    <td>let binding</td>
  </tr>
  <tr>
    <td><tt>CeStr loc po lcstri</tt></td>
    <td align="center"><tt>object $opt:op$ $list:lcstri$ end</tt></td>
    <td>object</td>
  </tr>
  <tr>
    <td><tt>CeTyc loc ce ct</tt></td>
    <td align="center"><tt>($ce$ : $ct$)</tt></td>
    <td>class type constraint</td>
  </tr>
</table>  

<h4>class_type</h4>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:class_type&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>CtCon loc ls lt</tt></td>
    <td align="center"><tt>$list:ls$ [ $list:lt$ ] </tt></td>
    <td>constructor</td>
  </tr>
  <tr>
    <td><tt>CtFun loc t ct</tt></td>
    <td align="center"><tt>[ $t$ ] -> $ct$</tt></td>
    <td>arrow</td>
  </tr>
  <tr>
    <td><tt>CtSig loc pt None lcsigi_item</tt></td>
    <td align="center"><tt>object $list:lcsigi$ end</tt></td>
    <td>object</td>
  </tr>
  <tr>
    <td><tt>CtSig loc pt (Some t) lcsigi_item</tt></td>
    <td align="center"><tt>object ($t$) $list:lcsigi$ end</tt></td>
    <td>object</td>
  </tr>
  <tr>
    <td><tt>CtSig loc pt ot lcsigi_item</tt></td>
    <td align="center"><tt>object $opt:ot$ $list:lcsigi$ end</tt></td>
    <td>object (general)</td>
  </tr>
</table>

<h4>class_str_item</h4>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:class_str_item&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>CrCtr loc t1 t2</tt></td>
    <td align="center"><tt>type $t1$ = $t2$</tt></td>
    <td>type constraint</td>
  </tr>
  <tr>
    <td><tt>CrDcl loc lcstri</tt></td>
    <td align="center"><tt>declare $list:lcstri$ end </tt></td>
    <td>declaration list</td>
  </tr>
  <tr>
    <td><tt>CrInh loc ce None</tt></td>
    <td align="center"><tt>inherit $ce$</tt></td>
    <td>inheritance</td>
  </tr>
  <tr>
    <td><tt>CrInh loc ce (Some s)</tt></td>
    <td align="center"><tt>inherit $ce$ as $s$</tt></td>
    <td>inheritance</td>
  </tr>
  <tr>
    <td><tt>CrInh loc ce os</tt></td>
    <td align="center"><tt>inherit $ce$ $opt:s$</tt></td>
    <td>inheritance (general)</td>
  </tr>
  <tr>
    <td><tt>CrIni loc e</tt></td>
    <td align="center"><tt>initializer $e$</tt></td>
    <td>initialization</td>
  </tr>
  <tr>
    <td><tt>CrMth loc s False e None</tt></td>
    <td align="center"><tt>method $s$ = $e$</tt></td>
    <td>method</td>
  </tr>
  <tr>
    <td><tt>CrMth loc s False e (Some t)</tt></td>
    <td align="center"><tt>method $s$ : $t$ = $e$</tt></td>
    <td>method</td>
  </tr>
  <tr>
    <td><tt>CrMth loc s True e None</tt></td>
    <td align="center"><tt>method private $s$ = $e$</tt></td>
    <td>method</td>
  </tr>
  <tr>
    <td><tt>CrMth loc s True e (Some t)</tt></td>
    <td align="center"><tt>method private $s$ : $t$ = $e$</tt></td>
    <td>method</td>
  </tr>
  <tr>
    <td><tt>CrMth loc s b e ot</tt></td>
    <td align="center"><tt>method $flag:b$ $s$ $opt:ot$ = $e$</tt></td>
    <td>method (general)</td>
  </tr>
  <tr>
    <td><tt>CrVal loc s False e</tt></td>
    <td align="center"><tt>value $s$ = $e$</tt></td>
    <td>value</td>
  </tr>
  <tr>
    <td><tt>CrVal loc s True e</tt></td>
    <td align="center"><tt>value mutable $s$ = $e$</tt></td>
    <td>value</td>
  </tr>
  <tr>
    <td><tt>CrVal loc s b e</tt></td>
    <td align="center"><tt>value $flag:b$ $s$ = $e$</tt></td>
    <td>value (general)</td>
  </tr>
  <tr>
    <td><tt>CrVir loc s False t</tt></td>
    <td align="center"><tt>method virtual $s$ : $t$</tt></td>
    <td>virtual method</td>
  </tr>
  <tr>
    <td><tt>CrVir loc s True t</tt></td>
    <td align="center"><tt>method virtual private $s$ : $t$</tt></td>
    <td>virtual method</td>
  </tr>
  <tr>
    <td><tt>CrVir loc s b t</tt></td>
    <td align="center"><tt>method virtual $flag:b$ $s$ : $t$</tt></td>
    <td>virtual method (general)</td>
  </tr>
</table>

<h4>class_sig_item</h4>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:class_sig_item&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>CgCtr loc t1 t2</tt></td>
    <td align="center"><tt>type $t1$ = $t2$</tt></td>
    <td>type constraint</td>
  </tr>
  <tr>
    <td><tt>CgDcl loc lcsigi</tt></td>
    <td align="center"><tt>declare $list:lcsigi$ end</tt></td>
    <td>declare</td>
  </tr>
  <tr>
    <td><tt>CgInh loc ct</tt></td>
    <td align="center"><tt>inherit $ct$</tt></td>
    <td>inheritance </td>
  </tr>
  <tr>
    <td><tt>CgMth loc s False t</tt></td>
    <td align="center"><tt>method $s$ : $t$</tt></td>
    <td>method</td>
  </tr>
  <tr>
    <td><tt>CgMth loc s True t</tt></td>
    <td align="center"><tt>method private $s$ : $t$</tt></td>
    <td>method</td>
  </tr>
  <tr>
    <td><tt>CgMth loc s b t</tt></td>
    <td align="center"><tt>method $flag:b$ $s$ : $t$</tt></td>
    <td>method (general)</td>
  </tr>
  <tr>
    <td><tt>CgVal loc s False t</tt></td>
    <td align="center"><tt>value $s$ : $t$</tt></td>
    <td>value</td>
  </tr>
  <tr>
    <td><tt>CgVal loc s True t</tt></td>
    <td align="center"><tt>value mutable $s$ : $t$</tt></td>
    <td>value</td>
  </tr>
  <tr>
    <td><tt>CgVal loc s b t</tt></td>
    <td align="center"><tt>value $flag:b$ $s$ : $t$</tt></td>
    <td>value (general)</td>
  </tr>
  <tr>
    <td><tt>CgVir loc s False t</tt></td>
    <td align="center"><tt>method virtual $s$ : $t$</tt></td>
    <td>method virtual</td>
  </tr>
  <tr>
    <td><tt>CgVir loc s True t</tt></td>
    <td align="center"><tt>method virtual private $s$ : $t$</tt></td>
    <td>method virtual</td>
  </tr>
  <tr>
    <td><tt>CgVir loc s b t</tt></td>
    <td align="center"><tt>method virtual $flag:b$ $s$ : $t$</tt></td>
    <td>method virtual (general)</td>
  </tr>
</table>

<h3>other</h3>

<h4>with_constr</h4>

<p>"With" possibly following a module type.</p>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:with_const&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>WcTyp loc s ltv False t</tt></td>
    <td align="center"><tt>type $s$ $list:ltv$ = $t$</tt></td>
    <td>with type</td>
  </tr>
  <tr>
    <td><tt>WcTyp loc s ltv True t</tt></td>
    <td align="center"><tt>type $s$ $list:ltv$ = private $t$</tt></td>
    <td>with type</td>
  </tr>
  <tr>
    <td><tt>WcTyp loc s ltv b t</tt></td>
    <td align="center"><tt>type $s$ $list:ltv$ = $flag:b$ $t$</tt></td>
    <td>with type (general)</td>
  </tr>
  <tr>
    <td><tt>WcMod loc ls me</tt></td>
    <td align="center"><tt>module $list:ls$ = $me$</tt></td>
    <td>with module</td>
  </tr>
</table>

<h4>poly_variant</h4>

<p>Polymorphic variants.</p>

<table border="1">
  <tr>
    <th>Node</th>
    <th><tt>&lt;:poly_variant&lt; ... >></tt></th>
    <th>Comment</th>
  </tr>
  <tr>
    <td><tt>PvTag s False []</tt></td>
    <td align="center"><tt>` $i$</tt></td>
    <td>constructor</td>
  </tr>
  <tr>
    <td><tt>PvTag s True lt</tt></td>
    <td align="center"><tt>` $i$ of &amp; $list:lt$</tt></td>
    <td>constructor</td>
  </tr>
  <tr>
    <td><tt>PvTag s b lt</tt></td>
    <td align="center"><tt>` $i$ of $flag:b$ $list:lt$</tt></td>
    <td>constructor (general)</td>
  </tr>
  <tr>
    <td><tt>PvInh t</tt></td>
    <td align="center"><tt>$t$</tt></td>
    <td>type</td>
  </tr>
</table>

<p>... to be added: <tt>type_decl</tt>, <tt>type_var</tt>
  and <tt>class_infos</tt>)...</p>

<div class="trailer">
</div>

</div>

</body>
</html>
