<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
  <!-- $Id$ -->
  <!-- Copyright (c) 2007 INRIA -->
  <title>Pretty Printing</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="robots" content="none" />
  <link rel="shortcut icon" href="c4logo.png" />
  <style type="text/css"><!--
    body { counter-reset: h2cnt }
    h1 { text-align: center }
    h2:before { content: counter(h2cnt) " - "; counter-increment: h2cnt }
    h2 { border: 1px solid; text-align: center; background: #9bf }
    h2 { counter-reset: h3cnt }
    h3:before {
      content: counter(h2cnt) "." counter(h3cnt) " - ";
      counter-increment: h3cnt
    }
    p { text-align: justify; margin: 1em 1cm }
    li { margin-left: 1cm }
    pre {
      border-left: silver solid 3px; margin-bottom: 1.5em; margin-left: 2cm;
      padding-left: 1em; padding-right: 0.5em; line-height: 1.2
    }
    tt { font-weight: bold }
    .value { background: #0f0 }
  --></style>
</head>
<body>

<h1>pa_lexer.cmo: syntax for parsers of streams of characters</h1>

<p>pa_lexer.cmo is a Camlp4 syntax extension for parsers for streams
of the type 'char'. This syntax is shorter in length and more readable
than its equivalent version written with classical stream parsers.
Like classical parsers, they use recursive descendant parsing. They
are pure syntax sugar for parsers: each lexer written with this syntax
can be written with normal parsers syntax.</p>

<h2>Introduction</h2>

<p>Classical parsers in OCaml apply to streams of any type of
values. But, for the specific type "char", it has been possible to
shorten codes in several ways, in particular by using strings to group
several characters together, and by hidding the management of the
"lexing buffer", a data structure recording the matched
characters.</p>

<p>In order to motivate our work, here is a small example. Let us look
at the following parser:</p>

<pre>
     value rec ident buf =
       parser
       [ [: `('A'..'Z' | 'a'..'z' | '0'..'9' | '_' | ''' | '\128'..'\255'
            as c); buf = ident (B.add c buf) ! :] -&gt; buf
       | [: :] -&gt; buf ];
</pre>

<p> With the new syntax, it is possible to write it as:</p>

<pre>
     value rec ident = lexer [ "A..Za..z0..9_'\128..\255" ident! | ];
</pre>

<p>The two codes are strictly equivalent. To be sure of that, you can
use the camlp4 pretty printer kit "pa_r.cmo".</p>





<p>The rest of the paper is structured as follows:
section&#XA0;<A HREF="#syntax">2</A> gives the description of this new
syntax, section&#XA0;<A HREF="#semantics">3</A> details the semantics
and the directions for use. The conclusion and the future work follow,
in section&#XA0;<A HREF="#conclusion">4</A>.</p>

<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">2</A>&#XA0;&#XA0;Syntax</H2><!--SEC END --><p>
<A NAME="syntax"></A></p><p>When loading the syntax extension, the OCaml syntax is extended as
follows:</p><PRE CLASS="verbatim">            expression ::= lexer
                 lexer ::= "lexer" "[" rules "]"
                 rules ::= rules rule
                         | &lt;nothing&gt;
                  rule ::= symbols [ "-&gt;" action ]
               symbols ::= symbols symbol error
                         | &lt;nothing&gt;
                symbol ::= "_" no_record
                         | STRING no_record
                         | simple_expression
                         | "?=" "[" lookaheads "]"
                         | "[" rules "]"
             no_record ::= "/"
                         | &lt;nothing&gt;
     simple_expression ::= LIDENT
                         | CHAR
                         | "(" &lt;expression&gt; ")"
            lookaheads ::= lookaheads "|" lookahead_sequence
                         | lookahead_sequence
    lookahead_sequence ::= lookahead_symbols
                         | STRING
     lookahead_symbols ::= lookahead_symbols lookahead_symbol
                         | lookahead_symbol
      lookahead_symbol ::= CHAR
                         | "_"
                 error ::= "?" simple_expression
                         | "!"
                         | &lt;nothing&gt;
               action ::= expression
</PRE><p>The identifiers &#X201C;<CODE>STRING</CODE>&#X201D;, &#X201C;<CODE>CHAR</CODE>&#X201D; and
&#X201C;<CODE>LIDENT</CODE>&#X201D; represent the OCaml tokens corresponding to string,
character and lowercase identifier (identifier starting with a
lowercase character).</p><p>The syntax of the entry <CODE>expression</CODE> of the Camlp4 OCaml grammar
is also extended this way:</p><PRE CLASS="verbatim">            expression ::= "$" "add" STRING
                         | "$" "buf"
                         | "$" "empty"
                         | "$" "pos"
</PRE><p>Remark: in this syntax extension, the identifiers &#X201C;add&#X201D;, &#X201C;buf&#X201D;,
&#X201C;empty&#X201D; and &#X201C;pos&#X201D; are not recorded as new keywords, they do not
become reserved words. On the contrary, the identifier
&#X201C;<CODE>lexer</CODE>&#X201D;, which introduces the syntax, is a new keyword and
cannot be used as variable identifier.</p><!--TOC section Semantics-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc3">3</A>&#XA0;&#XA0;Semantics</H2><!--SEC END --><p>
<A NAME="semantics"></A></p><p>A lexer defined in the syntax above is a shortcut version of a parser
applied to the specific case of streams of characters. It could be
written with a normal parser. The proposed syntax is much shorter,
easier to use and to understand, and it silently takes care of the
lexing buffer for the programmer. The lexing buffers are data
structures, which are passed as parameters to called lexers and
returned by them.</p><p>Lexers are of the type:</p><PRE CLASS="verbatim">      B.t -&gt; Stream.t char -&gt; a
</PRE><p>where &#X201C;<CODE>a</CODE>&#X201D; is a type which depends on what the lexer
returns. If there is no semantic action (since it it optional), this
type is &#X201C;<CODE>B.t</CODE>&#X201D;.</p><p>&#X201C;<CODE>B</CODE>&#X201D; is a module which must be defined by the user. It has to
contain the lexing buffer type &#X201C;<CODE>t</CODE>&#X201D; and some variables and
functions:</p><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>empty</CODE>: the empty lexing buffer
</LI><LI CLASS="li-itemize"><CODE>add</CODE>: the way to add a character to a lexing buffer
</LI><LI CLASS="li-itemize"><CODE>get</CODE>: the way to get a string from the lexing buffer
</LI></UL><p>A possible implementation, using &#X201C;<CODE>list char</CODE>&#X201D; as lexing buffer
type, recording the characters at top of the list (therefore creating
a list in reverse order) could be:</p><PRE CLASS="verbatim">       (* converting a reversed list of char into a string *)
       value rev_implode cl =
         let s = String.create (List.length cl) in
         loop (String.length s - 1) cl where rec loop i =
           fun
           [ [c :: cl] -&gt; do { s.[i] := c; loop (i - 1) cl }
           | [] -&gt; s ]
       ;

       (* the lexing buffer module *)
       module B =
         struct
           type t = list char;
           value empty = [];
           value add c l = [c :: l];
           value get = rev_implode;
         end
       ;
</PRE><p>A lexer gets a lexing buffer as first parameter, and the stream of
characters as second one. It tries to match the stream according
to its first rule. If it fails, it applies its second rule, and so
one, up to its last rule. If the last rule fails, the lexer fails
by raising the exception &#X201C;<CODE>Stream.Failure</CODE>&#X201D;. All of this
is the usual behaviour of stream parsers.</p><p>In a rule, when a character is matched, it is inserted into the lexing
buffer, except if the &#X201C;no record&#X201D; feature is used (see further).</p><p>Rules which have no semantic action return the lexing buffer itself.</p><!--TOC subsection Symbols-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc4">3.1</A>&#XA0;&#XA0;Symbols</H3><!--SEC END --><p>The different kinds or symbols in a rule are:</p><UL CLASS="itemize"><LI CLASS="li-itemize">The token &#X201C;underscore&#X201D;, which represents any
character. Fails only if the stream is empty.</LI><LI CLASS="li-itemize">A string which represent a matching of any character in the
string. Notice that it is a choice between all the characters, not
the sequence of these characters. To indicate a sequence, you have
to use several symbols, the ones behind the others. Character ranges
can be inserted using the characters &#X201C;<CODE>..</CODE>&#X201D;. For example, to
specify a match of any letter or digit, you can write
<CODE>"A..Za..z0..9"</CODE>&#X201D;. The beginning of a comment in the OCaml
language must be written: <CODE>"(" "*"</CODE>.</LI><LI CLASS="li-itemize">An expression corresponding to a call to another lexer, which
takes the buffer as first parameter and has to return another lexing
buffer with all characters found in the stream catened to the lexing
buffer.</LI><LI CLASS="li-itemize">The sequence &#X201C;<CODE>?=</CODE>&#X201D; introducing lookahead characters.
See the section&#XA0;<A HREF="#lookahead">3.3</A>.</LI><LI CLASS="li-itemize">A rule, recursively, between brackets, inlining a lexer.</LI></UL><p>In the first two cases (underscore or string), the symbol can be
followed by the character &#X201C;slash&#X201D; specifying that the symbol found
has not to be added in the lexing buffer. By default, it is. Useful,
for example, when writing a lexer parsing strings, when the initial
double quote and final double quote have not to be part of the string
itself.</p><p>

Moreover, a symbol can be followed by an optional error indicator,
which can be:</p><UL CLASS="itemize"><LI CLASS="li-itemize">The character <CODE>?</CODE> (question mark) followed by a string
expression, telling that, if there is a syntax error at this point
(i.e. the symbol is not matched although the beginning of the rule
was), the exception <CODE>Stream.Error</CODE> is raised with that string
as parameter. Without this indicator, it is raised with the empty
string.</LI><LI CLASS="li-itemize">The character <CODE>!</CODE> (exclamation mark), which is just an
indicator to let the syntax expander optimize the code. If the
programmer is sure that the previous symbol never fails (i.e. never
raises <CODE>Stream.Failure</CODE>), in particular if this symbol
recognizes the empty rule, she can add this exclamation mark. If it
is used correctly (the compiler cannot check it), the behaviour is
identical as without the <CODE>!</CODE>, except that the code is shorter
and faster, and can sometimes be tail recursive. If the indication
is not correct, the behaviour of the lexer is undefined.</LI></UL><!--TOC subsection Specific expressions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc5">3.2</A>&#XA0;&#XA0;Specific expressions</H3><!--SEC END --><p>
<A NAME="specific"></A></p><p>When loading this syntax extension, the entry <CODE>&lt;expression&gt;</CODE>, at
level labelled &#X201C;simple&#X201D; of the OCaml language is extended with the
following rules:</p><UL CLASS="itemize"><LI CLASS="li-itemize"><CODE>$add</CODE> followed by a string, specifing that the programmer
wants to add all characters of the string in the lexing buffer. It
returns the new lexing buffer. It corresponds to an iteration of
calls to <CODE>B.add</CODE> with all characters of the string with the
current lexing buffer as initial parameter.</LI><LI CLASS="li-itemize"><CODE>$buf</CODE> which returns the lexing buffer converted into
string.</LI><LI CLASS="li-itemize"><CODE>$empty</CODE> which returns the empty lexing buffer.</LI><LI CLASS="li-itemize"><CODE>$pos</CODE> which return the current position in the stream in
number of characters (starting at zero).</LI></UL><!--TOC subsection Lookahead-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc6">3.3</A>&#XA0;&#XA0;Lookahead</H3><!--SEC END --><p>
<A NAME="lookahead"></A></p><p>Lookahead is useful in some cases, when factorization of rules is
impossible. To understand how it is useful, a first remark must
be done, about the usual behaviour of Camlp4 stream parsers.</p><p>Stream parsers (including these lexers) use a limited parsing
algorithm, in a way that when the first symbol of a rule is matched,
all the following symbols of the same rule must apply, otherwise it is
a syntax error. There is no backtrack. In most of the cases, left
factorization of rules resolve conflicting problems. For example, when
one writes a parser of tokens to recognize both the typicall grammar
rules &#X201C;if..then..else&#X201D; and the shorter &#X201C;if..then..&#X201D;, the solution
is to write a rule starting with &#X201C;if..then..&#X201D; followed with a call
to a parser recognizing &#X201C;else..&#X201D; or nothing.</p><p>Sometimes, however, this left factorization is not possible. A
lookahead of the stream to check the presence of some elements (these
element being characters, if we are using this &#X201C;lexer&#X201D; syntax) might
be necessary to decide whether or not it is a good idea to continue
the rule. This lookahead feature may unfreeze the first stream
characters but does not remove them from the stream.</p><p>Syntactically, a lookahead starts with <CODE>?=</CODE> and is followed by
one or several lookahead sequences separated by the vertical bar
<CODE>|</CODE>, the whole list being enclosed by braces.</p><p>If there are several lookaheads, they must all be of the same size
(contain the same number of characters).</p><p>If lookahead sequence is just a string, it corresponds to all characters
of this string in the order.</p><p>Examples of lookaheads:</p><PRE CLASS="verbatim">       ?= [ _ ''' | '\\' _ ]
       ?= [ "&lt;&lt;" | "&lt;:" ]
</PRE><p>The first line above matches a stream whose second character is a
quote or a stream whose first character is a backslash. The second
line matches a stream starting with the two characters <CODE>&lt;</CODE> and
<CODE>&lt;</CODE> or starting with the two characters <CODE>&lt;</CODE> and <CODE>:</CODE>.</p><!--TOC subsection Semantic actions of rules-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc7">3.4</A>&#XA0;&#XA0;Semantic actions of rules</H3><!--SEC END --><p>By default, the result of a &#X201C;lexer&#X201D; is the current lexing buffer,
which is of type &#X201C;<CODE>B.t</CODE>&#X201D;. But it is possible to return other
values, by adding &#X201C;<CODE>-&gt;</CODE>&#X201D; at end of rules followed by the
expression you want to return, like in usual pattern matching in
OCaml.</p><p>An interesting result, for example, could be the string corresponding
to the characters of the lexing buffer. This can be obtained by
returning the value &#X201C;<CODE>$buf</CODE>&#X201D; (see section&#XA0;<A HREF="#specific">3.2</A>)</p><!--TOC subsection A complete example-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc8">3.5</A>&#XA0;&#XA0;A complete example</H3><!--SEC END --><p>A complete example can be seen in the sources of Camlp4, file
&#X201C;lib/plexer.ml&#X201D;. This is the lexer of OCaml, either &#X201C;normal&#X201D; or
&#X201C;revised&#X201D; syntax.</p><!--TOC subsection Compiling-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc9">3.6</A>&#XA0;&#XA0;Compiling</H3><!--SEC END --><p>To compile a file containing lexers, just load <CODE>pa_lex.cmo</CODE> using
one of the following methods:</p><UL CLASS="itemize"><LI CLASS="li-itemize">Either by adding <CODE>pa_lex.cmo</CODE> among the camlp4 options. See
the camlp4 manual page or documentation.
</LI><LI CLASS="li-itemize">Or by adding <CODE>#load "pa_lex.cmo";</CODE> anywhere in the file,
before the usages of this &#X201C;lexer&#X201D; syntax.</LI></UL><!--TOC subsection How to display the generated code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc10">3.7</A>&#XA0;&#XA0;How to display the generated code</H3><!--SEC END --><p>You can see the generated code, for a file &#X201C;bar.ml&#X201D; containing
lexers, by typing in a command line:</p><PRE CLASS="verbatim">     camlp4r pr_r.cmo bar.ml
</PRE><p>or, possibly, if &#X201C;<CODE>pa_lex.cmo</CODE>&#X201D; is not loaded in the file &#X201C;bar.ml&#X201D;:</p><PRE CLASS="verbatim">     camlp4r pa_lex.cmo pr_r.cmo bar.ml
</PRE><!--TOC section Conclusion and future work-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc11">4</A>&#XA0;&#XA0;Conclusion and future work</H2><!--SEC END --><p>
<A NAME="conclusion"></A></p><p>We think that this new feature can encourage programmers to use the
stream parsers technology for their lexers. Their shorter syntax has
almost the same comfort and the same readability as the programs
written in &#X201C;ocamllex&#X201D;. Although these lexers are not as powerful as
&#X201C;ocamllex&#X201D; since, sometimes, explicit left factorization or
characters lookaheads must be necessary, they are more functional
(they can have extra parameters, and the lexing buffer is not a
mutable variable) and are more included in the language, since they
are pure syntactic sugar.</p><p>We plan to experiment these lexers in real OCaml programs. Perhaps
syntax might change, or other features are added. An interesting one
could be a way to allow lexers to be extended at run time, to give to
lexers the same power as the Camlp4 extensible grammars offers at
parsing level.</p><!--TOC section References-->
<H2 CLASS="section"><!--SEC ANCHOR -->References</H2><!--SEC END --><DL CLASS="thebibliography"><DT CLASS="dt-thebibliography">
<A NAME="Goscinny"><FONT COLOR=purple>[1]</FONT></A></DT><DD CLASS="dd-thebibliography">
Goscinny et&#XA0;Uderzo.
<EM>Ast&#XE9;rix et Cl&#XE9;opatre</EM>.
Dargaud, 1974.</DD></DL><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
