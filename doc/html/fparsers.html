<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
  <!-- $Id$ -->
  <!-- Copyright (c) 2007 INRIA -->
  <title>purely functional parsers of streams</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="shortcut icon" href="c4logo.png" />
  <style type="text/css"><!--
    body { counter-reset: h2cnt }
    h1 { text-align: center }
    h2:before { content: counter(h2cnt) " - "; counter-increment: h2cnt }
    h2 { border: 1px solid; text-align: center; background: #9bf }
    h2 { counter-reset: h3cnt }
    h3:before {
      content: counter(h2cnt) "." counter(h3cnt) " - ";
      counter-increment: h3cnt
    }
    p { text-align: justify; margin: 1em 1cm }
    li { margin-left: 1cm }
    pre {
      border-left: silver solid 3px; margin-bottom: 1.5em; margin-left: 1.5cm;
      padding-left: 1em; padding-right: 0.5em; line-height: 1.2
    }
    tt { font-weight: bold }
    .value { background: #0f0 }
  --></style>
</head>
<body>

<h1>Purely functional parsers of streams</h1>

<p>Purely functional parsers are an alternative
of <a href="parsers.html">parsers of streams</a> where the used stream
type is a lazy non-destructive type : these streams are lazy values,
like in classical parsers of streams, but the values are not removed
as long as the parsing advances. To make them work, the parsers of
purely functional streams return, not the simple values, but a value
of type option : "<code>Node</code>" meaning "mo match" (the equivalent
of the exception "<code>Parse.Failure</code>" of normal streams) and
"<code>Some (r, s)</code>" meaning "the result is r and the remaining
stream is s".</p>

<h2>Syntax</h2>

<p>The syntax of purely functional parsers, when loading
"pa_fstream.cmo", is the following:</p>

<pre>
          expression ::= fparser
                       | match_with_fparser
             fparser ::= "fparser" pos_opt "[" parser_cases "]"
                       | "fparser" pos_opt parser_case
  match_with_fparser ::= "match" expression with "fparser" pos_opt "[" parser_cases "]"
                       | "match" expression with "fparser" pos_opt parser_case
        parser_cases ::= parser_cases parser_case
                       | &lt;nothing&gt;
         parser_case ::= "[:" stream_pattern ":]" pos_opt "->" expression
                       | "[:" ":]" pos_opt "->" expression
      stream_pattern ::= stream_patt_comp
                       | stream_patt_comp ";" stream_pattern
    stream_patt_comp ::= "`" pattern
                       | pattern "=" expression
                       | pattern
             pos_opt ::= pattern
                       | &lt;nothing&gt;
</pre>

<p>Notice that, in difference with classical parsers, there is no
difference, in a stream pattern, between the first stream pattern
component and the other ones. In particular, there is not this syntax
"question mark" and expression optionnally ending those
components. Moreover, the "lookahead" case is not necessary, we see
further why. On the contrary, the syntaxes "pattern when" and "let..in"
inside stream patterns we see in classical parsers are just not
implemented. </p>

<h2>Streams</h2>

<p>The functional parsers are functions taking as parameters
functional streams, which are values of type "<code>Fstream.t
a</code>" for some type "<code>a</code>". It is possible to build
functional streams using the functions defined in the module
"<code>Fstream</code>":</p>

<h3>Fstream.from</h3>

<p>"<code>Fstream.from f</code>" returns a stream built from the
function "<code>f</code>". To create a new stream element, the
function "<code>f</code>" is called with the current stream count,
starting with zero. The user function "<code>f</code>" must return
either "<code>Some &lt;value&gt;</code>" for a value or
"<code>None</code>" to specify the end of the stream.

<h3>Fstream.of_list</h3>

<p>Return a stream built from the list in the same order.</p>

<h3>Fstream.of_string</h3>

<p>Return a stream of the characters of the string parameter.</p>

<h3>Fstream.of_channel</h3>

<p>Return a stream of the characters read from the input channel
parameter.</p>

<h2>Semantics of parsers</h2>

<h3>Fparser</h3>

<p>The purely functional parsers act like classical parsers, with a
recursive descent algorithm, except that:</p>

<ul>

<li>If the first stream pattern component matches the beginning of the
stream, there is no error if the following stream patterns components
do not match: the control simply passes to the next parser case with
the initial stream.</li>

<li>If the semantic actions are of type "<code>t</code>", the result
of the parser is of type "<code>option (t * Fstream.t)</code>", not
just "<code>t</code>" like in classical parsers. If a stream pattern
matches, the semantic action is evaluated, giving some result
"<code>e</code>" and the result of the parser is "<code>Some (e,
strm)</code>" where "<code>strm</code>" is the remaining stream.</li>

<li>If no parser case matches, the result of the parser is
"<code>None</code>".</li>

</ul>

<h3>Error position</h3>

<p>A difficulty, with purely functional parsers, is how to find the
position of the syntax error, when the input is wrong. Since the
system tries all parsers cases before returning "<code>None</code>",
and that the initial stream is not affected, it is not possible to
directly find where the error happened. This is a problem for parsing
using backtracking (here, it is limited backtracking, but the problem
is the same).<p>

<p>The solution is to use the function
"<code>Fstream.count_unfrozen</code>" applied to the initial
stream. Like its name says, it returns the number of unfrozen elements
of the stream, which is exactly the longuest match found. If the input
is a stream of characters, the return of this function is exactly the
position in number of characters from the beginning of the stream.
However, it is not possible to know directly which rule failed and it
is not possible, like in classical parsers, to get a clear error
message. Future versions of purely functional parsers may propose
solutions to resolve this problem.</p>

<p>Notice that, if using that method, it is not possible to reuse the
same stream to call another parser, and hope to get the right position
of the error, if another error happens, since it may test less terminals
than the first parser. Use a fresh stream in this case, if possible.</p>

<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>

<hr style="margin:0" /><div style="font-size: 80%"><em>Copyright 2007
Daniel de Rauglaudre (INRIA)</em>

</body>
</html>
