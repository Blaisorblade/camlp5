<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
  <!-- $Id$ -->
  <!-- Copyright (c) 2007 INRIA -->
  <title>Pretty Printing OCaml Programs</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="shortcut icon" href="c4logo.png" />
  <link rel="stylesheet" type="text/css" href="styles/base.css" />
</head>
<body>

<div id="menu">
  <h1>- <a href="index.html">Camlp5</a> -</h1>
  <ul>
    <li>Parsing
      <ul>
        <li><a href="parsers.html">parsers</a></li>
        <li><a href="lexers.html">lexers</a></li>
        <li><a href="fparsers.html">functional parsers</a></li>
      </ul>
    </li>
    <li>Printing
      <ul>
        <li><a href="pretty.html">library module</a></li>
        <li><a href="opretty.html">programs</a></li>
      </ul>
    </li>
    <li>Other
      <ul>
        <li><a href="ml_ast.html">syntax tree</a></li>
        <li><a href="pragma.html">pragma directive</a></li>
        <li><a href="extfun.html">extensible functions</a></li>
      </ul>
    </li>
  </ul>
</div>

<div id="content">

<h1 class="top">Camlp5 - Pretty Printing OCaml Programs</h1>

<p>Camlp5 provides extensions kits to pretty print programs in revised
syntax and normal syntax. Some other extensions kits also allow to
rebuild the parsers, or the EXTEND statements in their initial
syntax. The pretty print system is itself extensible, by adding new
rules. We present here how it works in the Camlp5 sources.</p>

<p>The pretty print system of Camlp5 uses the library modules
<a href="pretty.html">Pretty</a>, an original system to format
output) and <a href="extfun.html">Extfun</a>, another original
system of extensible functions.</p>

<p>This documentation is destinated to programmers who want to
understand how the pretty printing of ocaml programs work in camlp5,
want to adapt, modify or debug it, or want to add their own pretty
printing extensions.</p>

<h2>Introduction</h2>

<p>The files doing the pretty prints are located in Camlp5 sources
in the directory "etc". Look at them if you are interested on creating
new ones. The main ones are:</p>

<ul>

<li>"etc/pr_r.ml": pretty print in revised syntax.</li>

<li>"etc/pr_o.ml": pretty print in normal syntax.</li>

<li>"etc/pr_rp.ml": rebuilding parsers in their original revised syntax.</li>

<li>"etc/pr_op.ml": rebuilding parsers in their original normal syntax.</li>

<li>"etc/pr_extend.ml": rebuilding EXTEND in its original syntax.</li>

</ul>

<p>We present here how this system work inside these files.</p>

<h2>Principles</h2>

<h3>Using module Pretty</h3>

<p>All functions in ocaml pretty printing take a parameter named "the
printing context" (variable <code>pc</code>). It is a record holding :</p>

<ul>

<li>The current indendation : <code>pc.ind</code></li>

<li>What has to be printed before, in the same line : <code>pc.bef</code></li>

<li>What has to be printed after, in the same line : <code>pc.aft</code></li>

<li>The dangling token, useful in normal syntax to know whether
parentheses are necessary : <code>pc.dang</code></li>

</ul>

<p>A typical pretty printing function calls the
function <code>horiz_vertic</code> of the library
module <a href="pretty.html">Pretty</a>. This function takes two
functions as paramter:</p>

<ul>

<li>The way to print the data in one only line (<i>horizontal</i>
printing)</li>

<li>The way to print the data in two or more lines (<i>vertical</i>
printing)</li>

</ul>

<p>Both functions catenate the strings by using the
function <code>sprintf</code> of the library
module <code>Pretty</code> which controls whether the printed data
holds in the line or not. They generally call, recursively, other
pretty printing functions with the same behaviour.</p>

<p>Let us see an example (fictive) of printing an ocaml
application. Let us suppose we have an application expression
"<code>e1 e2</code>" to pretty print where <code>e1</code>
and <code>e2</code> are sub-expressions. If both expressions and their
application holds on one only line, we want to see:</p>

<pre>
e1 e2
</pre>

<p>On the other hand, if they do not hold on one only line, we want to
see <code>e2</code> in another line with, say, an indendation of 2
spaces:</p>

<pre>
e1
  e2
</pre>

<p>Here is a possible implementation. The function has been
named <code>expr_app</code> and can call the function <code>expr</code> to
print the sub-expressions <code>e1</code> and <code>e2</code>:</p>

<pre>
value expr_app pc e1 e2 =
  horiz_vertic
    (fun () ->
       let s1 = expr {(pc) with aft = ""} e1 in
       let s2 = expr {(pc) with bef = ""} e2 in
       sprintf "%s %s" s1 s2)
    (fun () ->
       let s1 = expr {(pc) with aft = ""} e1 in
       let s2 =
         expr
           {(pc) with
              ind = pc.ind + 2;
              bef = tab (pc.ind + 2)}
           e2
       in
       sprintf "%s\n%s" s1 s2)
;
</pre>

<p>The first function is the <i>horizontal</i> printing. It ends with a
<code>sprintf</code> separating the printing of <code>e1</code>
and <code>e2</code> by a space. The possible "before part"
(<code>pc.bef</code>) and "after part" (<code>pc.aft</code>) are
transmitted in the calls of the sub-functions.</p>

<p>The second function is the <i>vertical</i> printing. It ends with a
<code>sprintf</code> separating the printing of <code>e1</code>
and <code>e2</code> by a newline. The second line starts with an
indendation, using the "before part" (<code>pc.bef</code>) of the
second call to <code>expr</code>.</p>

<p>The pretty printing library
function <code>Pretty.horiz_vertic</code> calls the first
(<i>horizontal</i>) function, and if it fails (either
because <code>s1</code> or <code>s2</code> are too long or hold
newlines, or because the final string produced by <code>sprintf</code>
is too long), calls the second (<i>vertical</i>) function.</p>

<p>Notice that the parameter <code>pc</code> contains a
field <code>pc.bef</code> (what has to be printed before in the same
line), which in both cases is transmitted to the printing
of <code>e1</code> (since the syntax <code>{(pc) with aft = ""}</code>
is a record with <code>pc.bef</code> kept). Same for the
field <code>pc.aft</code> transmitted to the printing
of <code>e2</code>.</p>

<h3>Using module Extfun and its syntax</h3>

<p>This system is combined to the the <a href="extfun.html">extensible
functions</a> to allow the extensibility of the pretty
printing. Pretty printers of camlp5 can then be used as "kits" to be
added or not, according to the things to be pretty printed in some or
other ways. In particular, the pretty printing kit
"<code>pr_r.cmo</code>" alone does not rebuild parsers in their
original syntax. When adding "<code>pr_rp.cmo</code>", the parsers are
rebuilt: the code of "<code>pr_rp.ml</code>" is just an extension of
some parts of the pretty printing extensible functions of
"<code>pr_r.ml</code>".</p>

<p>The code above actually looks like:</p>

<pre>
value expr_app =
  extfun Extfun.empty with
  [ &lt;:expr&lt; $e1$ $e2$ &gt;&gt; ->
      fun curr next pc ->
        horiz_vertic
          (fun () ->
             let s1 = curr {(pc) with aft = ""} e1 in
             let s2 = next {(pc) with bef = ""} e2 in
             sprintf "%s %s" s1 s2)
          (fun () ->
             let s1 = curr {(pc) with aft = ""} e1 in
             let s2 =
               next
                 {(pc) with
                    ind = pc.ind + 2;
                    bef = tab (pc.ind + 2)}
                 e2
             in
             sprintf "%s\n%s" s1 s2)
  | e ->
      fun curr next pc -> next pc e ]
;
</pre>

<p>The extensible functions have a syntax tree
(here <code>&lt;:expr&lt; $e1$ $e2$ &gt;&gt;</code>) as parameter. To
be extensible, the syntax tree must be the first parameter (it is not
possible to apply extensions inside a closure). The other parameters,
in particular the printing context
<code>pc</code> are given in the semantic action.</p>

<p>The parameter <code>curr</code> and <code>next</code> are provided
by the pretty printing system for ocaml programs. They correspond to
the pretty printing of, respectively, the current level and the next
level. Since the application in ocaml is left associative, the first
sub-expression is printed at the same (current) level and the second
one is printed at the next level. We also see a call
to <code>next</code> in the last (2nd) case of the function to treat
the other cases in the next level.</p>

<h3>Dangling else, bar, semicolon</h3>

<p>In normal syntax, there are cases where it is necessary to enclose
expressions between parentheses (or
between <span class="parenthesis">begin</span>
and <span class="parenthesis">end</span>, which is equivalent in that
syntax). Three tokens may cause problems: the "<code>else</code>", the
vertical bar "<code>|</code>" and the semicolon "<code>;</code>". Here
are examples where the presence of these tokens constraints the
previous expression to be parenthesized. In these three examples,
removing
the <span class="parenthesis">begin</span>..<span class="parenthesis">end</span>
enclosers would change the meaning of the expression because the
dangling token would be included in that expression:</p>

<p>Dangling else:</p>

<pre>
if a then <span class="parenthesis">begin</span> if b then c <span class="parenthesis">end</span> <span class="dangling">else</span> d
</pre>

<p>Dangling bar:</p>

<pre>
function
  A ->
    <span class="parenthesis">begin</span> match a with
      B -> c
    | D -> e
    <span class="parenthesis">end</span>
<span class="dangling">|</span> F -> g
</pre>

<p>Dangling semicolon:</p>

<pre>
if a then b
else <span class="parenthesis">begin</span>
  let c = d in
  e
<span class="parenthesis">end</span><span class="dangling">;</span>
f
</pre>

<p>The information is transmitted by the
value <code>pc.dang</code>. In the first example above, while
displaying the "<code>then</code>" part of the outer
"<code>if</code>", the sub-expression is called with the
value <code>pc.dang</code> set to
<code>"else"</code> to inform the last sub-sub-expression that it is
going to be followed by that token. When a "<code>if</code>"
expression has to be displayed without "<code>else</code>" part,
and that its "<code>pc.dang</code>" is "else", it has to be enclosed
with spaces.</p>

<p>This problem does not exist in revised syntax. While pretty
printing in revised syntax, the parameter <code>pc.dang</code> is not
necessary and remains the empty string.</p>

<h3>By level</h3>

<p>For each level of pretty printing, there is such a function. The
example showed the pretty printing of expression at the level "apply".
There are other functions for levels "top", "add", "mul", "simple",
and so on. The global pretty printing variable for expressions is a
record, named "<code>pr_expr</code>" (in the
module <code>Pcaml.Printers</code>), where the levels are defined by a
list, something like this:</p>

<pre>
pr_expr.pr_levels :=
  [{pr_label = "top"; pr_rules = expr_top};
   {pr_label = "add"; pr_rules = expr_add};
   {pr_label = "mul"; pr_rules = expr_mul};
   {pr_label = "apply"; pr_rules = expr_app};
   {pr_label = "simple"; pr_rules = expr_simple}]
;
</pre>

<p>where we find, in particular, our function <code>expr_app</code>
defined above.</p>

<p>The call to a specific level is done by the
function <code>pr_expr.pr_fun</code> with the level name. It returns the
function taking the "printing context" (<code>pc</code>) and the expression
as parameters, and returning the pretty printed string. For example, the
call to the top level of expressions has been defined as:</p>

<pre>
value expr pc e = pr_expr.pr_fun "top" pc e;
</pre>

<p>Same thing for the other pretty printed functions for patterns,
structures, signatures, and so on.</p>

<p>To extend some level, in another file, the
function <code>find_pr_level</code> can be used to get the level to
be extended, e.g.</p>

<pre>
let expr_app = find_pr_level "app" pr_expr.pr_levels in
expr_app.pr_rules :=
  extfun expr_app.pr_rules with
  [ &lt;:expr&lt; .... &gt;&gt; -> ...
  | &lt;:expr&lt; .... &gt;&gt; -> ... 
  | ... ];
</pre>

<div class="trailer">

  <hr style="margin:0" /><div style="font-size: 80%"><em>Copyright 2007
      Daniel de Rauglaudre (INRIA)</em></div>

  <p class="bottom">
    <a href="http://validator.w3.org/check?uri=referer"><img
       src="http://www.w3.org/Icons/valid-xhtml11" style="border:0"
       alt="Valid XHTML 1.1" height="31" width="88" /></a>
  </p>

</div>

</div>

</body>
</html>
