<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
  <!-- $Id$ -->
  <!-- Copyright (c) 2007 INRIA -->
  <title>parsers</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="shortcut icon" href="c4logo.png" />
  <style type="text/css"><!--
    body { counter-reset: h2cnt }
    h1 { text-align: center }
    h2:before { content: counter(h2cnt) " - "; counter-increment: h2cnt }
    h2 { border: 1px solid; text-align: center; background: #9bf }
    h2 { counter-reset: h3cnt }
    h3:before {
      content: counter(h2cnt) "." counter(h3cnt) " - ";
      counter-increment: h3cnt
    }
    p { text-align: justify; margin: 1em 1cm }
    li { margin-left: 1cm }
    pre {
      border-left: silver solid 3px; margin-bottom: 1.5em; margin-left: 2cm;
      padding-left: 1em; padding-right: 0.5em; line-height: 1.2
    }
    tt { font-weight: bold }
    .value { background: #0f0 }
  --></style>
</head>
<body>

<h1>Parsers of streams</h1>

<p>We describe here the syntax and the semantics of the parsers of
streams of Camlp4. Streams are kinds of lazy lists. The parsers of
these streams use recursive descendent method, which is the most
natural one in functionnal languages. In particular, parsers are
normal functions.

<p>Notice that the parsers have existed in OCaml since many years (the
beginning of the 90ies), but some new features have been added in 2007
(lookahead, "no error" optimization, and let..in statement) in Camlp4s
distribution. This page describes them also.</p>

<h2>Introduction</h2>

<p>Parsers apply to values of type "Stream.t" defined in the module
"Stream" of the standard library of OCaml. Like the type "list", the
type "Stream.t" has a type parameter, indicating the type of its
elements. They differ from the lists that they are lazy (the elements
are evaluated as long as the parser need them for its actions), and
imperative (parsers deletes their first elements when they take their
parsing decisions) : notice that pure functional parsers exist in
Camlp4, where the corresponding streams are lazy and functional, the
analyzed elements remaining in the initial stream and the semantic
action returning the resulting stream together with the normal
result, which allow natural limited backtrack but have the drawback
that it is not easy to find the position of parsing errors when they
happen.</p>

<p>Parsers of lazy/imperative streams, which are described here, use a
method named "recursive descendent" : they look at the first element,
they decide what to do in function of its value, and continue the
parsing with the remaining elements. Parsers can call other parsers,
and can be recursive, like normal functions.<p>

<p>Actually, parsers are just pure syntactic sugar. When writing a
parser in the syntax of the parser, Camlp4 transforms them into normal
call to functions, use of patterns matchings and try..with statements.
The pretty printer of Camlp4, by default, display this expanded
result, without syntax of parsers. A pretty printing kit, when added,
can rebuild the parsers in their initial syntax and display it.<p>


<h2>Syntax</h2>

<p>The syntax of parsers is the following:</p>

<pre>
            expression ::= parser
                parser ::= "parser" pos_opt "[" parser_cases "]"
                         | "parser" pos_opt parser_case
          parser_cases ::= parser_cases parser_case
                         | &lt;nothing&gt;
           parser_case ::= "[:" stream_pattern ":]" pos_opt "->" expression
        stream_pattern ::= stream_patt_comp
                         | stream_patt_comp ";" stream_pattern_cont
                         | "let" LIDENT "=" expression "in" stream_pattern
   stream_pattern_cont ::= stream_patt_comp_err
                         | stream_patt_comp_err ";" stream_pattern_cont
                         | "let" LIDENT "=" expression "in" stream_pattern_cont
  stream_patt_comp_err ::= stream_patt_comp
                         | stream_patt_comp "?" expression
                         | stream_patt_comp "!"
      stream_patt_comp ::= "`" pattern
                         | "`" pattern "when" expression
                         | "?=" lookaheads
                         | pattern "=" expression
                         | pattern
            lookaheads ::= lookaheads "|" lookahead
                         | lookahead
             lookahead ::= "[" patterns "]"
              patterns ::= patterns pattern
                         | pattern
               pos_opt ::= pattern
                         | &lt;nothing&gt;
</pre>

<h3>Semantics</h3>

<p>A parser, defined with the syntax "parser" above, is of type
"<code>Stream.t a -> b</code>" where "a" is the type of the elements
of the streams and "b" the type of the result. The parser cases are
tested in the order they are defined until one of them applies. The
result is the semantic action of the parser case which applies. If no
parser case applies, the exception "<code>Stream.Failure</code>" is
raised.</p>

<p>When testing a parser case, if the first stream pattern component
matches, all remaining stream pattern component of the stream pattern
must match also. If one does not match, the parser return with the
exception "<code>Stream.Error</code>" which has a parameter of type
string : by default, this string is the empty string, but if the
stream pattern component which does not match is followed by a
question mark and an expression, this expression is evaluated and
given as parameter to "<code>Stream.Error</code>".<p>

<p>In short, a parser can return with three ways:<p>

<ul>

<li>A normal result, of type "<code>b</code>" for a parser of type "<code>Stream.t a -> b</code>".</li>

<li>Raising the exception "<code>Stream.Failure</code>".</li>

<li>Raising the exception "<code>Stream.Error</code>".</li>

</ul>

<p>Fundamentally, the exception "<code>Stream.Failure</code>" means
"this parser does not apply and no element have been removed from the
initial stream". This is a normal case when parsing : the parser fails,
but the parsing can continue.</p>

<p>Conversely, the exception "<code>Stream.Error</code>" means that
"this parsers encountered a syntax error". In this case, the parsing
definitively fails.</p>

<p>Like said above, when a parser case applies partially but not completely,
the exception "<code>Stream.Error</code>" is raised. This means that if
two parser cases start with the same stream pattern components, only the
first one have chances to work. This is a limitation of this parsing
method. To turn over this limitation, one must factorize the rules to
make both work. A typical example is a language having a rule for the
statement "if..then..else" and a rule for the shorter "if..then". If
written that way:</p>

<pre>
      parser
      [ [: `If; e1 = expr; `Then; e2 = expr; `Else; e3 = expr :] -> f e1 e2 e3
      | [: `If; e1 = expr; `Then; e2 = expr :] -> g e1 e2 ]
</pre>

<p>the second pattern case cannot work.</p>

<p>Indeed, if the input is a stream containg the syntax with
"if..then..else", the first pattern case apply and it is
ok. Conversely, if the input contains just "if..then", the matching
fails when arriving at the "<code>Else</code>" stream pattern
component above. Since it is not the first stream pattern component of
the parser case, the parser fails with "<code>Stream.Error</code>".</p>

<p>Reversing the parser cases like this does not help:</p>

<pre>
      parser
      [ [: `If; e1 = expr; `Then; e2 = expr :] -> g e1 e2
      | [: `If; e1 = expr; `Then; e2 = expr; `Else; e3 = expr :] -> f e1 e2 e3 ]
</pre>

<p>In this case, whatever the input, containing the "if..then"
construction, or the "if..then..else.." construction, the first parser
case applies. If the input is "if..then..else..", only the part
"if..then.." is removed from the stream and the part "else.." remains.
When a parser case is applied, like for a function, the next case will
never apply.</p>

<p>The solution, with this parsing technology, is to do a left
factorization of the parsing cases, namely programming it like
this:<p>

<pre>
      parser
        [: `If; e1 = expr; `Then; e2 = expr;
           a =
             parser
             [ [: `Else; e3 = expr :] -> f e1 e2 e3
             | [: :] -> g e1 e2 ] :] ->
          a
</pre>

<h3>Stream pattern component</h3>

<p>In a stream pattern (starting with "<code>[:</code>" and ending
with "<code>:]</code>"), are the stream pattern components separated
with the semicolon character. There are three cases of stream pattern
components with some sub-cases for some of them, and an extra syntax
can be used with a "let..in" construction. The three cases are:</p>

<ul>

<li>A direct test of one or several stream elements (called "terminal"
elements), in three ways:

  <ol>

  <li>The character "backquote" followed by a pattern, meaning: if the
  stream starts with an element which is matched by this pattern, the
  stream pattern component matches, and the stream element is removed
  from the stream.</li>

  <li>The character "backquote" followed by a pattern, the keyword
  "when" and an expression of type "<code>bool</code>", meaning: if the
  stream starts with an element which is matched by this pattern and
  then if the evaluation of the expression is "<code>True</code>", the
  stream pattern component matches, and the first element of the stream
  is removed.</li>

  <li>The character "question mark" followed by the character "equal"
  (new feature 2007) and a lookahead expression (see further), meaning:
  if the lookahead applies, the stream pattern component matches. The
  lookahead may unfreeze one or several elements on the stream, but
  does not remove them.</p>

  </ol>

</li>

<li>A pattern followed by the "equal" sign and an expression of type
"<code>Stream.t x -> y</code>" for some types "<code>x</code>" and
"<code>y</code>". meaning: call the expression (which is a parser)
with the current stream. If this sub-parser:

  <ol>

  <li>Returns an element, the pattern is bound to this result and the
  next stream pattern component is tested.</li>

  <li>Raises the exception "<code>Stream.Failure</code>", there are two
  cases:

    <ul>

    <li>if the stream pattern component is the first one of the stream
    case, the current parser fails with "<code>Stream.Failure</code>"
    also.</li>

    <li>if the stream pattern component is not the first one of the stream
    case, the current parser fails with the exception
    "<code>Stream.Error</code>".</li>
    
    </ul>

  In this second case:

    <ul>

    <li>If the stream pattern component is followed by a "question mark"
    and an expression (which must be of type "<code>string</code>"), the
    expression is evaluated and given as parameter of the exception.</li>

    <li>If the expression is followed by an "exclamation mark" (new feature
    2007), the test and conversion from "<code>Stream.Failure</code>" to
    "<code>Stream.Error</code>" is not done, and the parser just raises
    "<code>Stream.Failure</code>" again. This is an optimization which
    must be assumed by the programmer, in general when he knows that
    the sub-parser called never raises "<code>Stream.Failure</code>" (for
    example if the called parser ends with a parser case containing an
    empty stream pattern). See "no error optionization" below.</li>

    <li>Otherwize the exception parameter is the empty string</li>

    </ul>

  </li>

  </ol>

</li>

<li>A pattern, which is bound to the current stream.</li>

</ul>

<p>Notice that patterns are bound immediately and can be used in the
next stream pattern component.</p>

<p>Between stream pattern components, it is possible to use the
"let..in" construction. This is not considered as a real stream
pattern component, in the fact that is is not tested against the
exception "<code>Stream.Failure</code>" it may raise. It can be useful
for an intermediate computation. In particular, it is used internally
by the <a href="pa_lexer.html">lexers</a> (this can be seen by
printing a code using these lexers into parsers by Camlp4 using the
pretty printing kit "pr_r.cmo").</p>

<p>Example of use, when an expression have to be used several times
(in the example, "<code>d a</code>", which is bound to the variable
"<code>c</code>"):</p>

<pre>
   parser
     [: a = b;
        let c = d a in
        e =
          parser
          [ [: f = g :] -> h c
          | [: :] -> c ] :] ->
       e
</pre>

<h3>Lookahead</h3>

<h3>No error optimization</h3>

<p>The "no error optimization" is a new feature 2007. This is the fact
to end a stream pattern component of kind "pattern" "equal"
"expression" by the character "exclamation mark". Like said above,
this inhibits the transformation of the exception
"<code>Stream.Failure</code>", possibly raised by the called parser
into the exception "<code>Stream.Error</code>".<p>

<p>The code:</p>

<pre>
    parser [: a = b; c = d ! :] -> e
</pre>

<p>is equivalent to:</p>

<pre>
    parser [: a = b; s :] -> let c = d s in e
</pre>

<p>On interest of the first syntax is that it shows to readers that
"<code>d</code>" is indeed a sub-parser. In the second syntax, it
is called in the semantic action, which makes the parser case not
no clear, as far as readability is concerned.</p>

<p>If the stream pattern component is the last one of the stream pattern,
this allow possible tail recursion done by the OCaml compiler, in the
following case:</p>

<pre>
    parser [: a = b; c = d ! :] -> c
</pre>

<p>since it is equivalent (with the fact that "<code>c</code>" is at
the same time the pattern of the last case and the expression of the
parser case semantic action:</p>

<pre>
    parser [: a = b; s :] -> d s
</pre>

<p>The call to "<code>d s</code>" can be a tail recursive call. Without
the use of the "exclamation mark" in the rule, the equivalent code is:</p>

<pre>
    parser [: a = b; s :] ->
      try d s with [ Stream.Failure -> raise (Stream.Error "")
</pre>

<p>which is not tail recursive (because the "try..with" construction
pushes a context), preventing the compiler to optimize its code. It
can have some importance when many recursive calls happen, since it
can overflow the OCaml stack.</p>

<h3>Position</h3>

<p>The optional "pattern" before and after a stream pattern is bound to
the current stream count. Indeed, streams contains internally the count
of its elements. At the beginning the count is zero. When an element is
removed, the count is incremented. The example:</p>

<pre>
    parser [: a = b :] ep -> c
</pre>

<p>is equivalent to:</p>

<pre>
    parser [: a = b; s :] -> let ep = Stream.count s in c
</pre>

<p>There is not direct syntax equivalent to the optional pattern at
beginning of the stream pattern:</p>

<pre>
    parser bp [: a = b :] -> c
</pre>

<p>These optional patterns allow to dispose of the stream count at the
beginning and at the end of the parser case, allowing to compute
locations of the rule in the source. In particular, if the stream is a
stream of characters, these counts are the source location in numberr
of characters.</p>

<h3>Semantic action</h3>

<p>In a parser case, after the stream pattern, there is an "arrow" and
an expression, called the "semantic action". If the parser case is
matched the parser returns with the expression evaluated, in a context
of the possibly patterns bound in the stream pattern (position,
backquote patterns, pattern equal expression, pattern).</p>

<hr style="margin:0" /><div style="font-size: 80%"><em>Copyright 2007
Daniel de Rauglaudre (INRIA)</em>

</body>
</html>
