<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
  <!-- $Id$ -->
  <!-- Copyright (c) 2007 INRIA -->
  <title>parsers</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="shortcut icon" href="c4logo.png" />
  <style type="text/css"><!--
    body { counter-reset: h2cnt }
    h1 { text-align: center }
    h2:before { content: counter(h2cnt) " - "; counter-increment: h2cnt }
    h2 { border: 1px solid; text-align: center; background: #9bf }
    h2 { counter-reset: h3cnt }
    h3:before {
      content: counter(h2cnt) "." counter(h3cnt) " - ";
      counter-increment: h3cnt
    }
    p { text-align: justify; margin: 1em 1cm }
    li { margin-left: 1cm }
    pre {
      border-left: silver solid 3px; margin-bottom: 1.5em; margin-left: 2cm;
      padding-left: 1em; padding-right: 0.5em; line-height: 1.2
    }
    tt { font-weight: bold }
    .value { background: #0f0 }
  --></style>
</head>
<body>

<h1>Parsers of streams</h1>

<p>We describe here the syntax and the semantics of the parsers of
streams of Camlp4. Streams are kinds of lazy lists. The parsers of
these streams use recursive descendent method, which is the most
natural one in functionnal languages. In particular, parsers are
normal functions.

<p>Notice that the parsers have existed in OCaml since many years (the
beginning of the 90ies), but some new features have been added in 2007
(lookahead, "no error" optimization, and let..in statement) in Camlp4s
distribution. This page describes them also.</p>

<h2>Introduction</h2>

<p>Parsers apply to values of type "Stream.t" defined in the module
"Stream" of the standard library of OCaml. Like the type "list", the
type "Stream.t" has a type parameter, indicating the type of its
elements. They differ from the lists that they are lazy (the elements
are evaluated as long as the parser need them for its actions), and
imperative (parsers deletes their first elements when they take their
parsing decisions) : notice that pure functional parsers exist in
Camlp4, where the corresponding streams are lazy and functional, the
analyzed elements remaining in the initial stream and the semantic
action returning the resulting stream together with the normal
result, which allow natural limited backtrack but have the drawback
that it is not easy to find the position of parsing errors when they
happen.</p>

<p>Parsers of lazy/imperative streams, which are described here, use a
method named "recursive descendent" : they look at the first element,
they decide what to do in function of its value, and continue the
parsing with the remaining elements. Parsers can call other parsers,
and can be recursive, like normal functions.<p>

<p>Actually, parsers are just pure syntactic sugar. When writing a
parser in the syntax of the parser, Camlp4 transforms them into normal
call to functions, use of patterns matchings and try..with statements.
The pretty printer of Camlp4, by default, display this expanded
result, without syntax of parsers. A pretty printing kit, when added,
can rebuild the parsers in their initial syntax and display it.<p>


<h2>Syntax</h2>

<p>The syntax of parsers is the following:</p>

<pre>
            expression ::= parser
                parser ::= "parser" pos_opt "[" parser_cases "]"
                         | "parser" pos_opt parser_case
          parser_cases ::= parser_cases parser_case
                         | &lt;nothing&gt;
           parser_case ::= "[:" stream_pattern ":]" pos_opt "->" expression
        stream_pattern ::= stream_patt_comp
                         | stream_patt_comp ";" stream_pattern_cont
                         | "let" LIDENT "=" expression "in" stream_pattern
   stream_pattern_cont ::= stream_patt_comp_err
                         | stream_patt_comp_err ";" stream_pattern_cont
                         | "let" LIDENT "=" expression "in" stream_pattern_cont
  stream_patt_comp_err ::= stream_patt_comp
                         | stream_patt_comp "?" expression
                         | stream_patt_comp "!"
      stream_patt_comp ::= "`" pattern
                         | "`" pattern "when" expression
                         | "?=" lookaheads
                         | pattern "=" expression
                         | pattern
            lookaheads ::= lookaheads "|" lookahead
                         | lookahead
             lookahead ::= "[" patterns "]"
              patterns ::= patterns pattern
                         | pattern
               pos_opt ::= pattern
                         | &lt;nothing&gt;
</pre>

<hr style="margin:0" /><div style="font-size: 80%"><em>Copyright 2007
Daniel de Rauglaudre (INRIA)</em>

</body>
</html>
