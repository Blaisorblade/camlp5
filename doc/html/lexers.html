<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
  <!-- $Id$ -->
  <!-- Copyright (c) 2007 INRIA -->
  <title>lexers</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="shortcut icon" href="c4logo.png" />
  <link rel="stylesheet" type="text/css" href="styles/base.css" />
</head>
<body>

<div id="menu">
  <h1>- Camlp4 -</h1>
  <ul>
    <li>Parsing
      <ul>
        <li><a href="parsers.html">parsers</a></li>
        <li><a href="lexers.html">lexers</a></li>
        <li><a href="fparsers.html">functional parsers</a></li>
      </ul>
    </li>
    <li>Printing
      <ul>
        <li><a href="pretty.html">library module</a></li>
        <li><a href="opretty.html">programs</a></li>
      </ul>
    </li>
    <li>Other
      <ul>
        <li><a href="ml_ast.html">syntax tree</a></li>
        <li><a href="pragma.html">pragma directive</a></li>
        <li><a href="extfun.html">extensible functions</a></li>
      </ul>
    </li>
  </ul>
</div>

<div id="content">

<h1 class="top">Lexers of streams - pa_lex.cmo</h1>

<p>The file pa_lex.cmo is a Camlp4 syntax extension for parsers for
streams of the type 'char'. This syntax is shorter in length and more
readable than its equivalent version written
with <a href="parsers.html">classical stream parsers</a>.  Like
classical parsers, they use recursive descendant parsing. They are
also pure syntax sugar, and each lexer written with this syntax can be
written using normal parsers syntax.</p>

<h2>Introduction</h2>

<p>Classical parsers in OCaml apply to streams of any type of
values. But, for the specific type "char", it has been possible to
shorten codes in several ways, in particular by using strings to group
several characters together, and by hidding the management of a
"lexing buffer", a data structure recording the matched
characters.</p>

<p>In order to motivate our work, here is a small example. Let us look
at the following parser. It parses an identifier, composed of letters,
digits, underscores, quotes and utf-8 characters, and record the
result in a buffer. In classical parsers syntax, this could be written
like this:</p>

<pre>
value rec ident buf =
  parser
  [ [: `('A'..'Z' | 'a'..'z' | '0'..'9' | '_' | ''' | '\128'..'\255'
       as c); buf = ident (B.add c buf) ! :] -&gt; buf
  | [: :] -&gt; buf ];
</pre>

<p> With the new syntax, it is possible to write it as:</p>

<pre>
value rec ident = lexer [ "A..Za..z0..9_'\128..\255" ident! | ];
</pre>

<p>The two codes are strictly equivalent, but the lexer version is easier
to write and understand, and is much shorter.</p>

<h2>Syntax</h2>

<p>When loading the syntax extension <code>pa_lex.cmo</code>, the
OCaml syntax is extended as follows:</p>

<pre>
        expression ::= lexer
             lexer ::= "lexer" "[" rules "]"
             rules ::= rules rule
                     | &lt;nothing&gt;
              rule ::= symbols [ "-&gt;" action ]
           symbols ::= symbols symbol err
                     | &lt;nothing&gt;
            symbol ::= "_" no_record_opt
                     | STRING no_record_opt
                     | simple_expression
                     | "?=" "[" lookaheads "]"
                     | "[" rules "]"
     no_record_opt ::= "/"
                     | &lt;nothing&gt;
 simple_expression ::= LIDENT
                     | CHAR
                     | "(" &lt;expression&gt; ")"
        lookaheads ::= lookaheads "|" lookahead_sequence
                     | lookahead_sequence
lookahead_sequence ::= lookahead_symbols
                     | STRING
 lookahead_symbols ::= lookahead_symbols lookahead_symbol
                     | lookahead_symbol
  lookahead_symbol ::= CHAR
                     | "_"
               err ::= "?" simple_expression
                     | "!"
                     | &lt;nothing&gt;
            action ::= expression
</pre>

<p>The identifiers "<code>STRING</code>", "<code>CHAR</code>" and
"<code>LIDENT</code>" above represent the OCaml tokens corresponding
to string, character and lowercase identifier (identifier starting
with a lowercase character).</p>

<p>Moreover, together with that syntax extension, another extension is
added the entry <code>expression</code>, typically for the semantics
actions of the "<code>lexer</code>" statement above, but not only. It
is:</p>

<pre>
expression ::= "$" "add" STRING
             | "$" "buf"
             | "$" "empty"
             | "$" "pos"
</pre>

<p>Remark: the identifiers "add", "buf", "empty" and "pos" do not
become keywords (they are not reserved words) but just identifiers. On
the contrary, the identifier <code>lexer</code>, which introduces the
syntax, is a new keyword and cannot be used as variable identifier any
more.</p>

<h2>Semantics</h2>

<p>A lexer defined in the syntax above is a shortcut version of a
parser applied to the specific case of streams of characters. It could
be written with a normal parser. The proposed syntax is much shorter,
easier to use and to understand, and silently takes care of the lexing
buffer for the programmer. The lexing buffers are data structures,
which are passed as parameters to called lexers and returned by
them.</p>

<p>Our lexers are of the type:</p>

<pre>
B.t -&gt; Stream.t char -&gt; u
</pre>

<p>where "<code>u</code>" is a type which depends on what the lexer
returns. If there is no semantic action (since it it optional), this
type is automatically "<code>B.t</code>".</p>

<p>"<code>B</code>" is a module which must be defined by the user. It
has to contain the lexing buffer type "<code>t</code>" and some
variables and functions:</p>

<ul>

<li>
<code>empty</code>: the empty lexing buffer
</li>

<li><code>add</code>: the way to add a character to a lexing buffer
</li>

<li><code>get</code>: the way to get a string from the lexing buffer
</li>

</ul>

<p>A possible implementation, using "<code>list char</code>" as lexing
buffer type ("<code>B.t</code>"), recording the characters at top of
the list (therefore creating a list in reverse order) could be:</p>

<pre>
(* tool function, converting a reversed list of char into a string *)
value rev_implode cl =
  let s = String.create (List.length cl) in
  loop (String.length s - 1) cl where rec loop i =
    fun
    [ [c :: cl] -&gt; do { s.[i] := c; loop (i - 1) cl }
    | [] -&gt; s ]
 ;

 (* the lexing buffer module *)
 module B =
   struct
     type t = list char;
     value empty = [];
     value add c l = [c :: l];
     value get = rev_implode;
   end
;
</pre>

<p>A lexer is a function with two parameters: the first one is the
lexing buffer itself, and the second one the stream. When called, it
tries to match the stream against its first rule. If it fails, it
tries its second rule, and so on, up to its last rule. If the last
rule fails, the lexer fails by raising the exception
"<code>Stream.Failure</code>". All of this is
the <a href="parsers.html">usual behaviour of stream parsers</a>.</p>

<p>In a rule, when a character is matched, it is inserted into the
lexing buffer, except if the "no record" feature is used (see
further).</p>

<p>Rules which have no semantic action return the lexing buffer
itself.</p>

<h3>Symbols</h3>

<p>The different kinds or symbols in a rule are:</p>

<ul>

<li>The token "underscore", which represents any character. Fails only
if the stream is empty.</li>

<li>A string which represent a matching of any character in the
string. Notice that it is a <span style="font:underline">choice</span>
between all the characters, <span style="font:underline">not</span>
the sequence of these characters. To indicate a sequence, you have to
use several symbols, the ones behind the others. Character ranges can
be inserted using the characters "<code>..</code>". For example, to
specify a match of any letter or digit, you can write
"<code>A..Za..z0..9</code>". Conversely, the beginning of a comment in
the OCaml language has to be written: <code>"(" "*"</code>,
not <code>"(*"</code> which would mean "the character left parenthesis
or the character star".</li>

<li>An expression corresponding to a call to another lexer, which
takes the buffer as first parameter and has to return another lexing
buffer with all characters found in the stream catened to the lexing
buffer.</li>

<li>The sequence "<code>?=</code>" introducing lookahead characters.
See the section <a href="#lookahead">3.3</a>.</li>

<li>A rule, recursively, between brackets, inlining a lexer.</li>

</ul>

<p>In the first two cases (namely, underscore and string), the symbol
can be optionally followed by the character "slash" specifying that
the found symbol must not be added into the lexing buffer. By default,
it is. Useful, for example, when writing a lexer parsing strings, when
the initial double quote and final double quote have not to be part of
the string itself.</p>

<p>Moreover, a symbol can be followed by an optional error indicator,
which can be:</p>

<ul>

<li>The character <code>?</code> (question mark) followed by a string
expression, telling that, if there is a syntax error at this point
(i.e. the symbol is not matched although the beginning of the rule
was), the exception <code>Stream.Error</code> is raised with that
string as parameter. Without this indicator, it is raised with the
empty string. This is the same behaviour than with
classical <a href="parsers.html">stream parsers</a>.</li>

<li>The character <code>!</code> (exclamation mark), which is just an
indicator to let the syntax expander optimize the code. If the
programmer is sure that the symbol never fails (i.e. never
raises <code>Stream.Failure</code>), in particular if this symbol
recognizes the empty rule, he can add this exclamation mark. If it is
used correctly (the compiler cannot check it), the behaviour is
identical as without the <code>!</code>, except that the code is
shorter and faster, and can sometimes be tail recursive. If the
indication is not correct, the behaviour of the lexer is
undefined. This feature exists also in classical stream parsers (it is
a new feature added in 2007).</li>

</ul>

<p><a id="specific"></a></p>

<h3>Specific expressions</h3>

<p>When loading this syntax extension, the
entry <code>&lt;expression&gt;</code>, at level labelled "simple" of
the OCaml language is extended with the following
rules:</p>

<ul>

<li><code>$add</code> followed by a string, specifing that the
programmer wants to add all characters of the string in the lexing
buffer. It returns the new lexing buffer. It corresponds to an
iteration of calls to <code>B.add</code> with all characters of the
string with the current lexing buffer as initial
parameter.</li>

<li><code>$buf</code> which returns the lexing buffer converted into
string.</li>

<li><code>$empty</code> which returns an empty lexing buffer.</li>

<li><code>$pos</code> which return the current position in
the stream in number of characters (starting at zero).</li>

</ul>

<p><a id="lookahead"></a></p>

<h3>Lookahead</h3>

<p>Lookahead is useful in some cases, when factorization of rules is
impossible. To understand how it is useful, a first remark must
be done, about the usual behaviour of Camlp4 stream parsers.</p>

<p>Stream parsers (including these lexers) use a limited parsing
algorithm, in a way that when the first symbol of a rule is matched,
all the following symbols of the same rule must apply, otherwise it is
a syntax error. There is no backtrack. In most of the cases, left
factorization of rules resolve conflicting problems. For example, in
parsers of tokens (which is not our case here, since we parse only
characters), when one writes a parser to recognize both the typicall
grammar rules "if..then..else" and the shorter "if..then..", the
solution is to write a rule starting with "if..then.." followed with a
call to a parser recognizing "else.." <span style="font:underline">or</span>
nothing.</p>

<p>Sometimes, however, this left factorization is not possible. A
lookahead of the stream to check the presence of some elements (these
element being characters, if we are using this "lexer" syntax) might
be necessary to decide whether or not it is a good idea to start
the rule. This lookahead feature may unfreeze several characters
from the input stream but without removing them.</p>

<p>Syntactically, a lookahead starts with <code>?=</code> and is
followed by one or several lookahead sequences separated by the
vertical bar <code>|</code>, the whole list being enclosed by
braces.</p>

<p>If there are several lookaheads, they must all be of the same size
(contain the same number of characters).</p>

<p>If the lookahead sequence is just a string, it corresponds to all
characters of this string in the order (which is different for strings
outside lookahead sequences, representing a choice of all
characters).</p>

<p>Examples of lookaheads:</p>

<pre>
?= [ _ ''' | '\\' _ ]
?= [ "&lt;&lt;" | "&lt;:" ]
</pre>

<p>The first line above matches a stream whose second character is a
quote or a stream whose first character is a backslash (real example
in the lexer of OCaml, in the library of Camlp4, named
"plexer.ml"). The second line matches a stream starting with the two
characters <code>&lt;</code> and <code>&lt;</code> or starting with
the two characters <code>&lt;</code> and <code>:</code> (this is
another example in the same file).</p>

<h3>Semantic actions of rules</h3>

<p>By default, the result of a "lexer" is the current lexing buffer,
which is of type "<code>B.t</code>". But it is possible to return
other values, by adding "<code>-&gt;</code>" at end of rules followed
by the expression you want to return, like in usual pattern matching
in OCaml.</p>

<p>An interesting result, for example, could be the string
corresponding to the characters of the lexing buffer. This can be
obtained by returning the value "<code>$buf</code>" (see
section <a href="#specific">3.2</a>)</p>

<h3>A complete example</h3>

<p>A complete example can be seen in the sources of Camlp4, file
"lib/plexer.ml". This is the lexer of OCaml, either "normal" or
"revised" syntax.</p>

<h3>Compiling</h3>

<p>To compile a file containing lexers, just
load <code>pa_lex.cmo</code> using one of the following methods:</p>

<ul>

<li>Either by adding <code>pa_lex.cmo</code> among the camlp4
options. See the camlp4 manual page or documentation.
</li>

<li>Or by adding <code>#load "pa_lex.cmo";</code> anywhere in the
file, before the usages of this "lexer" syntax.</li>

</ul>

<h3>How to display the generated code</h3>

<p>You can see the generated code, for a file "bar.ml" containing
lexers, by typing in a command line:</p>

<pre>
camlp4r pa_lex.cmo pr_r.cmo bar.ml
</pre>

<p>To see the equivalent code with stream parsers, use:</p>

<pre>
camlp4r pa_lex.cmo pr_r.cmo pr_rp.cmo bar.ml
</pre>

<div class="trailer">

  <hr style="margin:0" /><div style="font-size: 80%"><em>Copyright 2007
      Daniel de Rauglaudre (INRIA)</em></div>

  <p class="bottom">
    <a href="http://validator.w3.org/check?uri=referer"><img
       src="http://www.w3.org/Icons/valid-xhtml11" style="border:0"
       alt="Valid XHTML 1.1" height="31" width="88" /></a>
  </p>

</div>

</div>

</body>
</html>
