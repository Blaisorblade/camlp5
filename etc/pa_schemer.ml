(* camlp5 pa_r.cmo pa_rp.cmo pa_extend.cmo q_MLast.cmo pr_dump.cmo *)
(* File generated by pretty print; do not edit! *)
(* Copyright (c) INRIA 2007 *)

open Pcaml;

type choice 'a 'b =
  [ Left of 'a
  | Right of 'b ]
;

(* Buffer *)

module Buff =
  struct
    value buff = ref (String.create 80);
    value store len x = do {
      if len >= String.length buff.val then
        buff.val := buff.val ^ String.create (String.length buff.val)
      else ();
      buff.val.[len] := x;
      succ len
    };
    value get len = String.sub buff.val 0 len;
  end
;

value rename_id s =
  if String.length s > 0 && s.[String.length s - 1] = '#' then
    String.sub s 0 (String.length s - 1)
  else Pcaml.rename_id.val s
;

(* Lexer *)

value rec skip_to_eol =
  parser
  [ [: `'\n' | '\r' :] -> ()
  | [: `_; s :] -> skip_to_eol s ]
;

value no_ident =
  ['('; ')'; '['; ']'; '{'; '}'; ' '; '\t'; '\n'; '\r'; ';'; '.']
;

value rec ident len =
  parser
  [ [: `x when not (List.mem x no_ident); s :] -> ident (Buff.store len x) s
  | [: :] -> Buff.get len ]
;

value identifier kwt s =
  let con =
    try do { (Hashtbl.find kwt s : unit); "" } with
    [ Not_found ->
        match s.[0] with
        [ 'A'..'Z' -> "UIDENT"
        | _ -> "LIDENT" ] ]
  in
  (con, s)
;

value rec string len =
  parser
  [ [: `'"' :] -> Buff.get len
  | [: `'\\'; `c; s :] -> string (Buff.store (Buff.store len '\\') c) s
  | [: `x; s :] -> string (Buff.store len x) s ]
;

value rec end_exponent_part_under len =
  parser
  [ [: `('0'..'9' as c); s :] -> end_exponent_part_under (Buff.store len c) s
  | [: :] -> ("FLOAT", Buff.get len) ]
;

value end_exponent_part len =
  parser
  [ [: `('0'..'9' as c); s :] -> end_exponent_part_under (Buff.store len c) s
  | [: :] -> raise (Stream.Error "ill-formed floating-point constant") ]
;

value exponent_part len =
  parser
  [ [: `('+' | '-' as c); s :] -> end_exponent_part (Buff.store len c) s
  | [: a = end_exponent_part len :] -> a ]
;

value rec decimal_part len =
  parser
  [ [: `('0'..'9' as c); s :] -> decimal_part (Buff.store len c) s
  | [: `'e' | 'E'; s :] -> exponent_part (Buff.store len 'E') s
  | [: :] -> ("FLOAT", Buff.get len) ]
;

value rec number len =
  parser
  [ [: `('0'..'9' as c); s :] -> number (Buff.store len c) s
  | [: `'.'; s :] -> decimal_part (Buff.store len '.') s
  | [: `'e' | 'E'; s :] -> exponent_part (Buff.store len 'E') s
  | [: :] -> ("INT", Buff.get len) ]
;

value binary = parser [: `('0'..'1' as c) :] -> c;

value octal = parser [: `('0'..'7' as c) :] -> c;

value hexa = parser [: `('0'..'9' | 'a'..'f' | 'A'..'F' as c) :] -> c;

value rec digits_under kind len =
  parser
  [ [: d = kind; s :] -> digits_under kind (Buff.store len d) s
  | [: :] -> Buff.get len ]
;

value digits kind bp len =
  parser
  [ [: d = kind; s :] -> ("INT", digits_under kind (Buff.store len d) s)
  | [: :] ep ->
      Ploc.raise (Ploc.make_unlined (bp, ep))
        (Failure "ill-formed integer constant") ]
;

value base_number kwt bp len =
  parser
  [ [: `'b' | 'B'; s :] -> digits binary bp (Buff.store len 'b') s
  | [: `'o' | 'O'; s :] -> digits octal bp (Buff.store len 'o') s
  | [: `'x' | 'X'; s :] -> digits hexa bp (Buff.store len 'x') s
  | [: id = ident (Buff.store 0 '#') :] -> identifier kwt id ]
;

value rec operator len =
  parser
  [ [: `'.' :] -> Buff.get (Buff.store len '.')
  | [: :] -> Buff.get len ]
;

value char_or_quote_id x =
  parser
  [ [: `''' :] -> ("CHAR", String.make 1 x)
  | [: s :] ep ->
      if List.mem x no_ident then
        Ploc.raise (Ploc.make_unlined (ep - 2, ep - 1))
          (Stream.Error "bad quote")
      else
        let len = Buff.store (Buff.store 0 ''') x in
        let s = ident len s in
        ("LIDENT", s) ]
;

value rec char len =
  parser
  [ [: `''' :] -> len
  | [: `x; s :] -> char (Buff.store len x) s ]
;

value quote =
  parser
  [ [: `'\\'; len = char (Buff.store 0 '\\') :] -> ("CHAR", Buff.get len)
  | [: `x; s :] -> char_or_quote_id x s ]
;

value rec lexer kwt =
  parser bp
  [ [: `'\t' | '\r'; s :] -> lexer kwt s
  | [: `' '; s :] -> after_space kwt s
  | [: `';'; _ = skip_to_eol; s :] -> lexer kwt s
  | [: `'\n'; s :] ->
      if Sys.interactive.val then (("NL", ""), (bp, bp + 1)) else lexer kwt s
  | [: `'(' :] -> (("", "("), (bp, bp + 1))
  | [: `')' :] -> (("", ")"), (bp, bp + 1))
  | [: `'[' :] -> (("", "["), (bp, bp + 1))
  | [: `']' :] -> (("", "]"), (bp, bp + 1))
  | [: `'{' :] -> (("", "{"), (bp, bp + 1))
  | [: `'}' :] -> (("", "}"), (bp, bp + 1))
  | [: `'.' :] -> (("DOT", ""), (bp, bp + 1))
  | [: `'"'; s = string 0 :] ep -> (("STRING", s), (bp, ep))
  | [: `'''; tok = quote :] ep -> (tok, (bp, ep))
  | [: `'<'; tok = less kwt :] ep -> (tok, (bp, ep))
  | [: `'-'; tok = minus kwt :] ep -> (tok, (bp, ep))
  | [: `'#'; tok = sharp bp kwt :] ep -> (tok, (bp, ep))
  | [: `'~'; tok = tilde :] ep -> (tok, (bp, ep))
  | [: `'?'; tok = question :] ep -> (tok, (bp, ep))
  | [: `('0'..'9' as c); tok = number (Buff.store 0 c) :] ep ->
      (tok, (bp, ep))
  | [: `('+' | '*' | '/' as c); id = operator (Buff.store 0 c) :] ep ->
      (identifier kwt id, (bp, ep))
  | [: `x; id = ident (Buff.store 0 x) :] ep -> (identifier kwt id, (bp, ep))
  | [: :] -> (("EOI", ""), (bp, bp + 1)) ]
and after_space kwt =
  parser
  [ [: `'.' :] ep -> (("SPACEDOT", ""), (ep - 1, ep))
  | [: x = lexer kwt :] -> x ]
and tilde =
  parser
  [ [: `('a'..'z' as c); s = ident (Buff.store 0 c) :] -> ("TILDEIDENT", s)
  | [: :] -> ("LIDENT", "~") ]
and question =
  parser
  [ [: `('a'..'z' as c); s = ident (Buff.store 0 c) :] -> ("QUESTIONIDENT", s)
  | [: :] -> ("LIDENT", "?") ]
and sharp bp kwt =
  parser
  [ [: `'(' :] -> ("", "#(")
  | [: tok = base_number kwt bp (Buff.store 0 '0') :] -> tok ]
and minus kwt =
  parser
  [ [: `'.' :] -> identifier kwt "-."
  | [: `('0'..'9' as c); n = number (Buff.store (Buff.store 0 '-') c) :] -> n
  | [: id = ident (Buff.store 0 '-') :] -> identifier kwt id ]
and less kwt =
  parser
  [ [: `':'; lab = label 0; `'<' ? "'<' expected"; q = quotation 0 :] ->
      ("QUOT", lab ^ ":" ^ q)
  | [: id = ident (Buff.store 0 '<') :] -> identifier kwt id ]
and label len =
  parser
  [ [: `('a'..'z' | 'A'..'Z' | '_' as c); s :] -> label (Buff.store len c) s
  | [: :] -> Buff.get len ]
and quotation len =
  parser
  [ [: `'>'; s :] -> quotation_greater len s
  | [: `x; s :] -> quotation (Buff.store len x) s
  | [: :] -> failwith "quotation not terminated" ]
and quotation_greater len =
  parser
  [ [: `'>' :] -> Buff.get len
  | [: a = quotation (Buff.store len '>') :] -> a ]
;

value lexer_using kwt (con, prm) =
  match con with
  [ "CHAR" | "DOT" | "EOI" | "INT" | "FLOAT" | "LIDENT" | "NL" |
    "QUESTIONIDENT" | "QUOT" | "SPACEDOT" | "STRING" | "TILDEIDENT" |
    "UIDENT" ->
      ()
  | "ANTIQUOT" | "ANTIQUOT_LOC" -> ()
  | "" ->
      try Hashtbl.find kwt prm with [ Not_found -> Hashtbl.add kwt prm () ]
  | _ ->
      raise
        (Plexing.Error
           ("the constructor \"" ^ con ^ "\" is not recognized by Plexer")) ]
;

value lexer_text (con, prm) =
  if con = "" then "'" ^ prm ^ "'"
  else if prm = "" then con
  else con ^ " \"" ^ prm ^ "\""
;

value lexer_gmake () =
  let kwt = Hashtbl.create 89
  and lexer2 kwt (s, _, _) =
    let (t, loc) = lexer kwt s in
    (t, Ploc.make_unlined loc)
  in
  {Plexing.tok_func = Plexing.lexer_func_of_parser (lexer2 kwt);
   Plexing.tok_using = lexer_using kwt; Plexing.tok_removing = fun [];
   Plexing.tok_match = Plexing.default_match; Plexing.tok_text = lexer_text;
   Plexing.tok_comm = None}
;

(* Building AST *)

type sexpr =
  [ Sacc of MLast.loc and sexpr and sexpr
  | Sarr of MLast.loc and list sexpr
  | Schar of MLast.loc and string
  | Sexpr of MLast.loc and list sexpr
  | Sint of MLast.loc and string
  | Sfloat of MLast.loc and string
  | Slid of MLast.loc and string
  | Slist of MLast.loc and list sexpr
  | Sqid of MLast.loc and string
  | Squot of MLast.loc and string and string
  | Srec of MLast.loc and list sexpr
  | Sstring of MLast.loc and string
  | Stid of MLast.loc and string
  | Suid of MLast.loc and string ]
;

value loc_of_sexpr =
  fun
  [ Sacc loc _ _ | Sarr loc _ | Schar loc _ | Sexpr loc _ | Sint loc _ |
    Sfloat loc _ | Slid loc _ | Slist loc _ | Sqid loc _ | Squot loc _ _ |
    Srec loc _ | Sstring loc _ | Stid loc _ | Suid loc _ ->
      loc ]
;
value error_loc loc err = Ploc.raise loc (Stream.Error (err ^ " expected"));
value error se err = error_loc (loc_of_sexpr se) err;

value strm_n = "strm__";
value peek_fun loc = <:expr< Stream.peek >>;
value junk_fun loc = <:expr< Stream.junk >>;

value assoc_left_parsed_op_list =
  ["+"; "*"; "+."; "*."; "land"; "lor"; "lxor"]
;
value assoc_right_parsed_op_list = ["and"; "or"; "^"; "@"];
value and_by_couple_op_list = ["="; "<>"; "<"; ">"; "<="; ">="; "=="; "!="];

value op_apply loc e1 e2 =
  fun
  [ "and" -> <:expr< $e1$ && $e2$ >>
  | "or" -> <:expr< $e1$ || $e2$ >>
  | x -> <:expr< $lid:x$ $e1$ $e2$ >> ]
;

value string_se =
  fun
  [ Sstring loc s -> s
  | se -> error se "string" ]
;

value rec mod_ident_se =
  fun
  [ Sacc _ se1 se2 -> mod_ident_se se1 @ mod_ident_se se2
  | Suid _ s -> [rename_id s]
  | Slid _ s -> [rename_id s]
  | se -> error se "mod_ident" ]
;

value lident_expr loc s =
  if String.length s > 1 && s.[0] = '`' then
    let s = String.sub s 1 (String.length s - 1) in
    <:expr< ` $s$ >>
  else <:expr< $lid:(rename_id s)$ >>
;

value rec module_expr_se =
  fun
  [ Sexpr loc [Slid _ "functor"; Suid _ s; se1; se2] ->
      let s = rename_id s in
      let mt = module_type_se se1 in
      let me = module_expr_se se2 in
      <:module_expr< functor ($uid:s$ : $mt$) -> $me$ >>
  | Sexpr loc [Slid _ "struct" :: sl] ->
      let mel = List.map str_item_se sl in
      <:module_expr< struct $list:mel$ end >>
  | Sexpr loc [se1; se2] ->
      let me1 = module_expr_se se1 in
      let me2 = module_expr_se se2 in
      <:module_expr< $me1$ $me2$ >>
  | Sexpr loc [Slid _ ":"; se1; se2] ->
      let me = module_expr_se se1 in
      let mt = module_type_se se2 in
      <:module_expr< ($me$ : $mt$) >>
  | Sacc loc se1 se2 ->
      let me1 = module_expr_se se1 in
      let me2 = module_expr_se se2 in
      <:module_expr< $me1$ . $me2$ >>
  | Suid loc s -> <:module_expr< $uid:(rename_id s)$ >>
  | se -> error se "module expr" ]
and module_type_se =
  fun
  [ Sexpr loc [Slid _ "functor"; Suid _ s; se1; se2] ->
      let s = rename_id s in
      let mt1 = module_type_se se1 in
      let mt2 = module_type_se se2 in
      <:module_type< functor ($uid:s$ : $mt1$) -> $mt2$ >>
  | Sexpr loc [Slid _ "sig" :: sel] ->
      let sil = List.map sig_item_se sel in
      <:module_type< sig $list:sil$ end >>
  | Sexpr loc [Slid _ "with"; se :: sel] ->
      let mt = module_type_se se in
      let wcl = List.map with_constr_se sel in
      <:module_type< $mt$ with $list:wcl$ >>
  | Sacc loc se1 se2 ->
      let mt1 = module_type_se se1 in
      let mt2 = module_type_se se2 in
      <:module_type< $mt1$ . $mt2$ >>
  | Suid loc s -> <:module_type< $uid:(rename_id s)$ >>
  | se -> error se "module type" ]
and with_constr_se =
  fun
  [ Sexpr loc [Slid _ "type"; se1; se2] ->
      let tn = mod_ident_se se1 in
      let te = ctyp_se se2 in
      <:with_constr< type $tn$ = $te$ >>
  | se -> error se "with constr" ]
and sig_item_se =
  fun
  [ Sexpr loc [Slid _ "open"; se] ->
      let s = mod_ident_se se in
      <:sig_item< open $s$ >>
  | Sexpr loc [Slid _ "type" :: sel] ->
      let tdl = type_declaration_list_se sel in
      <:sig_item< type $list:tdl$ >>
  | Sexpr loc [Slid _ "type*" :: sel] ->
      let tdl = List.map type_declaration_se sel in
      <:sig_item< type $list:tdl$ >>
  | Sexpr loc [Slid _ "exception"; Suid _ c :: sel] ->
      let c = rename_id c in
      let tl = List.map ctyp_se sel in
      <:sig_item< exception $uid:c$ of $list:tl$ >>
  | Sexpr loc [Slid _ "value"; Slid _ s; se] ->
      let s = rename_id s in
      let t = ctyp_se se in
      <:sig_item< value $lid:s$ : $t$ >>
  | Sexpr loc [Slid _ "external"; Slid _ i; se :: sel] ->
      let i = rename_id i in
      let pd = List.map string_se sel in
      let t = ctyp_se se in
      <:sig_item< external $lid:i$ : $t$ = $list:pd$ >>
  | Sexpr loc [Slid _ "module"; Suid _ s; se] ->
      let s = rename_id s in
      let mb = module_type_se se in
      <:sig_item< module $uid:s$ : $mb$ >>
  | Sexpr loc [Slid _ "moduletype"; Suid _ s; se] ->
      let s = rename_id s in
      let mt = module_type_se se in
      <:sig_item< module type $uid:s$ = $mt$ >>
  | se -> error se "sig item" ]
and str_item_se se =
  match se with
  [ Sexpr loc [Slid _ "open"; se] ->
      let s = mod_ident_se se in
      <:str_item< open $s$ >>
  | Sexpr loc [Slid _ "type" :: sel] ->
      let tdl = type_declaration_list_se sel in
      <:str_item< type $list:tdl$ >>
  | Sexpr loc [Slid _ "type*" :: sel] ->
      let tdl = List.map type_declaration_se sel in
      <:str_item< type $list:tdl$ >>
  | Sexpr loc [Slid _ "exception"; Suid _ c :: sel] ->
      let c = rename_id c in
      let tl = List.map ctyp_se sel in
      <:str_item< exception $uid:c$ of $list:tl$ >>
  | Sexpr loc [Slid _ "exceptionrebind"; Suid _ c; se] ->
      let c = rename_id c in
      let id = mod_ident_se se in
      <:str_item< exception $uid:c$ = $id$ >>
  | Sexpr loc [Slid _ ("define" | "definerec" as r); se :: sel] ->
      let r = r = "definerec" in
      let (p, e) = fun_binding_se se (begin_se loc sel) in
      <:str_item< value $flag:r$ $p$ = $e$ >>
  | Sexpr loc [Slid _ ("define*" | "definerec*" as r) :: sel] ->
      let r = r = "definerec*" in
      let lbs = List.map let_binding_se sel in
      <:str_item< value $flag:r$ $list:lbs$ >>
  | Sexpr loc [Slid _ "external"; Slid _ i; se :: sel] ->
      let i = rename_id i in
      let pd = List.map string_se sel in
      let t = ctyp_se se in
      <:str_item< external $lid:i$ : $t$ = $list:pd$ >>
  | Sexpr loc [Slid _ "module"; Suid _ i; se] ->
      let i = rename_id i in
      let mb = module_binding_se se in
      <:str_item< module $uid:i$ = $mb$ >>
  | Sexpr loc [Slid _ "moduletype"; Suid _ s; se] ->
      let s = rename_id s in
      let mt = module_type_se se in
      <:str_item< module type $uid:s$ = $mt$ >>
  | Sexpr loc [Slid _ "#"; Slid _ s; se] ->
      let s = rename_id s in
      let e = expr_se se in
      <:str_item< # $lid:s$ $e$ >>
  | _ ->
      let loc = loc_of_sexpr se in
      let e = expr_se se in
      <:str_item< $exp:e$ >> ]
and module_binding_se se = module_expr_se se
and expr_se =
  fun
  [ Sacc loc se1 se2 ->
      let e1 = expr_se se1 in
      match se2 with
      [ Slist loc [se2] ->
          let e2 = expr_se se2 in
          <:expr< $e1$ .[ $e2$ ] >>
      | Sexpr loc [se2] ->
          let e2 = expr_se se2 in
          <:expr< $e1$ .( $e2$ ) >>
      | _ ->
          let e2 = expr_se se2 in
          <:expr< $e1$ . $e2$ >> ]
  | Slid loc s -> lident_expr loc s
  | Suid loc s -> <:expr< $uid:(rename_id s)$ >>
  | Sint loc s -> <:expr< $int:s$ >>
  | Sfloat loc s -> <:expr< $flo:s$ >>
  | Schar loc s -> <:expr< $chr:s$ >>
  | Sstring loc s -> <:expr< $str:s$ >>
  | Stid loc s -> <:expr< ~$(rename_id s)$ >>
  | Sqid loc s -> <:expr< ?$(rename_id s)$ >>
  | Sexpr loc [] -> <:expr< () >>
  | Sexpr loc [Slid _ s; e1 :: ([_ :: _] as sel)]
    when List.mem s assoc_left_parsed_op_list ->
      loop (expr_se e1) (List.map expr_se sel) where rec loop e1 =
        fun
        [ [] -> e1
        | [e2 :: el] -> loop (op_apply loc e1 e2 s) el ]
  | Sexpr loc [Slid _ s :: ([_; _ :: _] as sel)]
    when List.mem s assoc_right_parsed_op_list ->
      loop (List.map expr_se sel) where rec loop =
        fun
        [ [] -> assert False
        | [e1] -> e1
        | [e1 :: el] ->
            let e2 = loop el in
            op_apply loc e1 e2 s ]
  | Sexpr loc [Slid _ s :: ([_; _ :: _] as sel)]
    when List.mem s and_by_couple_op_list ->
      loop (List.map expr_se sel) where rec loop =
        fun
        [ [] | [_] -> assert False
        | [e1; e2] -> <:expr< $lid:s$ $e1$ $e2$ >>
        | [e1 :: ([e2; _ :: _] as el)] ->
            let a1 = op_apply loc e1 e2 s in
            let a2 = loop el in
            <:expr< $a1$ && $a2$ >> ]
  | Sexpr loc [Stid _ s; se] ->
      let e = expr_se se in
      <:expr< ~$s$: $e$ >>
  | Sexpr loc [Slid _ "-"; se] ->
      let e = expr_se se in
      <:expr< - $e$ >>
  | Sexpr loc [Slid _ "if"; se; se1] ->
      let e = expr_se se in
      let e1 = expr_se se1 in
      <:expr< if $e$ then $e1$ else () >>
  | Sexpr loc [Slid _ "if"; se; se1; se2] ->
      let e = expr_se se in
      let e1 = expr_se se1 in
      let e2 = expr_se se2 in
      <:expr< if $e$ then $e1$ else $e2$ >>
  | Sexpr loc [Slid _ "cond" :: sel] ->
      loop sel where rec loop =
        fun
        [ [Sexpr loc [Slid _ "else" :: sel]] -> begin_se loc sel
        | [Sexpr loc [se1 :: sel1] :: sel] ->
            let e1 = expr_se se1 in
            let e2 = begin_se loc sel1 in
            let e3 = loop sel in
            <:expr< if $e1$ then $e2$ else $e3$ >>
        | [] -> <:expr< () >>
        | [se :: _] -> error se "cond clause" ]
  | Sexpr loc [Slid _ "while"; se :: sel] ->
      let e = expr_se se in
      let el = List.map expr_se sel in
      <:expr< while $e$ do { $list:el$ } >>
  | Sexpr loc [Slid _ "for"; Slid _ i; se1; se2 :: sel] ->
      let i = rename_id i in
      let e1 = expr_se se1 in
      let e2 = expr_se se2 in
      let el = List.map expr_se sel in
      <:expr< for $lid:i$ = $e1$ to $e2$ do { $list:el$ } >>
  | Sexpr loc [Slid _ "fordown"; Slid _ i; se1; se2 :: sel] ->
      let i = rename_id i in
      let e1 = expr_se se1 in
      let e2 = expr_se se2 in
      let el = List.map expr_se sel in
      <:expr< for $lid:i$ = $e1$ downto $e2$ do { $list:el$ } >>
  | Sexpr loc [Slid loc1 "lambda"] -> <:expr< fun [] >>
  | Sexpr loc [Slid loc1 "lambda"; sep :: sel] ->
      let e = begin_se loc1 sel in
      match ipatt_opt_se sep with
      [ Left p -> <:expr< fun $p$ -> $e$ >>
      | Right (se, sel) ->
          List.fold_right
            (fun se e ->
               let p = ipatt_se se in
               <:expr< fun $p$ -> $e$ >>)
            [se :: sel] e ]
  | Sexpr loc [Slid _ "lambda_match" :: sel] ->
      let pel = List.map (match_case loc) sel in
      <:expr< fun [ $list:pel$ ] >>
  | Sexpr loc [Slid _ ("let" | "letrec" as r) :: sel] ->
      match sel with
      [ [Sexpr _ sel1 :: sel2] ->
          let r = r = "letrec" in
          let lbs = List.map let_binding_se sel1 in
          let e = begin_se loc sel2 in
          <:expr< let $flag:r$ $list:lbs$ in $e$ >>
      | [Slid _ n; Sexpr _ sl :: sel] ->
          let n = rename_id n in
          let (pl, el) =
            List.fold_right
              (fun se (pl, el) ->
                 match se with
                 [ Sexpr _ [se1; se2] ->
                     ([patt_se se1 :: pl], [expr_se se2 :: el])
                 | se -> error se "named let" ])
              sl ([], [])
          in
          let e1 =
            List.fold_right (fun p e -> <:expr< fun $p$ -> $e$ >>) pl
              (begin_se loc sel)
          in
          let e2 =
            List.fold_left (fun e1 e2 -> <:expr< $e1$ $e2$ >>)
              <:expr< $lid:n$ >> el
          in
          <:expr< let rec $lid:n$ = $e1$ in $e2$ >>
      | [se :: _] -> error se "let_binding"
      | _ -> error_loc loc "let_binding" ]
  | Sexpr loc [Slid _ "let*" :: sel] ->
      match sel with
      [ [Sexpr _ sel1 :: sel2] ->
          List.fold_right
            (fun se ek ->
               let (p, e) = let_binding_se se in
               <:expr< let $p$ = $e$ in $ek$ >>)
            sel1 (begin_se loc sel2)
      | [se :: _] -> error se "let_binding"
      | _ -> error_loc loc "let_binding" ]
  | Sexpr loc [Slid _ "letmodule"; Suid _ s; se1; se2] ->
      let me = module_expr_se se1 in
      let e = expr_se se2 in
      <:expr< let module $s$ = $me$ in $e$ >>
  | Sexpr loc [Slid _ "match"; se :: sel] ->
      let e = expr_se se in
      let pel = List.map (match_case loc) sel in
      <:expr< match $e$ with [ $list:pel$ ] >>
  | Sexpr loc [Slid _ "parser" :: sel] ->
      let e =
        match sel with
        [ [(Slid _ _ as se) :: sel] ->
            let p = patt_se se in
            let pc = parser_cases_se loc sel in
            <:expr< let $p$ = Stream.count $lid:strm_n$ in $pc$ >>
        | _ -> parser_cases_se loc sel ]
      in
      <:expr< fun ($lid:strm_n$ : Stream.t _) -> $e$ >>
  | Sexpr loc [Slid _ "match_with_parser"; se :: sel] ->
      let me = expr_se se in
      let (bpo, sel) =
        match sel with
        [ [(Slid _ _ as se) :: sel] -> (Some (patt_se se), sel)
        | _ -> (None, sel) ]
      in
      let pc = parser_cases_se loc sel in
      let e =
        match bpo with
        [ Some bp -> <:expr< let $bp$ = Stream.count $lid:strm_n$ in $pc$ >>
        | None -> pc ]
      in
      match me with
      [ <:expr< $lid:x$ >> when x = strm_n -> e
      | _ -> <:expr< let ($lid:strm_n$ : Stream.t _) = $me$ in $e$ >> ]
  | Sexpr loc [Slid _ "try"; se :: sel] ->
      let e = expr_se se in
      let pel = List.map (match_case loc) sel in
      <:expr< try $e$ with [ $list:pel$ ] >>
  | Sexpr loc [Slid _ "begin" :: sel] ->
      let el = List.map expr_se sel in
      <:expr< do { $list:el$ } >>
  | Sexpr loc [Slid _ ":="; se1; se2] ->
      let e1 = expr_se se1 in
      let e2 = expr_se se2 in
      <:expr< $e1$ := $e2$ >>
  | Sarr loc sel ->
      let el = List.map expr_se sel in
      <:expr< [| $list:el$ |] >>
  | Sexpr loc [Slid _ "values" :: sel] ->
      let el = List.map expr_se sel in
      <:expr< ( $list:el$ ) >>
  | Srec loc [Slid _ "with"; se :: sel] ->
      let e = expr_se se in
      let lel = List.map (label_expr_se loc) sel in
      <:expr< { ($e$) with $list:lel$ } >>
  | Srec loc sel ->
      let lel = List.map (label_expr_se loc) sel in
      <:expr< { $list:lel$ } >>
  | Sexpr loc [Slid _ ":"; se1; se2] ->
      let e = expr_se se1 in
      let t = ctyp_se se2 in
      <:expr< ( $e$ : $t$ ) >>
  | Sexpr loc [se] ->
      let e = expr_se se in
      <:expr< $e$ () >>
  | Sexpr loc [Slid _ "assert"; se] ->
      let e = expr_se se in
      <:expr< assert $e$ >>
  | Sexpr loc [Slid _ "lazy"; se] ->
      let e = expr_se se in
      <:expr< lazy $e$ >>
  | Sexpr loc [se :: sel] ->
      List.fold_left
        (fun e se ->
           let e1 = expr_se se in
           <:expr< $e$ $e1$ >>)
        (expr_se se) sel
  | Slist loc sel ->
      loop sel where rec loop =
        fun
        [ [] -> <:expr< [] >>
        | [se1; Slid _ "."; se2] ->
            let e = expr_se se1 in
            let el = expr_se se2 in
            <:expr< [$e$ :: $el$] >>
        | [se :: sel] ->
            let e = expr_se se in
            let el = loop sel in
            <:expr< [$e$ :: $el$] >> ]
  | Squot loc typ txt -> Pcaml.handle_expr_quotation loc (typ, txt) ]
and begin_se loc =
  fun
  [ [] -> <:expr< () >>
  | [se] -> expr_se se
  | sel ->
      let el = List.map expr_se sel in
      let loc = Ploc.encl (loc_of_sexpr (List.hd sel)) loc in
      <:expr< do { $list:el$ } >> ]
and let_binding_se =
  fun
  [ Sexpr loc [se :: sel] ->
      let e = begin_se loc sel in
      match ipatt_opt_se se with
      [ Left p -> (p, e)
      | Right _ -> fun_binding_se se e ]
  | se -> error se "let_binding" ]
and fun_binding_se se e =
  match se with
  [ Sexpr _ [Slid _ "values" :: _] -> (ipatt_se se, e)
  | Sexpr _ [Slid loc s :: sel] ->
      let s = rename_id s in
      let e =
        List.fold_right
          (fun se e ->
             let loc = Ploc.encl (loc_of_sexpr se) (MLast.loc_of_expr e) in
             let p = ipatt_se se in
             <:expr< fun $p$ -> $e$ >>)
          sel e
      in
      let p = <:patt< $lid:s$ >> in
      (p, e)
  | _ -> (ipatt_se se, e) ]
and match_case loc =
  fun
  [ Sexpr loc [Sexpr _ [Slid _ "when"; se; sew] :: sel] ->
      (patt_se se, <:vala< (Some (expr_se sew)) >>, begin_se loc sel)
  | Sexpr loc [se :: sel] -> (patt_se se, <:vala< None >>, begin_se loc sel)
  | se -> error se "match_case" ]
and label_expr_se loc =
  fun
  [ Sexpr _ [se1; se2] -> (patt_se se1, expr_se se2)
  | se -> error se "label_expr" ]
and label_patt_se loc =
  fun
  [ Sexpr _ [se1; se2] -> (patt_se se1, patt_se se2)
  | se -> error se "label_patt" ]
and label_ipatt_se loc =
  fun
  [ Sexpr _ [se1; se2] -> (ipatt_se se1, ipatt_se se2)
  | se -> error se "label_ipatt" ]
and parser_cases_se loc =
  fun
  [ [] -> <:expr< raise Stream.Failure >>
  | [Sexpr loc [Sexpr _ spsel :: act] :: sel] ->
      let ekont _ = parser_cases_se loc sel in
      let act =
        match act with
        [ [se] -> expr_se se
        | [sep; se] ->
            let p = patt_se sep in
            let e = expr_se se in
            <:expr< let $p$ = Stream.count $lid:strm_n$ in $e$ >>
        | _ -> error_loc loc "parser_case" ]
      in
      stream_pattern_se loc act ekont spsel
  | [se :: _] -> error se "parser_case" ]
and stream_pattern_se loc act ekont =
  fun
  [ [] -> act
  | [se :: sel] ->
      let ckont err = <:expr< raise (Stream.Error $err$) >> in
      let skont = stream_pattern_se loc act ckont sel in
      stream_pattern_component skont ekont <:expr< "" >> se ]
and stream_pattern_component skont ekont err =
  fun
  [ Sexpr loc [Slid _ "`"; se :: wol] ->
      let wo =
        match wol with
        [ [se] -> Some (expr_se se)
        | [] -> None
        | _ -> error_loc loc "stream_pattern_component" ]
      in
      let e = peek_fun loc in
      let p = patt_se se in
      let j = junk_fun loc in
      let k = ekont err in
      <:expr< match $e$ $lid:strm_n$ with
               [ Some $p$ $opt:wo$ -> do { $j$ $lid:strm_n$ ; $skont$ }
               | _ -> $k$ ] >>
  | Sexpr loc [se1; se2] ->
      let p = patt_se se1 in
      let e =
        let e = expr_se se2 in
        <:expr< try Some ($e$ $lid:strm_n$) with [ Stream.Failure -> None ] >>
      in
      let k = ekont err in
      <:expr< match $e$ with [ Some $p$ -> $skont$ | _ -> $k$ ] >>
  | Sexpr loc [Slid _ "?"; se1; se2] ->
      stream_pattern_component skont ekont (expr_se se2) se1
  | Slid loc s ->
      let s = rename_id s in
      <:expr< let $lid:s$ = $lid:strm_n$ in $skont$ >>
  | se -> error se "stream_pattern_component" ]
and patt_se =
  fun
  [ Sacc loc se1 se2 ->
      let p1 = patt_se se1 in
      let p2 = patt_se se2 in
      <:patt< $p1$ . $p2$ >>
  | Slid loc "_" -> <:patt< _ >>
  | Slid loc s -> <:patt< $lid:(rename_id s)$ >>
  | Suid loc s -> <:patt< $uid:(rename_id s)$ >>
  | Sint loc s -> <:patt< $int:s$ >>
  | Sfloat loc s -> <:patt< $flo:s$ >>
  | Schar loc s -> <:patt< $chr:s$ >>
  | Sstring loc s -> <:patt< $str:s$ >>
  | Stid loc _ -> error_loc loc "patt"
  | Sqid loc _ -> error_loc loc "patt"
  | Srec loc sel ->
      let lpl = List.map (label_patt_se loc) sel in
      <:patt< { $list:lpl$ } >>
  | Sexpr loc [Slid _ ":"; se1; se2] ->
      let p = patt_se se1 in
      let t = ctyp_se se2 in
      <:patt< ($p$ : $t$) >>
  | Sexpr loc [Slid _ "or"; se :: sel] ->
      List.fold_left
        (fun p se ->
           let p1 = patt_se se in
           <:patt< $p$ | $p1$ >>)
        (patt_se se) sel
  | Sexpr loc [Slid _ "range"; se1; se2] ->
      let p1 = patt_se se1 in
      let p2 = patt_se se2 in
      <:patt< $p1$ .. $p2$ >>
  | Sarr loc sel ->
      let pl = List.map patt_se sel in
      <:patt< [| $list:pl$ |] >>
  | Sexpr loc [Slid _ "values" :: sel] ->
      let pl = List.map patt_se sel in
      <:patt< ( $list:pl$ ) >>
  | Sexpr loc [Slid _ "as"; se1; se2] ->
      let p1 = patt_se se1 in
      let p2 = patt_se se2 in
      <:patt< ($p1$ as $p2$) >>
  | Sexpr loc [se :: sel] ->
      List.fold_left
        (fun p se ->
           let p1 = patt_se se in
           <:patt< $p$ $p1$ >>)
        (patt_se se) sel
  | Sexpr loc [] -> <:patt< () >>
  | Slist loc sel ->
      loop sel where rec loop =
        fun
        [ [] -> <:patt< [] >>
        | [se1; Slid _ "."; se2] ->
            let p = patt_se se1 in
            let pl = patt_se se2 in
            <:patt< [$p$ :: $pl$] >>
        | [se :: sel] ->
            let p = patt_se se in
            let pl = loop sel in
            <:patt< [$p$ :: $pl$] >> ]
  | Squot loc typ txt -> Pcaml.handle_patt_quotation loc (typ, txt) ]
and ipatt_se se =
  match ipatt_opt_se se with
  [ Left p -> p
  | Right (se, _) -> error se "ipatt" ]
and ipatt_opt_se =
  fun
  [ Slid loc "_" -> Left <:patt< _ >>
  | Slid loc s -> Left <:patt< $lid:(rename_id s)$ >>
  | Stid loc s -> Left <:patt< ~$(rename_id s)$ >>
  | Sqid loc s -> Left <:patt< ?$(rename_id s)$ >>
  | Sexpr loc [Sqid _ s; se] ->
      let s = rename_id s in
      let e = expr_se se in
      Left <:patt< ? ( $lid:s$ = $e$ ) >>
  | Sexpr loc [Slid _ ":"; se1; se2] ->
      let p = ipatt_se se1 in
      let t = ctyp_se se2 in
      Left <:patt< ($p$ : $t$) >>
  | Sexpr loc [Slid _ "as"; se1; se2] ->
      let p1 = ipatt_se se1 in
      let p2 = ipatt_se se2 in
      Left <:patt< ($p1$ as $p2$) >>
  | Sexpr loc [Slid _ "values" :: sel] ->
      let pl = List.map ipatt_se sel in
      Left <:patt< ( $list:pl$ ) >>
  | Srec loc sel ->
      let lpl = List.map (label_ipatt_se loc) sel in
      Left <:patt< { $list:lpl$ } >>
  | Sexpr loc [] -> Left <:patt< () >>
  | Sexpr loc [se :: sel] -> Right (se, sel)
  | se -> error se "ipatt" ]
and type_declaration_se =
  fun
  [ Sexpr loc [se1; se2] ->
      let (n1, loc1, tpl) =
        match se1 with
        [ Sexpr _ [Slid loc n :: sel] ->
            (n, loc, List.map type_parameter_se sel)
        | Slid loc n -> (n, loc, [])
        | se -> error se "type declaration" ]
      in
      {MLast.tdNam = (loc1, <:vala< n1 >>); MLast.tdPrm = <:vala< tpl >>;
       MLast.tdPrv = <:vala< False >>; MLast.tdDef = ctyp_se se2;
       MLast.tdCon = <:vala< [] >>}
  | se -> error se "type_declaration" ]
and type_declaration_list_se =
  fun
  [ [se1; se2 :: sel] ->
      let (n1, loc1, tpl) =
        match se1 with
        [ Sexpr _ [Slid loc n :: sel] ->
            (n, loc, List.map type_parameter_se sel)
        | Slid loc n -> (n, loc, [])
        | se -> error se "type declaration" ]
      in
      let td =
        {MLast.tdNam = (loc1, <:vala< n1 >>); MLast.tdPrm = <:vala< tpl >>;
         MLast.tdPrv = <:vala< False >>; MLast.tdDef = ctyp_se se2;
         MLast.tdCon = <:vala< [] >>}
      in
      [td :: type_declaration_list_se sel]
  | [] -> []
  | [se :: _] -> error se "type_declaration" ]
and type_parameter_se =
  fun
  [ Slid _ s when String.length s >= 2 && s.[0] = ''' ->
      let s = String.sub s 1 (String.length s - 1) in
      (<:vala< s >>, (False, False))
  | se -> error se "type_parameter" ]
and ctyp_se =
  fun
  [ Slist loc sel ->
      let cdl = List.map constructor_declaration_se sel in
      <:ctyp< [ $list:cdl$ ] >>
  | Srec loc sel ->
      let ldl = List.map label_declaration_se sel in
      <:ctyp< { $list:ldl$ } >>
  | Sexpr loc [Slid _ "->" :: ([_; _ :: _] as sel)] ->
      loop sel where rec loop =
        fun
        [ [] -> assert False
        | [se] -> ctyp_se se
        | [se :: sel] ->
            let t1 = ctyp_se se in
            let loc = Ploc.encl (loc_of_sexpr se) loc in
            let t2 = loop sel in
            <:ctyp< $t1$ -> $t2$ >> ]
  | Sexpr loc [Slid _ "*" :: sel] ->
      let tl = List.map ctyp_se sel in
      <:ctyp< ($list:tl$) >>
  | Sexpr loc [Slid _ "=="; se1; se2] ->
      let t1 = ctyp_se se1 in
      let t2 = ctyp_se se2 in
      <:ctyp< $t1$ == $t2$ >>
  | Sexpr loc [se :: sel] ->
      List.fold_left
        (fun t se ->
           let t2 = ctyp_se se in
           <:ctyp< $t$ $t2$ >>)
        (ctyp_se se) sel
  | Sacc loc se1 se2 ->
      let t1 = ctyp_se se1 in
      let t2 = ctyp_se se2 in
      <:ctyp< $t1$ . $t2$ >>
  | Slid loc "_" -> <:ctyp< _ >>
  | Slid loc s ->
      if s.[0] = ''' then
        let s = String.sub s 1 (String.length s - 1) in
        <:ctyp< '$s$ >>
      else <:ctyp< $lid:(rename_id s)$ >>
  | Suid loc s -> <:ctyp< $uid:(rename_id s)$ >>
  | se -> error se "ctyp" ]
and constructor_declaration_se =
  fun
  [ Sexpr loc [Suid _ ci :: sel] ->
      (loc, <:vala< (rename_id ci) >>, <:vala< (List.map ctyp_se sel) >>)
  | se -> error se "constructor_declaration" ]
and label_declaration_se =
  fun
  [ Sexpr loc [Slid _ lab; Slid _ "mutable"; se] ->
      (loc, rename_id lab, True, ctyp_se se)
  | Sexpr loc [Slid _ lab; se] -> (loc, rename_id lab, False, ctyp_se se)
  | se -> error se "label_declaration" ]
;

value directive_se =
  fun
  [ Sexpr _ [Slid _ s] -> (s, None)
  | Sexpr _ [Slid _ s; se] ->
      let e = expr_se se in
      (s, Some e)
  | se -> error se "directive" ]
;

(* Parser *)

Pcaml.syntax_name.val := "Scheme";
Pcaml.no_constructors_arity.val := False;

do {
  Grammar.Unsafe.gram_reinit gram (lexer_gmake ());
  Grammar.Unsafe.clear_entry interf;
  Grammar.Unsafe.clear_entry implem;
  Grammar.Unsafe.clear_entry top_phrase;
  Grammar.Unsafe.clear_entry use_file;
  Grammar.Unsafe.clear_entry module_type;
  Grammar.Unsafe.clear_entry module_expr;
  Grammar.Unsafe.clear_entry sig_item;
  Grammar.Unsafe.clear_entry str_item;
  Grammar.Unsafe.clear_entry expr;
  Grammar.Unsafe.clear_entry patt;
  Grammar.Unsafe.clear_entry ctyp;
  Grammar.Unsafe.clear_entry let_binding;
  Grammar.Unsafe.clear_entry type_declaration;
  Grammar.Unsafe.clear_entry class_type;
  Grammar.Unsafe.clear_entry class_expr;
  Grammar.Unsafe.clear_entry class_sig_item;
  Grammar.Unsafe.clear_entry class_str_item
};

Pcaml.parse_interf.val := Grammar.Entry.parse interf;
Pcaml.parse_implem.val := Grammar.Entry.parse implem;

value sexpr = Grammar.Entry.create gram "sexpr";

EXTEND
  GLOBAL: implem interf top_phrase use_file str_item sig_item expr patt sexpr;
  implem:
    [ [ "#"; se = sexpr ->
          let (n, dp) = directive_se se in
          ([(<:str_item< # $lid:n$ $opt:dp$ >>, loc)], True)
      | si = str_item; x = SELF ->
          let (sil, stopped) = x in
          let loc = MLast.loc_of_str_item si in
          ([(si, loc) :: sil], stopped)
      | EOI -> ([], False) ] ]
  ;
  interf:
    [ [ "#"; se = sexpr ->
          let (n, dp) = directive_se se in
          ([(<:sig_item< # $lid:n$ $opt:dp$ >>, loc)], True)
      | si = sig_item; x = SELF ->
          let (sil, stopped) = x in
          let loc = MLast.loc_of_sig_item si in
          ([(si, loc) :: sil], stopped)
      | EOI -> ([], False) ] ]
  ;
  top_phrase:
    [ [ "#"; se = sexpr ->
          let (n, dp) = directive_se se in
          Some <:str_item< # $lid:n$ $opt:dp$ >>
      | se = sexpr -> Some (str_item_se se)
      | EOI -> None ] ]
  ;
  use_file:
    [ [ "#"; se = sexpr ->
          let (n, dp) = directive_se se in
          ([<:str_item< # $lid:n$ $opt:dp$ >>], True)
      | si = str_item; x = SELF ->
          let (sil, stopped) = x in
          ([si :: sil], stopped)
      | EOI -> ([], False) ] ]
  ;
  str_item:
    [ [ se = sexpr -> str_item_se se
      | e = expr -> <:str_item< $exp:e$ >> ] ]
  ;
  sig_item:
    [ [ se = sexpr -> sig_item_se se ] ]
  ;
  expr:
    [ "top"
      [ se = sexpr -> expr_se se ] ]
  ;
  patt:
    [ [ se = sexpr -> patt_se se ] ]
  ;
  sexpr:
    [ [ se1 = SELF; DOT; se2 = SELF -> Sacc loc se1 se2 ]
    | [ "("; sl = LIST0 sexpr; ")" -> Sexpr loc sl
      | "["; sl = LIST0 sexpr; "]" -> Slist loc sl
      | "{"; sl = LIST0 sexpr; "}" -> Srec loc sl
      | "#("; sl = LIST0 sexpr; ")" -> Sarr loc sl
      | a = pa_extend_keyword -> Slid loc a
      | s = LIDENT -> Slid loc s
      | s = UIDENT -> Suid loc s
      | s = TILDEIDENT -> Stid loc s
      | s = QUESTIONIDENT -> Sqid loc s
      | s = INT -> Sint loc s
      | s = FLOAT -> Sfloat loc s
      | s = CHAR -> Schar loc s
      | s = STRING -> Sstring loc s
      | s = SPACEDOT -> Slid loc "."
      | s = QUOT ->
          let i = String.index s ':' in
          let typ = String.sub s 0 i in
          let txt = String.sub s (i + 1) (String.length s - i - 1) in
          Squot loc typ txt
      | NL; s = SELF -> s
      | NL -> raise Stream.Failure ] ]
  ;
  pa_extend_keyword:
    [ [ "_" -> "_"
      | "," -> ","
      | "=" -> "="
      | ":" -> ":"
      | "/" -> "/"
      | "#" -> "#" ] ]
  ;
END;
