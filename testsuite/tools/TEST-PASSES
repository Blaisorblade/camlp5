#!/usr/bin/perl

use strict ;
use Data::Dumper ;
use Carp::Assert ;
use File::Basename;
use File::Find ;
use File::Spec ;
use File::stat ;
use Getopt::Long;
use IPC::System::Simple qw(systemx runx capturex $EXITVAL);
use String::ShellQuote ;
use YAML::Tiny;

our $quiet = 0 ;
our $verbose = 0 ;
our @verbose_passthru = () ;
our $preserve = 0 ;
our $continue_error = 0 ;
our @dopackages ;
our @onlyfiles ;
our $tool ;
our $tool1 ;
our $tool2 ;
our $packages_file ;
our $profile_file ;

# step takes as arguments:
#
# (1) 'input-filename': input filename
# (2) 'base-name': base-name for this step (so it can construct its own filenames)
#     THIS NAME is for this step only
# (3) 'step-number': step-number in sequence
#     so the files it constructs will be <base-name>.<number>
# (4) 'step-name'
# (5) 'output-filename': the output filename
# (6) 'file-type': "-intf" or "-impl" -- suitable for passing to ocaml/camlp5 tools.
#
# RETURNS: code -- typically zero, but maybe nonzero to indicate error

our %tools = (
  'roundtrip-revised' =>
  {
    'name' => 'roundtrip-revised',
    'command' => sub {
      my %args = @_ ;
      my $inputf = $args{'input-filename'} ;
      my $outputf = $args{'output-filename'} ;
      my $filetype = $args{'file-type'} ;
      
      my $code = v_systemx([0..2], 'tools/ROUNDTRIP-pa_r-pr_r', $filetype, $inputf, $outputf) ;
      return $code ;
    },
  },

  'roundtrip-official' =>
  {
    'name' => 'roundtrip-official',
    'command' => sub {
      my %args = @_ ;
      my $inputf = $args{'input-filename'} ;
      my $outputf = $args{'output-filename'} ;
      my $filetype = $args{'file-type'} ;
      
      my $code = v_systemx([0..2], 'tools/ROUNDTRIP-pa_o-pr_official', $filetype, $inputf, $outputf) ;
      return $code ;
    },
  },

  'roundtrip-original' =>
  {
    'name' => 'roundtrip-original',
    'command' => sub {
      my %args = @_ ;
      my $inputf = $args{'input-filename'} ;
      my $outputf = $args{'output-filename'} ;
      my $filetype = $args{'file-type'} ;
      
      my $code = v_systemx([0..2], 'tools/ROUNDTRIP-pa_o-pr_o', $filetype, $inputf, $outputf) ;
      return $code ;
    },
  },

  'roundtrip-original-streams' =>
  {
    'name' => 'roundtrip-original-streams',
    'command' => sub {
      my %args = @_ ;
      my $inputf = $args{'input-filename'} ;
      my $outputf = $args{'output-filename'} ;
      my $filetype = $args{'file-type'} ;
      
      my $code = v_systemx([0..2], 'tools/ROUNDTRIP-pa_op-pr_op', $filetype, $inputf, $outputf) ;
      return $code ;
    },
  },

  'cp' =>
  {
    'name' => 'cp',
    'command' => sub {
      my %args = @_ ;
      my $inputf = $args{'input-filename'} ;
      my $outputf = $args{'output-filename'} ;
      
      my $code = v_systemx([0..2], "cp", $inputf, $outputf) ;
      return $code ;
    },
  },

  'cowardly-comment-stripper' => {
    'name' => 'cowardly-comment-stripper',
	'command' => sub {
	  my %args = @_ ;
	  my $inputf = $args{'input-filename'} ;
	  my $outputf = $args{'output-filename'} ;

	  my $txt = f_read($inputf) ;
	  $txt =~ s|\(\*.*?\*\)| onlynl($&) |gse ;
	  f_write($outputf, $txt) ;
	  return 0 ;
    },
  },

  'nuke:multi-semi:declare-end:directives' => {
    'name' => 'nuke:multi-semi:declare-end:directives',
	'command' => sub {
	  my %args = @_ ;
	  my $inputf = $args{'input-filename'} ;
	  my $outputf = $args{'output-filename'} ;

	  my $txt = f_read($inputf) ;
	  $txt =~ s|^#load.*$||gm ;
	  $txt =~ s,declare end;,,gm ;
	  $txt =~ s,;(?:\s*;)*,;,gs ;
	  f_write($outputf, $txt) ;
	  return 0 ;
    },
  },

  'nuke:ending-double-semi' => {
    'name' => 'nuke:ending-double-semi',
	'command' => sub {
	  my %args = @_ ;
	  my $inputf = $args{'input-filename'} ;
	  my $outputf = $args{'output-filename'} ;

	  my $txt = f_read($inputf) ;
	  $txt =~ s,;;$,,gm ;
	  f_write($outputf, $txt) ;
	  return 0 ;
    },
  },

  'nuke:mli-ending-double-semi' => {
    'name' => 'nuke:mli-ending-double-semi',
	'command' => sub {
	  my %args = @_ ;
	  my $inputf = $args{'input-filename'} ;
	  my $outputf = $args{'output-filename'} ;
	  my $filetype = $args{'file-type'} ;

	  my $txt = f_read($inputf) ;
	  $txt =~ s,;;$,,gm if $filetype eq '-intf' ;
	  $txt =~ s,;;(\s*\(\*)?,$1,gs ;
	  f_write($outputf, $txt) ;
	  return 0 ;
    },
  },

  'cowardly-arrow' => {
    'name' => 'cowardly-arrow',
	'command' => sub {
	  my %args = @_ ;
	  my $inputf = $args{'input-filename'} ;
	  my $outputf = $args{'output-filename'} ;

	  my $txt = f_read($inputf) ;
	  $txt =~ s,â†’,->,gs ;
	  f_write($outputf, $txt) ;
	  return 0 ;
    },
  },

  'lexer-passthru' => {
    'name' => 'lexer-passthru',
	'command' => sub {
	  my %args = @_ ;
	  my $inputf = $args{'input-filename'} ;
	  my $outputf = $args{'output-filename'} ;

	  my $code = v_systemx([0..2], "./roundtrip_lexer.byte","-mode","lexer-passthru", $inputf, $outputf) ;
	  return $code ;
    },
  },

  'lexer-pa-pr' => {
    'name' => 'lexer-pa-pr',
	'command' => sub {
	  my %args = @_ ;
	  my $inputf = $args{'input-filename'} ;
	  my $outputf = $args{'output-filename'} ;

	  my $code = v_systemx([0..2], "./roundtrip_lexer.byte","-mode","parse-pp", $inputf, $outputf) ;
	  return $code ;
    },
  },

  'ifdef-eval' => {
    'name' => 'ifdef-eval',
	'command' => sub {
	  my %args = @_ ;
	  my $inputf = $args{'input-filename'} ;
	  my $outputf = $args{'output-filename'} ;

	  my $code = v_systemx([0..2], "./roundtrip_lexer.byte","-D", "STRICT", "-mode","ifdef-eval", $inputf, $outputf) ;
	  return $code ;
    },
  },
    ) ;

{
  GetOptions(
    "tool=s" => \$tool,
    "tool1=s" => \$tool1,
    "tool2=s" => \$tool2,
    "package=s{}" => \@dopackages,
    "only-files=s{}" => \@onlyfiles,
    "quiet" => \$quiet,
    "verbose" => \$verbose,
    "preserve" => \$preserve,
    "continue-on-error" => \$continue_error,
    "packages-file=s" => \$packages_file,
    "profile-file=s" => \$profile_file,
      )
      or die("Error in command line arguments\n");

  @verbose_passthru = ("--verbose") if $verbose ;

  $quiet = 0 if $verbose ;

  die "must specify packages-file"
      unless defined $packages_file ;

  my %packages ;
  {
    my $yaml = YAML::Tiny->read($packages_file) ;
    %packages = %{ $yaml->[0] } ;
  }

  if ($ARGV[0] eq 'override-file') {
    shift @ARGV ;
    die "tool $tool not recognized"
	unless $tool eq 'ALL' || exists $tools{$tool} ;

    die "must specify a single package"
	unless 1 == int(@dopackages) ;
    die "must specify files"
	unless int(@onlyfiles) || int(@ARGV) ;

    foreach my $file (@ARGV, @onlyfiles) {
      my $pkgna = $dopackages[0] ;
      my $pkgh = $packages{$pkgna} ;
      my %pkg = %{ $pkgh };

      my $fullsrcname = "$pkg{'location'}/$file" ;
      die "file $file in package $pkg{'package'} does not exist ($fullsrcname)"
	  unless (-r $fullsrcname) ;
      my $bangf = $file ;
      $bangf =~ s,/,!,g ;
      my $inputname = "patches/$pkg{'package'}/$tool/$bangf.INPUT" ;
      die "overridden input file $inputname already exists"
	  unless (!(-r $inputname)) ;

      v_systemx("mkdir", "-p", "patches/$pkg{'package'}/$tool") ;
      v_systemx("cp", $fullsrcname, $inputname) ;
    }
  }
  elsif ($ARGV[0] eq 'override-to-patch') {
    shift @ARGV ;
    die "tool $tool not recognized"
	unless $tool eq 'ALL' || exists $tools{$tool} ;

    die "must specify a single package"
	unless 1 == int(@dopackages) ;
    die "must specify files"
	unless int(@onlyfiles) || int(@ARGV) ;

    foreach my $file (@ARGV, @onlyfiles) {
      my $pkgna = $dopackages[0] ;
      my $pkgh = $packages{$pkgna} ;
      my %pkg = %{ $pkgh };

      my $fullsrcname = "$pkg{'location'}/$file" ;
      die "file $file in package $pkg{'package'} does not exist ($fullsrcname)"
	  unless (-r $fullsrcname) ;
      my $bangf = $file ;
      $bangf =~ s,/,!,g ;
      my $inputname = "patches/$pkg{'package'}/$tool/$bangf.INPUT" ;
      die "overridden input file $inputname does not exist"
	  unless (-r $inputname) ;

      my $patchname = "patches/$pkg{'package'}/$tool/$bangf.PATCH" ;
      die "patch file $patchname alrady exists"
	  unless (!(-r $patchname)) ;

      my $diff_output = v_capturex([1], "diff", "-Bwiu", $fullsrcname, $inputname) ;
      f_write($patchname, $diff_output) ;
      v_systemx("mv",$inputname,"$inputname-MOVED") ;
    }
  }
  else {
    die "must specify profile-file"
	unless defined $profile_file ;

    my %profile ;
    {
      my $yaml = YAML::Tiny->read($profile_file) ;
      %profile = %{ $yaml->[0] } ;
    }

    my $workdir = "workdir" ;

    foreach my $recna (keys %{ $profile{'recipes'} }) {
      my %recipe = %{ $profile{'recipes'}->{$recna} } ;
      foreach my $t (@{ $recipe{'steps'} }) {
	die "unrecognized step $t" unless exists $tools{$t} ;
      }
    }

    push(@dopackages, @ARGV) ;

    die "must specify packages" unless @dopackages ;

    foreach my $pkgna (@dopackages) {
      die "package $pkgna not recognized"
	  unless exists $packages{$pkgna} ;
    }

    if (@onlyfiles) {
      die "can only specify a single package if also specifying --only-files"
	  unless 1 == int(@dopackages) ;
    }

    foreach my $pkgna (@dopackages) {
      my $pkgh = $packages{$pkgna} ;
      $pkgh->{'onlyfiles'} = [ @onlyfiles ] if @onlyfiles ; 
      runtest_package($workdir,
		      \%profile,
		      $pkgh);
    }
  }
}

sub runtest_package {
  my $workroot = shift ;
  my $profh = shift ;
  my $pkgh = shift ;

  my %profile = %{ $profh } ;
  my %pkg = %{ $pkgh };
  my $location = $pkg{'location'} ;
  my $workdir = $workroot."/".$pkg{'package'} ;
  my @dirs = @{ $pkg{'dirs'} };
  my @files = @{  $pkg{'files'} } ;

  my %onlyfiles ;
  {
    my @l = () ;
    push (@l, @{ $pkg{'onlyfiles'} })
	if (exists $pkg{'onlyfiles'}) ;
    foreach my $f (@l) {
      $onlyfiles{$f} = 1 ;
    }
  }

  my %used_steps = () ;
  foreach my $recna (keys %{ $profile{'recipes'} }) {
    my @l = @{ $profile{'recipes'}->{$recna}->{'steps'} } ;
    foreach my $s (@l) { $used_steps{$s} = 1 ; }
  }

  my %exclude ;
  {
    my @l = () ;
    foreach my $stepna (keys %used_steps) {
      next unless exists $pkg{'exclude'}->{$stepna};

      push (@l, @{ $pkg{'exclude'}->{$stepna} }) ;
    }

    foreach my $f (@l) {
      $exclude{$f} = 1 ;
    }
  }

  foreach my $recna (keys %{ $profile{'recipes'} }) {
    v_systemx("rm", "-rf", "$workdir/$recna") ;
    v_systemx("mkdir", "-p", "$workdir/$recna") ;
  }

  {
    my @newfiles ;
    my $perfile = sub {
      my $f = $File::Find::name ;
      if ($f =~ /\.ml$/ || $f =~ /\.mli$/) {
	push(@newfiles, $f) ;
      }
    } ;

    find( { wanted => $perfile, no_chdir => 1 }, 
	  (map { $location."/".$_ } @dirs) ) ;

    @newfiles = map { $_ =~ s,^$location/,,; $_ } @newfiles ;

    push(@files, @newfiles) ;
  }

  foreach my $f (@files) {
    next if exists $exclude{$f} && !int(%onlyfiles);
    next if int(%onlyfiles) && !(exists $onlyfiles{$f}) ;

    print "==== $f ====\n" unless $main::quiet;
    my $bangf = $f ;
    $bangf =~ s,/,!,g ;
    my $filetype ;
    if ($f =~ /\.mli$/) { $filetype = "-intf" ; }
    elsif ($f =~ /\.ml$/) { $filetype = "-impl" ; }
    else { die "unrecognized filetype $f" ; }

    my @generated_files = () ;
    my $origf = "$location/".$f ;

    # so we know if any step failed
    my $failure = 0 ;

    my %recipe_outputs ;
    my @recipes = keys %{ $profile{'recipes'} } ;
    RECIPE: foreach my $recna (@recipes) {
      my %recipe = %{ $profile{'recipes'}->{$recna} } ;
      my $recbase = "$workdir/$recna/".$bangf ;
      my @steps = @{ $recipe{'steps'} } ;

      print "== $f : recipe $recna\n" unless $main::quiet;
    
      my $inputf = "$recbase.0-$steps[0].INPUT" ;
      generate_input(
	'input-filename' => $origf ,
	'output-filename' => $inputf ,
	'recipe-name' => $recna,
	'escaped-filename' => $bangf,
	'patch-directory' => "patches",
	'package-name' => $pkg{'package'},
	  ) ;

      for (my $stepi = 0 ; $stepi < @steps ; $stepi++) {
	my $stepname = $steps[$stepi] ;
	my $stepbase = "$recbase.$stepi-$stepname" ;
	my $outputf = $stepbase.".OUTPUT" ;
	
	my $tool = $tools{$stepname} ;
	my $code = &{ $tool->{'command'} }(
	  'input-filename' => $inputf ,
	  'output-filename' => $outputf ,
	  'base-name' => $stepbase ,
	  'step-number' => $stepi ,
	  'step-name' => $stepname ,
	  'file-type' => $filetype ,
	) ;

	if ($code != 0) {
	  warn "aborting processing of $f recipe $recna at step $stepname: $@" ;
	  if ($main::continue_error) {
	    delete $recipe_outputs{$recna} ;
	    $failure = 1 ;
	    next RECIPE;
	  }
	  else {
	    die "aborting entire test" ;
	  }
	}
	# setup for next step
	$inputf = $outputf;
	$recipe_outputs{$recna} = $outputf ;
      }
      push(@generated_files, <$recbase.*>) ;
    }

    assert (2 == @recipes) ;
    my ($rec1name, $rec2name) = sort @recipes ;
    my $errordir = "$workdir/$rec1name!$rec2name.ERRORS" ;
    v_systemx("mkdir", "-p", $errordir) ;
    my $errorbase = "$errordir/$bangf" ;
    my $preserve = $main::preserve || int(%onlyfiles) ;
    my $code = extended_diff($recipe_outputs{$rec1name}, $recipe_outputs{$rec2name},
	'errorbase' => $errorbase,
        'generated-files' => \@generated_files,
        'preserve' => \$preserve,
	) ;
    if (0 == $code) {
      print "OK $f\n" unless $main::quiet ;
      if (!$preserve) {
	v_systemx("rm", "-f", @generated_files);
      }
    } else {
      print "NOT OK $f\n";
      die "stopping due to errors in $f" unless $main::continue_error ;
    }
  }
}

# if there is both a PATCH and an INPUT file, that's a crash-error
# if there is a PATCH/INPUT for this recipe, use it
# if not and there is one for ALL recipes, use that
# otherwise, return the original input-filename.
sub generate_input {
  my %args = @_ ;
  my $inputf = $args{'input-filename'} ;
  my $outputf = $args{'output-filename'} ;
  my $recna = $args{'recipe-name'} ;
  my $escf = $args{'escaped-filename'} ;
  my $patchdir = $args{'patch-directory'} ;
  my $pkgna = $args{'package-name'} ;
  
  my $all_input = "$patchdir/$pkgna/ALL/$escf.INPUT" ;
  my $all_patch = "$patchdir/$pkgna/ALL/$escf.PATCH" ;

  my $recipe_input = "$patchdir/$pkgna/$recna/$escf.INPUT" ;
  my $recipe_patch = "$patchdir/$pkgna/$recna/$escf.PATCH" ;

  die "both PATCH & INPUT exist for package=$pkgna recipe=ALL file=$inputf"
      if ((-r $all_input) && (-r $all_patch)) ;

  die "both PATCH & INPUT exist for package=$pkgna recipe=$recna file=$inputf"
      if ((-r $recipe_input) && (-r $recipe_patch)) ;

  v_systemx([0], "cp", $inputf, $outputf) ;

  my @silent ;
  push(@silent, "-s") unless $main::verbose ;

  if (-r $recipe_patch) {
    v_systemx([0], "patch", @silent, $outputf, $recipe_patch) ;
  }
  elsif (-r $recipe_input) {
    v_systemx([0], "cp", $recipe_input, $outputf) ;
  }
  elsif (-r $all_patch) {
    v_systemx([0], "patch", @silent, $outputf, $all_patch) ;
  }
  elsif (-r $all_input) {
    v_systemx([0], "cp", $all_input, $outputf) ;
  }
}

sub extended_diff {
  my $f1 = shift ;
  my $f2 = shift ;
  my %args = @_ ;

  my @cmd = ("diff", "-Bwiu", $f1, $f2) ;
  my $diff_output = v_capturex([0..1], @cmd) ;
  my $diff_ok = (0 == $EXITVAL) ;

  my $wdiff_output = v_capturex([0..1], "wdiff", "-3", $f1, $f2) ;
  my $wdiff_full_output = v_capturex([0..1], "wdiff", $f1, $f2) ;
  my $wdiff_ok = (0 == $EXITVAL) ;

  if (exists $args{'errorbase'}) {
    f_write("$args{'errorbase'}.DIFF", $diff_output) ;
    f_write("$args{'errorbase'}.WDIFF", $wdiff_output) ;
    f_write("$args{'errorbase'}.WDIFF-FULL", $wdiff_full_output) ;
    push(@{ $args{'generated-files'} }, "$args{'errorbase'}.DIFF", "$args{'errorbase'}.WDIFF", "$args{'errorbase'}.WDIFF-FULL") ;
  }

  my $wordeq_ok = wordeq($f1, $f2, 'generated-files' => $args{'generated-files'}) ;

  if ($diff_ok) { return 0 ; }

  if ($wdiff_ok) {
    print "== $f1 <-> $f2\n" unless $main::quiet ;
    print "WDIFF SAYS OK\n" unless $main::quiet ;
    ${ $args{'preserve'} } = 1 ;
    return 0 ;
  }
  if ($wordeq_ok) {
    print "== $f1 <-> $f2\n" unless $main::quiet ;
    print "WHITE SPACE DIFFERENCES from wordeq\n" unless $main::quiet ;
    ${ $args{'preserve'} } = 1 ;
    return 0 ;
  }

  print $diff_output ;
  return 1 ;
}

sub wordeq {
  my $f1 = shift ;
  my $f2 = shift ;
  my %args = @_ ;

  my $txt1 = f_read($f1) ;
  my $txt2 = f_read($f2) ;

  $txt1 =~ s,\s,,gs ;
  $txt2 =~ s,\s,,gs ;
  if ($txt1 eq $txt2) {
    return 1 ;
  }
  else {
    f_write("$f1.NO-WS", $txt1) ;
    f_write("$f2.NO-WS", $txt2) ;
    push(@{ $args{'generated-files'} }, "$f1.NO-WS", "$f2.NO-WS") ;

    return 0 ;
  }
}

sub runtool {
  my %args = @_ ;
  my $tool = $args{'tool'} ;
  my $srcf = $args{'src-filename'} ;
  my $dstf = $args{'dst-filename'} ;

  print "$tool->{'name'}: $srcf -> $dstf\n" if $main::verbose ;
  my @cmd = &{ $tool->{'command'}, }($srcf, $dstf) ;
  my $code = v_systemx([0..2], @cmd) ;
  if ($code != 0) {
    if (!$continue_error) {
      die ("command <<".join(' ', @cmd).">> died with $@") ;
    }
    else {
      warn ("command <<".join(' ', @cmd).">> died with $@") ;
      return $code ;
    }
  }
  return 0 ;
}

sub v_systemx {
  my $codes ;
  $codes = shift if (ref($_[0]) eq 'ARRAY') ;
  my @cmd = @_ ;
  print STDERR join(' ', map { shell_quote($_) } @cmd)."\n" if ($main::verbose) ;

  if ($codes) {
    return runx($codes, @cmd) ;
  }
  else {
    return runx(@cmd) ;
  }
}

sub v_capturex {
  my $codes ;
  $codes = shift if (ref($_[0]) eq 'ARRAY') ;
  my @cmd = @_ ;
  print STDERR join(' ', map { shell_quote($_) } @cmd)."\n" if ($main::verbose) ;

  if ($codes) {
    return capturex($codes, @cmd) ;
  }
  else {
    return capturex(@cmd) ;
  }
}

sub v_system {
  my $cmd = shift;
  print STDERR "<<$cmd>>\n" if ($main::verbose);
  system $cmd;
}

sub onlynl {
  my $s = shift ;
  $s =~ s,[^\n],,gs;
  return $s;
}

sub f_read {
  my $f = shift;
  open(F,"<$f") || die "cannot open $f for reading";
  my @l = <F>;
  close(F);
  return (wantarray ? @l : join('', @l)) ;
}

sub f_write {
  my $f = shift;
  open(F,">$f") || die "cannot open $f for writing";
  print F @_;
  close(F);
}
