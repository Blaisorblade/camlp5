#!/usr/bin/perl

use strict ;
use Data::Dumper ;
use Carp::Assert ;
use File::Basename;
use File::Find ;
use File::Spec ;
use File::stat ;
use Getopt::Long;
use IPC::System::Simple qw(systemx runx capturex $EXITVAL);
use String::ShellQuote ;
use YAML::Tiny;

our $verbose = 0 ;
our $preserve = 0 ;
our $continue_error = 0 ;
our @dopackages ;
our @onlyfiles ;
our $tool ;
our $tool1 ;
our $tool2 ;
our $packages_file ;

our %tools = (
  'roundtrip-revised' =>
  {
    'name' => 'roundtrip-revised',
	'command' => sub {
	  return ('tools/ROUNDTRIP-pa_r-pr_r', @_) ;
    },
  },

  'roundtrip-original' =>
  {
    'name' => 'roundtrip-original',
	'command' => sub {
	  return ('tools/ROUNDTRIP-pa_o-pr_o', @_) ;
    },
  },


  'roundtrip-original-streams' =>
  {
    'name' => 'roundtrip-original-streams',
	'command' => sub {
	  return ('tools/ROUNDTRIP-pa_op-pr_op', @_) ;
    },
  },

  'cp' =>
  {
    'name' => 'cp',
	'command' => sub {
	  return ('/bin/cp', @_) ;
    },
  },

  'lexer-passthru' => {
    'name' => 'lexer-passthru',
	'command' => sub {
	  return ("./roundtrip_lexer.byte","-mode","lexer-passthru", @_) ;
    },
  },

  'lexer-pa-pr' => {
    'name' => 'lexer-pa-pr',
	'command' => sub {
	  return ("./roundtrip_lexer.byte","-mode","parse-pp", @_) ;
    },
  },

  'ifdef-eval' => {
    'name' => 'ifdef-eval',
	'command' => sub {
	  return ("./roundtrip_lexer.byte","-D", "STRICT", "-mode","ifdef-eval", @_) ;
    },
  },
    ) ;

our %packages ;

{
  GetOptions(
    "tool=s" => \$tool,
    "tool1=s" => \$tool1,
    "tool2=s" => \$tool2,
    "package=s{}" => \@dopackages,
    "only-files=s{}" => \@onlyfiles,
    "verbose" => \$verbose,
    "preserve" => \$preserve,
    "continue-on-error" => \$continue_error,
    "packages-file=s" => \$packages_file,
      )
      or die("Error in command line arguments\n");

  die "must specify packages-file"
      unless defined $packages_file ;

  my $yaml = YAML::Tiny->read($packages_file) ;
  %packages = %{ $yaml->[0] } ;

    my $workdir = "workdir" ;

  if ($ARGV[0] eq 'override-file') {
    shift @ARGV ;
    die "tool $tool not recognized"
	unless $tool eq 'ALL' || exists $tools{$tool} ;

    die "must specify a single package"
	unless 1 == int(@dopackages) ;
    die "must specify files"
	unless int(@onlyfiles) ;

    foreach my $file (@onlyfiles) {
      my $pkgna = $dopackages[0] ;
      my $pkgh = $packages{$pkgna} ;
      my %pkg = %{ $pkgh };

      my $fullsrcname = "$pkg{'location'}/$file" ;
      die "file $file in package $pkg{'package'} does not exist ($fullsrcname)"
	  unless (-r $fullsrcname) ;
      my $bangf = $file ;
      $bangf =~ s,/,!,g ;
      my $inputname = "patches/$pkg{'package'}/$tool/$bangf.INPUT" ;
      die "overridden input file $inputname already exists"
	  unless (!(-r $inputname)) ;

      v_systemx("mkdir", "-p", "patches/$pkg{'package'}/$tool") ;
      v_systemx("cp", $fullsrcname, $inputname) ;
    }
  }
  elsif ($ARGV[0] eq 'override-to-patch') {
    shift @ARGV ;
    die "tool $tool not recognized"
	unless $tool eq 'ALL' || exists $tools{$tool} ;

    die "must specify a single package"
	unless 1 == int(@dopackages) ;
    die "must specify files"
	unless int(@onlyfiles) ;

    foreach my $file (@onlyfiles) {
      my $pkgna = $dopackages[0] ;
      my $pkgh = $packages{$pkgna} ;
      my %pkg = %{ $pkgh };

      my $fullsrcname = "$pkg{'location'}/$file" ;
      die "file $file in package $pkg{'package'} does not exist ($fullsrcname)"
	  unless (-r $fullsrcname) ;
      my $bangf = $file ;
      $bangf =~ s,/,!,g ;
      my $inputname = "patches/$pkg{'package'}/$tool/$bangf.INPUT" ;
      die "overridden input file $inputname does not exist"
	  unless (-r $inputname) ;

      my $patchname = "patches/$pkg{'package'}/$tool/$bangf.PATCH" ;
      die "patch file $patchname alrady exists"
	  unless (!(-r $patchname)) ;

      my $diff_output = v_capturex([1], "diff", "-Bwiu", $fullsrcname, $inputname) ;
      f_write($patchname, $diff_output) ;
      v_systemx("mv",$inputname,"$inputname-MOVED") ;
    }
  }
  else {
    die "tool $tool1 not recognized"
	unless exists $tools{$tool1} ;

    die "tool $tool2 not recognized"
	unless exists $tools{$tool2} ;

    push(@dopackages, @ARGV) ;

    die "must specify packages" unless @dopackages ;

    foreach my $pkgna (@dopackages) {
      die "package $pkgna not recognized"
	  unless exists $packages{$pkgna} ;
    }

    if (@onlyfiles) {
      die "can only specify a single package if also specifying --only-files"
	  unless 1 == int(@dopackages) ;
    }

    foreach my $pkgna (@dopackages) {
      my $pkgh = $packages{$pkgna} ;
      $pkgh->{'onlyfiles'} = [ @onlyfiles ] if @onlyfiles ; 
      runtest_package($workdir,
		      $tools{$tool1},
		      $tools{$tool2},
		      $pkgh);
    }
  }
}

sub runtest_package {
  my $workroot = shift ;
  my $tool1h = shift ;
  my $tool2h = shift ;
  my $pkgh = shift ;

  my %tool1 = %{ $tool1h };
  my $tool1name = $tool1{'name'} ;

  my %tool2 = %{ $tool2h };
  my $tool2name = $tool2{'name'} ;

  my %pkg = %{ $pkgh };
  my $location = $pkg{'location'} ;
  my $workdir = $workroot."/".$pkg{'package'} ;
  my @dirs = @{ $pkg{'dirs'} };
  my @files = @{  $pkg{'files'} } ;

  my %exclude ;
  {
    my @l = () ;
    push (@l, @{ $pkg{'exclude'}->{$tool1name} })
	if (exists $pkg{'exclude'}->{$tool1name}) ;
    push (@l, @{ $pkg{'exclude'}->{$tool2name} })
	if (exists $pkg{'exclude'}->{$tool2name}) ;
    foreach my $f (@l) {
      $exclude{$f} = 1 ;
    }
  }

  my %onlyfiles ;
  {
    my @l = () ;
    push (@l, @{ $pkg{'onlyfiles'} })
	if (exists $pkg{'onlyfiles'}) ;
    foreach my $f (@l) {
      $onlyfiles{$f} = 1 ;
    }
  }

  v_systemx("rm", "-rf", $workdir) ;
  v_systemx("mkdir", "-p", "$workdir/$tool1name", "$workdir/$tool2name") ;

  {
    my @newfiles ;
    my $perfile = sub {
      my $f = $File::Find::name ;
      if ($f =~ /\.ml$/ || $f =~ /\.mli$/) {
	push(@newfiles, $f) ;
      }
    } ;

    find( { wanted => $perfile, no_chdir => 1 }, 
	  (map { $location."/".$_ } @dirs) ) ;

    @newfiles = map { $_ =~ s,^$location/,,; $_ } @newfiles ;

    push(@files, @newfiles) ;
  }

  foreach my $f (@files) {
    next if exists $exclude{$f} && !int(%onlyfiles);
    next if int(%onlyfiles) && !(exists $onlyfiles{$f}) ;

    print "==== $f ====\n";
    my $bangf = $f ;
    $bangf =~ s,/,!,g ;

    my @generated_files = () ;
    my $origf = "$location/".$f ;
    my $tool1srcf = "$workdir/$tool1name/".$bangf ;
    my $tool2srcf = "$workdir/$tool2name/".$bangf ;
    my $tool1outf = "$workdir/$tool1name/".$bangf.".OUT" ;
    my $tool2outf = "$workdir/$tool2name/".$bangf.".OUT" ;
    push(@generated_files, $tool1srcf, $tool2srcf,  $tool1outf, $tool2outf) ;

    my @silent ;
    push(@silent, "-s") unless $main::verbose ;
    my $all_tool_patch = "patches/$pkg{'package'}/ALL/".$bangf.".PATCH" ;
    my $patch1 = "patches/$pkg{'package'}/$tool1name/".$bangf.".PATCH" ;
    my $patch2 = "patches/$pkg{'package'}/$tool2name/".$bangf.".PATCH" ;

    my $all_tool_input = "patches/$pkg{'package'}/ALL/".$bangf.".INPUT" ;
    my $patch_input1 = "patches/$pkg{'package'}/$tool1name/".$bangf.".INPUT" ;
    my $patch_input2 = "patches/$pkg{'package'}/$tool2name/".$bangf.".INPUT" ;

    if (-r $all_tool_input) {
      v_systemx("cp", $all_tool_input, $tool1srcf) ;
    }
    elsif (-r $patch_input1) {
      v_systemx("cp", $patch_input1, $tool1srcf) ;
    }
    else {
      v_systemx("cp", $origf, $tool1srcf) ;
    }
    if (-r $patch1) {
      print "PATCHING $tool1srcf\n" if $main::verbose;
      v_systemx("patch",@silent, $tool1srcf, $patch1) ;
    }
    elsif (-r $all_tool_patch) {
      print "PATCHING $tool1srcf\n" if $main::verbose;
      v_systemx("patch",@silent, $tool1srcf, $all_tool_patch) ;
    }
    my $code ;
    $code = runtool(tool => \%tool1,
		    'src-filename' => $tool1srcf,
		    'dst-filename' => $tool1outf,
	) ;

    if ($code != 0) {
      warn "aborting processing of $f" ;
      next ;
    }

    if (-r $all_tool_input) {
      v_systemx("cp", $all_tool_input, $tool2srcf) ;
    }
    elsif (-r $patch_input2) {
      v_systemx("cp", $patch_input2, $tool2srcf) ;
    }
    else {
      v_systemx("cp", $origf, $tool2srcf) ;
    }
    if (-r $patch2) {
      print "PATCHING $tool2srcf\n" if $main::verbose;
      v_systemx("patch",@silent, $tool2srcf, $patch2) ;
    }
    elsif (-r $all_tool_patch) {
      print "PATCHING $tool2srcf\n" if $main::verbose;
      v_systemx("patch",@silent, $tool2srcf, $all_tool_patch) ;
    }
    $code = runtool(tool => \%tool2,
		    'src-filename' => $tool2srcf,
		    'dst-filename' => $tool2outf,
	) ;
    if ($code != 0) {
      warn "aborting processing of $f" ;
      next ;
    }
    v_systemx("tools/normalize-code.pl",
	      "-syntax", $pkg{'syntax'},
	      $tool1outf, $tool1outf.".NORMALIZED") ;
    v_systemx("tools/normalize-code.pl",
	      "-syntax", $pkg{'syntax'},
	      $tool2outf, $tool2outf.".NORMALIZED") ;
    push(@generated_files, $tool1outf.".NORMALIZED", $tool2outf.".NORMALIZED") ;

    my $errordir = "$workdir/$tool1name!$tool2name.ERRORS" ;
    v_systemx("mkdir", "-p", $errordir) ;
    my $errorbase = "$errordir/$bangf" ;
    my $preserve = $main::preserve ;
    $code = extended_diff($tool1outf.".NORMALIZED", $tool2outf.".NORMALIZED",
	'errorbase' => $errorbase,
        'generated-files' => \@generated_files,
        'preserve' => \$preserve,
	) ;
    if (0 == $code) {
      print "OK $f\n";
      if (!$preserve) {
	v_systemx("rm", "-f", @generated_files);
      }
    } else {
      print "NOT OK $f\n";
      die "stopping due to errors in $f" unless $main::continue_error ;
    }
  }
}

sub extended_diff {
  my $f1 = shift ;
  my $f2 = shift ;
  my %args = @_ ;

  my @cmd = ("diff", "-Bwiu", $f1, $f2) ;
  my $diff_output = v_capturex([0..1], @cmd) ;
  my $diff_ok = (0 == $EXITVAL) ;

  my $wdiff_output = v_capturex([0..1], "wdiff", "-3", $f1, $f2) ;
  my $wdiff_full_output = v_capturex([0..1], "wdiff", $f1, $f2) ;
  my $wdiff_ok = (0 == $EXITVAL) ;

  if (exists $args{'errorbase'}) {
    f_write("$args{'errorbase'}.DIFF", $diff_output) ;
    f_write("$args{'errorbase'}.WDIFF", $wdiff_output) ;
    f_write("$args{'errorbase'}.WDIFF-FULL", $wdiff_full_output) ;
    push(@{ $args{'generated-files'} }, "$args{'errorbase'}.DIFF", "$args{'errorbase'}.WDIFF", "$args{'errorbase'}.WDIFF-FULL") ;
  }

  my $wordeq_ok = wordeq($f1, $f2, 'generated-files' => $args{'generated-files'}) ;

  if ($diff_ok) { return 0 ; }

  if ($wdiff_ok) {
    print "== $f1 <-> $f2\n" ;
    print "WDIFF SAYS OK\n" ;
    ${ $args{'preserve'} } = 1 ;
    return 0 ;
  }
  if ($wordeq_ok) {
    print "== $f1 <-> $f2\n" ;
    print "WHITE SPACE DIFFERENCES from wordeq\n" ;
    ${ $args{'preserve'} } = 1 ;
    return 0 ;
  }

  print $diff_output ;
  return 1 ;
}

sub wordeq {
  my $f1 = shift ;
  my $f2 = shift ;
  my %args = @_ ;

  my $txt1 = f_read($f1) ;
  my $txt2 = f_read($f2) ;

  $txt1 =~ s,\s,,gs ;
  $txt2 =~ s,\s,,gs ;
  if ($txt1 eq $txt2) {
    return 1 ;
  }
  else {
    f_write("$f1.NO-WS", $txt1) ;
    f_write("$f2.NO-WS", $txt2) ;
    push(@{ $args{'generated-files'} }, "$f1.NO-WS", "$f2.NO-WS") ;

    return 0 ;
  }
}

sub runtool {
  my %args = @_ ;
  my $tool = $args{'tool'} ;
  my $srcf = $args{'src-filename'} ;
  my $dstf = $args{'dst-filename'} ;

  print "$tool->{'name'}: $srcf -> $dstf\n" if $main::verbose ;
  my @cmd = &{ $tool->{'command'}, }($srcf, $dstf) ;
  my $code = v_systemx([0..2], @cmd) ;
  if ($code != 0) {
    if (!$continue_error) {
      die ("command <<".join(' ', @cmd).">> died with $@") ;
    }
    else {
      warn ("command <<".join(' ', @cmd).">> died with $@") ;
      return $code ;
    }
  }
  return 0 ;
}

sub v_systemx {
  my $codes ;
  $codes = shift if (ref($_[0]) eq 'ARRAY') ;
  my @cmd = @_ ;
  print STDERR join(' ', map { shell_quote($_) } @cmd)."\n" if ($main::verbose) ;

  if ($codes) {
    return runx($codes, @cmd) ;
  }
  else {
    return runx(@cmd) ;
  }
}

sub v_capturex {
  my $codes ;
  $codes = shift if (ref($_[0]) eq 'ARRAY') ;
  my @cmd = @_ ;
  print STDERR join(' ', map { shell_quote($_) } @cmd)."\n" if ($main::verbose) ;

  if ($codes) {
    return capturex($codes, @cmd) ;
  }
  else {
    return capturex(@cmd) ;
  }
}

sub v_system {
  my $cmd = shift;
  print STDERR "<<$cmd>>\n" if ($main::verbose);
  system $cmd;
}

sub f_read {
  my $f = shift;
  open(F,"<$f") || die "cannot open $f for reading";
  my @l = <F>;
  close(F);
  return (wantarray ? @l : join('', @l)) ;
}

sub f_write {
  my $f = shift;
  open(F,">$f") || die "cannot open $f for writing";
  print F @_;
  close(F);
}
