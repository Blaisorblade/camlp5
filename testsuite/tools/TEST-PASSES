#!/usr/bin/perl

use strict ;
use Data::Dumper ;
use Carp::Assert ;
use File::Basename;
use File::Find ;
use File::Spec ;
use File::stat ;
use Getopt::Long;
use IPC::System::Simple qw(systemx runx capturex $EXITVAL);
use String::ShellQuote ;

our $verbose = 0 ;
our $preserve = 0 ;
our $continue_error = 0 ;
our @dopackages ;
our @onlyfiles ;
our $tool1 ;
our $tool2 ;

our %tools = (
  'roundtrip-revised' =>
  {
    'name' => 'roundtrip-revised',
	'command' => sub {
	  return ('tools/ROUNDTRIP-pa_r-pr_r', @_) ;
    },
  },

  'cp' =>
  {
    'name' => 'cp',
	'command' => sub {
	  return ('/bin/cp', @_) ;
    },
  },

  'lexer-passthru' => {
    'name' => 'lexer-passthru',
	'command' => sub {
	  return ("./roundtrip_lexer.byte","-mode","lexer-passthru", @_) ;
    },
  },

  'lexer-pa-pr' => {
    'name' => 'lexer-pa-pr',
	'command' => sub {
	  return ("./roundtrip_lexer.byte","-mode","parse-pp", @_) ;
    },
  },

  'ifdef-eval' => {
    'name' => 'ifdef-eval',
	'command' => sub {
	  return ("./roundtrip_lexer.byte","-D", "STRICT", "-mode","ifdef-eval", @_) ;
    },
  },
    ) ;

our %packages = (
  'camlp5.7.11' =>
  {
    'package' => 'camlp5.7.11',
    'location' => '..',
	'dirs' => [ qw(lib main meta etc top odyl ocpp compile) ],
	'files' => [],
	'exclude' => {
	  'roundtrip-pa_r-pr_r' => [
	      ],
	  'roundtrip-revised' => [
# has "lexer", for which no printers yet
	    "lib/plexer.ml",
# fparsers, bparsers (ugh): no printers for these yet
	    "lib/grammar.ml",
# uses DEFINE_TYPE
	    "main/mLast.mli",
	    "main/pcaml.mli",
# uses DELETE_RULE, no printers
	    "meta/pa_macro.ml",
# uses extensible grammars, doesn't print back out
	    "etc/elexer.ml",
# wrong syntax (LISP)
	    "etc/pa_lisp.ml",
# wrong syntax (Scheme)
	    "etc/pa_scheme.ml",
# unimplemented AST printer
	    "etc/pa_mkast.ml",
# unimplemented fparser printer
	    "etc/pa_pprintf.ml",
# unimplemented AST printer
	    "etc/pa_reloc.ml",
# pretty-printing for grammar EXTEND not up to snuff
	    "etc/pa_sml.ml",
# uses pprintf, but nothing exists to rebuild pprintf (pr_pprintf)
# applies to all these printers
	    "etc/pr_extend.ml",
	    "etc/pr_extfun.ml",
	    "etc/pr_extprint.ml",
	    "etc/pr_op.ml",
	    "etc/pr_ro.ml",
	    "etc/pr_rp.ml",
	    "etc/pr_schemep.ml",
	    "etc/pr_scheme.ml",
	    "etc/pr_o.ml",
	    "etc/pr_r.ml",
	    "etc/papr_phony_macro.ml",
# unimplemented AST printer
	    "etc/pa_mktest.ml",
## TODO: use GITIGNORE to ignore temporary files
#	    "compile/tmp.o_concat.ml",
#	    "compile/tmp.ml",
#	    "compile/tmp.mli",
#	    "compile/pa_o_fast.ml",
## this seems like original syntax -- skip
#	    "odyl/odyl_config.ml",
	      ],
    },
  },
    ) ;

{

  GetOptions("tool1=s" => \$tool1,
	     "tool2=s" => \$tool2,
	     "package=s{}" => \@dopackages,
	     "only-files=s{}" => \@onlyfiles,
	     "verbose" => \$verbose,
	     "preserve" => \$preserve,
	     "continue-on-error" => \$continue_error,
      )
      or die("Error in command line arguments\n");

  push(@dopackages, @ARGV) ;

  die "tool $tool1 not recognized"
      unless exists $tools{$tool1} ;

  die "tool $tool2 not recognized"
      unless exists $tools{$tool2} ;

  die "must specify packages" unless @dopackages ;

  foreach my $pkgna (@dopackages) {
    die "package $pkgna not recognized"
	unless exists $packages{$pkgna} ;
  }

  my $workdir = "workdir" ;

  foreach my $pkgna (@dopackages) {
    my $pkgh = $packages{$pkgna} ;
    $pkgh->{'onlyfiles'} = [ @onlyfiles ] if @onlyfiles ; 
    runtest_package($workdir,
		    $tools{$tool1},
		    $tools{$tool2},
		    $pkgh);
  }
}

sub runtest_package {
  my $workroot = shift ;
  my $tool1h = shift ;
  my $tool2h = shift ;
  my $pkgh = shift ;

  my %tool1 = %{ $tool1h };
  my $tool1name = $tool1{'name'} ;

  my %tool2 = %{ $tool2h };
  my $tool2name = $tool2{'name'} ;

  my %pkg = %{ $pkgh };
  my $location = $pkg{'location'} ;
  my $workdir = $workroot."/".$pkg{'package'} ;
  my @dirs = @{ $pkg{'dirs'} };
  my @files = @{  $pkg{'files'} } ;

  my %exclude ;
  {
    my @l = () ;
    push (@l, @{ $pkg{'exclude'}->{$tool1name} })
	if (exists $pkg{'exclude'}->{$tool1name}) ;
    push (@l, @{ $pkg{'exclude'}->{$tool2name} })
	if (exists $pkg{'exclude'}->{$tool2name}) ;
    foreach my $f (@l) {
      $exclude{$f} = 1 ;
    }
  }

  my %onlyfiles ;
  {
    my @l = () ;
    push (@l, @{ $pkg{'onlyfiles'} })
	if (exists $pkg{'onlyfiles'}) ;
    foreach my $f (@l) {
      $onlyfiles{$f} = 1 ;
    }
  }

  v_systemx("rm", "-rf", $workdir) ;
  v_systemx("mkdir", "-p", "$workdir/$tool1name", "$workdir/$tool2name") ;

  {
    my @newfiles ;
    my $perfile = sub {
      my $f = $File::Find::name ;
      if ($f =~ /\.ml$/ || $f =~ /\.mli$/) {
	push(@newfiles, $f) ;
      }
    } ;

    find( { wanted => $perfile, no_chdir => 1 }, 
	  (map { $location."/".$_ } @dirs) ) ;

    @newfiles = map { $_ =~ s,^$location/,,; $_ } @newfiles ;

    push(@files, @newfiles) ;
  }

  foreach my $f (@files) {
    next if exists $exclude{$f} && !int(%onlyfiles);
    next if int(%onlyfiles) && !(exists $onlyfiles{$f}) ;

    print "==== $f ====\n";
    my $bangf = $f ;
    $bangf =~ s,/,!,g ;

    my @generated_files = () ;
    my $origf = "$location/".$f ;
    my $tool1srcf = "$workdir/$tool1name/".$bangf ;
    my $tool2srcf = "$workdir/$tool2name/".$bangf ;
    my $tool1outf = "$workdir/$tool1name/".$bangf.".OUT" ;
    my $tool2outf = "$workdir/$tool2name/".$bangf.".OUT" ;
    push(@generated_files, $tool1srcf, $tool2srcf,  $tool1outf, $tool2outf) ;

    my $all_tool_patch = "patches/$pkg{'package'}/ALL/".$bangf.".PATCH" ;
    my $patch1 = "patches/$pkg{'package'}/$tool1name/".$bangf.".PATCH" ;
    my $patch2 = "patches/$pkg{'package'}/$tool2name/".$bangf.".PATCH" ;

    my $all_tool_input = "patches/$pkg{'package'}/ALL/".$bangf.".INPUT" ;
    my $patch_input1 = "patches/$pkg{'package'}/$tool1name/".$bangf.".INPUT" ;
    my $patch_input2 = "patches/$pkg{'package'}/$tool2name/".$bangf.".INPUT" ;

    if (-r $all_tool_input) {
      v_systemx("cp", $all_tool_input, $tool1srcf) ;
    }
    elsif (-r $patch_input1) {
      v_systemx("cp", $patch_input1, $tool1srcf) ;
    }
    else {
      v_systemx("cp", $origf, $tool1srcf) ;
    }
    if (-r $patch1) {
      print "PATCHING $tool1srcf\n";
      v_systemx("patch",$tool1srcf, $patch1) ;
    }
    elsif (-r $all_tool_patch) {
      print "PATCHING $tool1srcf\n";
      v_systemx("patch",$tool1srcf, $all_tool_patch) ;
    }
    my $code ;
    $code = runtool(tool => \%tool1,
		    'src-filename' => $tool1srcf,
		    'dst-filename' => $tool1outf,
	) ;

    if ($code != 0) {
      warn "aborting processing of $f" ;
      next ;
    }

    if (-r $all_tool_input) {
      v_systemx("cp", $all_tool_input, $tool2srcf) ;
    }
    elsif (-r $patch_input2) {
      v_systemx("cp", $patch_input2, $tool2srcf) ;
    }
    else {
      v_systemx("cp", $origf, $tool2srcf) ;
    }
    if (-r $patch2) {
      print "PATCHING $tool2srcf\n";
      v_systemx("patch",$tool2srcf, $patch2) ;
    }
    elsif (-r $all_tool_patch) {
      print "PATCHING $tool2srcf\n";
      v_systemx("patch",$tool2srcf, $all_tool_patch) ;
    }
    $code = runtool(tool => \%tool2,
		    'src-filename' => $tool2srcf,
		    'dst-filename' => $tool2outf,
	) ;
    if ($code != 0) {
      warn "aborting processing of $f" ;
      next ;
    }
    v_systemx("tools/normalize-code.pl", $tool1outf, $tool1outf.".NORMALIZED") ;
    v_systemx("tools/normalize-code.pl", $tool2outf, $tool2outf.".NORMALIZED") ;
    push(@generated_files, $tool1outf.".NORMALIZED", $tool2outf.".NORMALIZED") ;

    my $errordir = "$workdir/$tool1name!$tool2name.ERRORS" ;
    v_systemx("mkdir", "-p", $errordir) ;
    my $errorbase = "$errordir/$bangf" ;
    my $code = extended_diff($tool1outf.".NORMALIZED", $tool2outf.".NORMALIZED",
	'errorbase' => $errorbase,
        'generated-files' => \@generated_files,
	) ;
    if (0 == $code) {
      print "OK $f\n";
      if (!$preserve) {
	v_systemx("rm", "-f", @generated_files);
      }
    } else {
      print "NOT OK $f\n";
    }
  }
}

sub extended_diff {
  my $f1 = shift ;
  my $f2 = shift ;
  my %args = @_ ;

  my @cmd = ("diff", "-Bwiu", $f1, $f2) ;
  my $diff_output = v_capturex([0..1], @cmd) ;
  my $diff_ok = (0 == $EXITVAL) ;

  my $wdiff_output = v_capturex([0..1], "wdiff", "-3", $f1, $f2) ;
  my $wdiff_full_output = v_capturex([0..1], "wdiff", $f1, $f2) ;
  my $wdiff_ok = (0 == $EXITVAL) ;

  if (exists $args{'errorbase'}) {
    f_write("$args{'errorbase'}.DIFF", $diff_output) ;
    f_write("$args{'errorbase'}.WDIFF", $wdiff_output) ;
    f_write("$args{'errorbase'}.WDIFF-FULL", $wdiff_full_output) ;
    push(@{ $args{'generated-files'} }, "$args{'errorbase'}.DIFF", "$args{'errorbase'}.WDIFF", "$args{'errorbase'}.WDIFF-FULL") ;
  }

  my $wordeq_ok = wordeq($f1, $f2, 'generated-files' => $args{'generated-files'}) ;

  if ($diff_ok) { return 0 ; }

  if ($wdiff_ok) {
    print "== $f1 <-> $f2\n" ;
    print "WDIFF SAYS OK\n" ;
    return 1 ;
  }
  if ($wordeq_ok) {
    print "== $f1 <-> $f2\n" ;
    print "WHITE SPACE DIFFERENCES from wordeq\n" ;
    return 1 ;
  }

  print $diff_output ;
  return 1 ;
}

sub wordeq {
  my $f1 = shift ;
  my $f2 = shift ;
  my %args = @_ ;

  my $txt1 = f_read($f1) ;
  my $txt2 = f_read($f2) ;

  $txt1 =~ s,\s,,gs ;
  $txt2 =~ s,\s,,gs ;
  if ($txt1 eq $txt2) {
    return 1 ;
  }
  else {
    f_write("$f1.NO-WS", $txt1) ;
    f_write("$f2.NO-WS", $txt2) ;
    push(@{ $args{'generated-files'} }, "$f1.NO-WS", "$f2.NO-WS") ;

    return 0 ;
  }
}

sub runtool {
  my %args = @_ ;
  my $tool = $args{'tool'} ;
  my $srcf = $args{'src-filename'} ;
  my $dstf = $args{'dst-filename'} ;

  print "$tool->{'name'}: $srcf -> $dstf\n" if $main::verbose ;
  my @cmd = &{ $tool->{'command'}, }($srcf, $dstf) ;
  my $code = v_systemx([0..2], @cmd) ;
  if ($code != 0) {
    if (!$continue_error) {
      die ("command <<".join(' ', @cmd).">> died with $@") ;
    }
    else {
      warn ("command <<".join(' ', @cmd).">> died with $@") ;
      return $code ;
    }
  }
  return 0 ;
}

sub v_systemx {
  my $codes ;
  $codes = shift if (ref($_[0]) eq 'ARRAY') ;
  my @cmd = @_ ;
  print STDERR join(' ', map { shell_quote($_) } @cmd)."\n" if ($main::verbose) ;

  if ($codes) {
    return runx($codes, @cmd) ;
  }
  else {
    return runx(@cmd) ;
  }
}

sub v_capturex {
  my $codes ;
  $codes = shift if (ref($_[0]) eq 'ARRAY') ;
  my @cmd = @_ ;
  print STDERR join(' ', map { shell_quote($_) } @cmd)."\n" if ($main::verbose) ;

  if ($codes) {
    return capturex($codes, @cmd) ;
  }
  else {
    return capturex(@cmd) ;
  }
}

sub v_system {
  my $cmd = shift;
  print STDERR "<<$cmd>>\n" if ($main::verbose);
  system $cmd;
}

sub f_read {
  my $f = shift;
  open(F,"<$f") || die "cannot open $f for reading";
  my @l = <F>;
  close(F);
  return (wantarray ? @l : join('', @l)) ;
}

sub f_write {
  my $f = shift;
  open(F,">$f") || die "cannot open $f for writing";
  print F @_;
  close(F);
}
