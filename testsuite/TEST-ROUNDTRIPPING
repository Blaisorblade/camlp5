#!/usr/bin/perl

use strict ;
use Data::Dumper ;
use Carp::Assert ;
use File::Basename;
use File::Find ;
use File::Spec ;
use File::stat ;
use IPC::System::Simple qw(systemx runx capturex $EXITVAL);
use String::ShellQuote ;

our $verbose = 0 ;
our $continue_error = 0 ;

{
  my $top= ".." ;
  my $workdir = "workdir" ;
  my @revised_dirs = (qw(lib main meta etc top odyl ocpp compile)) ;

  v_systemx("rm", "-rf", $workdir) ;
  roundtrip_package($workdir, {
    'location' => '..',
    'package' => 'camlp5.7.11',
	'dirs' => [ qw(lib main meta etc top odyl ocpp compile) ],
	'files' => [],
	'exclude' => [
	  'lib/versdep.ml',
	  'lib/eprinter.ml',
	  'lib/pprintf.ml',
	  'lib/pprintf.mli',
	  'lib/plexer.ml',
	  'lib/plexing.ml',
	  'lib/ploc.ml',
#	  'lib/extfold.ml',
	  'lib/grammar.ml',
	  "main/pcaml.mli",
	  "main/prtools.ml",
	  "main/mLast.mli",
	  "main/reloc.ml",
	],
		    }
      );
}

sub roundtrip_package {
  my $workroot = shift ;
  my $h = shift ;
  my %package = %{ $h };

  my $location = $package{'location'} ;
  my $workdir = $workroot."/".$package{'package'} ;
  my @dirs = @{ $package{'dirs'} };
  my @files = @{  $package{'files'} } ;

  my %exclude ;
  {
    my @l = @{ $package{'exclude'} } ;
    foreach my $f (@l) {
      $exclude{$f} = 1 ;
    }
  }

  v_systemx("rm", "-rf", $workdir) ;
  v_systemx("mkdir", "-p", "$workdir/roundtrip", "$workdir/wanted") ;

  {
    my @newfiles ;
    my $perfile = sub {
      my $f = $File::Find::name ;
      if ($f =~ /\.ml$/ || $f =~ /\.mli$/) {
	push(@newfiles, $f) ;
      }
    } ;

    find( { wanted => $perfile, no_chdir => 1 }, 
	  (map { $location."/".$_ } @dirs) ) ;

    @newfiles = map { $_ =~ s,^$location/,,; $_ } @newfiles ;

    push(@files, @newfiles) ;
  }

  foreach my $f (@files) {
    next if exists $exclude{$f} ;

    my $bangf = $f ;
    $bangf =~ s,/,!,g ;

    my $srcf = "$location/".$f ;
    my $resultf = "$workdir/roundtrip/".$bangf ;
    my $wantedf = "$workdir/wanted/".$bangf ;

    v_systemx("cp", "-n", $srcf, $wantedf) ;

    roundtrip1(mode => 'revised',
	       'src-filename' => $srcf,
	       'result-filename' => $resultf,
	       'wanted-filename' => $wantedf,
	) ;
    v_systemx("./normalize-code.pl", $resultf, $resultf.".NORMALIZED") ;
    v_systemx("./normalize-code.pl", $wantedf, $wantedf.".NORMALIZED") ;
    my $code = extended_diff($resultf.".NORMALIZED", $wantedf.".NORMALIZED"); ;
    if (0 == $code) {
      v_systemx("rm", "-f", $resultf, $resultf.".NORMALIZED", $wantedf, $wantedf.".NORMALIZED");
    }
  }
}

sub extended_diff {
  my $f1 = shift ;
  my $f2 = shift ;

  my @cmd = ("diff", "-Bwiu", $f1, $f2) ;
  my $diff_output = v_capturex([0..1], @cmd) ;
  return 0 if (0 == $EXITVAL) ;

  my $wdiff_output = v_capturex([0..1], "wdiff", "-3", $f1, $f2) ;
  return 1 if (0 == $EXITVAL) ;

  if (wordeq($f1, $f2)) {
    print "== $f1 <-> $f2\n" ;
    print "WHITE SPACE DIFFERENCES\n" ;
  }
  else {
    print $diff_output ;
  }
  return 1 ;
}

sub wordeq {
  my $f1 = shift ;
  my $f2 = shift ;

  my $txt1 = f_read($f1) ;
  my $txt2 = f_read($f2) ;

  $txt1 =~ s,\s,,gs ;
  $txt2 =~ s,\s,,gs ;
  return ($txt1 eq $txt2) ;
}

sub roundtrip1 {
  my %args = @_ ;
  my $mode = $args{'mode'} ;
  my $srcf = $args{'src-filename'} ;
  my $resultf = $args{'result-filename'} ;
  my $wantedf = $args{'wanted-filename'} ;

  print "$srcf -> $resultf\n" if $main::verbose ;
  v_systemx("./REVISED-ROUNDTRIP",$srcf, $resultf) ;
}

sub v_systemx {
  my $codes ;
  $codes = shift if (ref($_[0]) eq 'ARRAY') ;
  my @cmd = @_ ;
  print STDERR join(' ', map { shell_quote($_) } @cmd)."\n" if ($main::verbose) ;

  if ($codes) {
    return runx($codes, @cmd) ;
  }
  else {
    return runx(@cmd) ;
  }
}

sub v_capturex {
  my $codes ;
  $codes = shift if (ref($_[0]) eq 'ARRAY') ;
  my @cmd = @_ ;
  print STDERR join(' ', map { shell_quote($_) } @cmd)."\n" if ($main::verbose) ;

  if ($codes) {
    return capturex($codes, @cmd) ;
  }
  else {
    return capturex(@cmd) ;
  }
}

sub v_system {
  my $cmd = shift;
  print STDERR "<<$cmd>>\n" if ($main::verbose);
  system $cmd;
}

sub f_read {
  my $f = shift;
  open(F,"<$f") || die "cannot open $f for reading";
  my @l = <F>;
  close(F);
  return (wantarray ? @l : join('', @l)) ;
}

sub f_write {
  my $f = shift;
  open(F,">$f") || die "cannot open $f for writing";
  print F @_;
  close(F);
}
