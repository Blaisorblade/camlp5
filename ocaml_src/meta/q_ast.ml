(* camlp5r *)
(* This file has been generated by program: do not edit! *)

(* #load "pa_extend.cmo";; *)
(* #load "q_MLast.cmo";; *)

let not_impl f x =
  let desc =
    if Obj.is_block (Obj.repr x) then
      "tag = " ^ string_of_int (Obj.tag (Obj.repr x))
    else "int_val = " ^ string_of_int (Obj.magic x)
  in
  failwith ("q_ast_r.ml: " ^ f ^ ", not impl: " ^ desc)
;;

let antiquot_loc k loc =
  let shift_bp =
    if k = "" then String.length "$"
    else String.length "$" + String.length k + String.length ":"
  in
  let shift_ep = String.length "$" in
  Stdpp.make_lined_loc (Stdpp.line_nb loc) (Stdpp.bol_pos loc)
    (Stdpp.first_pos loc + shift_bp, Stdpp.last_pos loc - shift_ep)
;;

let after_colon e =
  try
    let i = String.index e ':' in
    String.sub e (i + 1) (String.length e - i - 1)
  with Not_found -> ""
;;

let eq_before_colon p e =
  let rec loop i =
    if i == String.length e then
      failwith "Internal error in Plexer: incorrect ANTIQUOT"
    else if i == String.length p then e.[i] == ':'
    else if p.[i] == e.[i] then loop (i + 1)
    else false
  in
  loop 0
;;

let call_with r v f a =
  let saved = !r in
  try r := v; let b = f a in r := saved; b with e -> r := saved; raise e
;;

let expr_eoi = Grammar.Entry.create Pcaml.gram "expr";;
let patt_eoi = Grammar.Entry.create Pcaml.gram "patt";;
let sig_item_eoi = Grammar.Entry.create Pcaml.gram "sig_item";;
Grammar.extend
  [Grammar.Entry.obj (expr_eoi : 'expr_eoi Grammar.Entry.e), None,
   [None, None,
    [[Gramext.Snterm
        (Grammar.Entry.obj (Pcaml.expr : 'Pcaml__expr Grammar.Entry.e));
      Gramext.Stoken ("EOI", "")],
     Gramext.action
       (fun _ (x : 'Pcaml__expr) (loc : Token.location) -> (x : 'expr_eoi))]];
   Grammar.Entry.obj (patt_eoi : 'patt_eoi Grammar.Entry.e), None,
   [None, None,
    [[Gramext.Snterm
        (Grammar.Entry.obj (Pcaml.patt : 'Pcaml__patt Grammar.Entry.e));
      Gramext.Stoken ("EOI", "")],
     Gramext.action
       (fun _ (x : 'Pcaml__patt) (loc : Token.location) -> (x : 'patt_eoi))]];
   Grammar.Entry.obj (sig_item_eoi : 'sig_item_eoi Grammar.Entry.e), None,
   [None, None,
    [[Gramext.Snterm
        (Grammar.Entry.obj
           (Pcaml.sig_item : 'Pcaml__sig_item Grammar.Entry.e));
      Gramext.Stoken ("EOI", "")],
     Gramext.action
       (fun _ (x : 'Pcaml__sig_item) (loc : Token.location) ->
          (x : 'sig_item_eoi))]]];;

module Meta =
  struct
    open MLast;;
    let loc = Stdpp.dummy_loc;;
    let ln () = MLast.ExLid (loc, !(Stdpp.loc_name));;
    let rec e_list elem =
      function
        [] -> MLast.ExUid (loc, "[]")
      | e :: el ->
          MLast.ExApp
            (loc, MLast.ExApp (loc, MLast.ExUid (loc, "::"), elem e),
             e_list elem el)
    ;;
    let e_option elem =
      function
        None -> MLast.ExUid (loc, "None")
      | Some e -> MLast.ExApp (loc, MLast.ExUid (loc, "Some"), elem e)
    ;;
    let e_bool b =
      if b then MLast.ExUid (loc, "True") else MLast.ExUid (loc, "False")
    ;;
    let e_type t =
      let ln = ln () in
      let rec loop =
        function
          TyAcc (_, t1, t2) ->
            MLast.ExApp
              (loc,
               MLast.ExApp
                 (loc,
                  MLast.ExApp
                    (loc,
                     MLast.ExAcc
                       (loc, MLast.ExUid (loc, "MLast"),
                        MLast.ExUid (loc, "TyAcc")),
                     ln),
                  loop t1),
               loop t2)
        | TyAny _ ->
            MLast.ExApp
              (loc,
               MLast.ExAcc
                 (loc, MLast.ExUid (loc, "MLast"),
                  MLast.ExUid (loc, "TyAny")),
               ln)
        | TyApp (_, t1, t2) ->
            MLast.ExApp
              (loc,
               MLast.ExApp
                 (loc,
                  MLast.ExApp
                    (loc,
                     MLast.ExAcc
                       (loc, MLast.ExUid (loc, "MLast"),
                        MLast.ExUid (loc, "TyApp")),
                     ln),
                  loop t1),
               loop t2)
        | TyLid (_, s) ->
            MLast.ExApp
              (loc,
               MLast.ExApp
                 (loc,
                  MLast.ExAcc
                    (loc, MLast.ExUid (loc, "MLast"),
                     MLast.ExUid (loc, "TyLid")),
                  ln),
               MLast.ExStr (loc, s))
        | TyUid (_, s) ->
            MLast.ExApp
              (loc,
               MLast.ExApp
                 (loc,
                  MLast.ExAcc
                    (loc, MLast.ExUid (loc, "MLast"),
                     MLast.ExUid (loc, "TyUid")),
                  ln),
               MLast.ExStr (loc, s))
        | x -> not_impl "e_type" x
      in
      loop t
    ;;
    let p_type =
      function
        TyLid (_, s) ->
          MLast.PaApp
            (loc,
             MLast.PaApp
               (loc,
                MLast.PaAcc
                  (loc, MLast.PaUid (loc, "MLast"),
                   MLast.PaUid (loc, "TyLid")),
                MLast.PaAny loc),
             MLast.PaStr (loc, s))
      | x -> not_impl "p_type" x
    ;;
    let e_patt p =
      let ln = ln () in
      let rec loop =
        function
          PaLid (loc, s) ->
            let a = after_colon s in
            if a = "" then
              MLast.ExApp
                (loc,
                 MLast.ExApp
                   (loc,
                    MLast.ExAcc
                      (loc, MLast.ExUid (loc, "MLast"),
                       MLast.ExUid (loc, "PaLid")),
                    ln),
                 MLast.ExStr (loc, s))
            else
              let r =
                let loc = Stdpp.make_loc (0, String.length a) in
                MLast.ExApp
                  (loc,
                   MLast.ExApp
                     (loc,
                      MLast.ExAcc
                        (loc, MLast.ExUid (loc, "MLast"),
                         MLast.ExUid (loc, "PaLid")),
                      ln),
                   MLast.ExLid (loc, a))
              in
              let loc = antiquot_loc "lid" loc in MLast.ExAnt (loc, r)
        | PaTyc (_, p, t) ->
            MLast.ExApp
              (loc,
               MLast.ExApp
                 (loc,
                  MLast.ExApp
                    (loc,
                     MLast.ExAcc
                       (loc, MLast.ExUid (loc, "MLast"),
                        MLast.ExUid (loc, "PaTyc")),
                     ln),
                  loop p),
               e_type t)
        | x -> not_impl "e_patt" x
      in
      loop p
    ;;
    let e_expr e =
      let ln = ln () in
      let rec loop =
        function
          ExAcc (_, e1, e2) ->
            MLast.ExApp
              (loc,
               MLast.ExApp
                 (loc,
                  MLast.ExApp
                    (loc,
                     MLast.ExAcc
                       (loc, MLast.ExUid (loc, "MLast"),
                        MLast.ExUid (loc, "ExAcc")),
                     ln),
                  loop e1),
               loop e2)
        | ExAnt (_, MLast.ExTup (_, [MLast.ExStr (_, ""); e])) -> e
        | ExApp (_, e1, e2) ->
            MLast.ExApp
              (loc,
               MLast.ExApp
                 (loc,
                  MLast.ExApp
                    (loc,
                     MLast.ExAcc
                       (loc, MLast.ExUid (loc, "MLast"),
                        MLast.ExUid (loc, "ExApp")),
                     ln),
                  loop e1),
               loop e2)
        | ExArr
            (_, [ExAnt (_, MLast.ExTup (_, [MLast.ExStr (_, "list"); e]))]) ->
            MLast.ExApp
              (loc,
               MLast.ExApp
                 (loc,
                  MLast.ExAcc
                    (loc, MLast.ExUid (loc, "MLast"),
                     MLast.ExUid (loc, "ExArr")),
                  ln),
               e)
        | ExArr (_, el) ->
            MLast.ExApp
              (loc,
               MLast.ExApp
                 (loc,
                  MLast.ExAcc
                    (loc, MLast.ExUid (loc, "MLast"),
                     MLast.ExUid (loc, "ExArr")),
                  ln),
               e_list loop el)
        | ExIfe (_, e1, e2, e3) ->
            MLast.ExApp
              (loc,
               MLast.ExApp
                 (loc,
                  MLast.ExApp
                    (loc,
                     MLast.ExApp
                       (loc,
                        MLast.ExAcc
                          (loc, MLast.ExUid (loc, "MLast"),
                           MLast.ExUid (loc, "ExIfe")),
                        ln),
                     loop e1),
                  loop e2),
               loop e3)
        | ExInt (_, s, k) ->
            MLast.ExApp
              (loc,
               MLast.ExApp
                 (loc,
                  MLast.ExApp
                    (loc,
                     MLast.ExAcc
                       (loc, MLast.ExUid (loc, "MLast"),
                        MLast.ExUid (loc, "ExInt")),
                     ln),
                  MLast.ExStr (loc, s)),
               MLast.ExStr (loc, k))
        | ExFun (_, pwel) ->
            let pwel =
              e_list
                (fun (p, eo, e) ->
                   MLast.ExTup (loc, [e_patt p; e_option loop eo; loop e]))
                pwel
            in
            MLast.ExApp
              (loc,
               MLast.ExApp
                 (loc,
                  MLast.ExAcc
                    (loc, MLast.ExUid (loc, "MLast"),
                     MLast.ExUid (loc, "ExFun")),
                  ln),
               pwel)
        | ExLet
            (_, rf,
             [MLast.PaAny _,
              ExAnt (_, MLast.ExTup (_, [MLast.ExStr (_, "list"); e1]))],
             e) ->
            let rf = e_bool rf in
            let pel = e1 in
            MLast.ExApp
              (loc,
               MLast.ExApp
                 (loc,
                  MLast.ExApp
                    (loc,
                     MLast.ExApp
                       (loc,
                        MLast.ExAcc
                          (loc, MLast.ExUid (loc, "MLast"),
                           MLast.ExUid (loc, "ExLet")),
                        ln),
                     rf),
                  pel),
               loop e)
        | ExLet (_, rf, pel, e) ->
            let rf = e_bool rf in
            let pel =
              e_list (fun (p, e) -> MLast.ExTup (loc, [e_patt p; loop e])) pel
            in
            MLast.ExApp
              (loc,
               MLast.ExApp
                 (loc,
                  MLast.ExApp
                    (loc,
                     MLast.ExApp
                       (loc,
                        MLast.ExAcc
                          (loc, MLast.ExUid (loc, "MLast"),
                           MLast.ExUid (loc, "ExLet")),
                        ln),
                     rf),
                  pel),
               loop e)
        | ExLid (loc, s) ->
            let a = after_colon s in
            if a = "" then
              MLast.ExApp
                (loc,
                 MLast.ExApp
                   (loc,
                    MLast.ExAcc
                      (loc, MLast.ExUid (loc, "MLast"),
                       MLast.ExUid (loc, "ExLid")),
                    ln),
                 MLast.ExStr (loc, s))
            else
              let r =
                let loc = Stdpp.make_loc (0, String.length a) in
                MLast.ExApp
                  (loc,
                   MLast.ExApp
                     (loc,
                      MLast.ExAcc
                        (loc, MLast.ExUid (loc, "MLast"),
                         MLast.ExUid (loc, "ExLid")),
                      ln),
                   MLast.ExLid (loc, a))
              in
              let loc = antiquot_loc "lid" loc in MLast.ExAnt (loc, r)
        | ExStr (loc, s) ->
            let a = after_colon s in
            if a = "" then
              MLast.ExApp
                (loc,
                 MLast.ExApp
                   (loc,
                    MLast.ExAcc
                      (loc, MLast.ExUid (loc, "MLast"),
                       MLast.ExUid (loc, "ExStr")),
                    ln),
                 MLast.ExStr (loc, s))
            else
              let r =
                let loc = Stdpp.make_loc (0, String.length a) in
                MLast.ExApp
                  (loc,
                   MLast.ExApp
                     (loc,
                      MLast.ExAcc
                        (loc, MLast.ExUid (loc, "MLast"),
                         MLast.ExUid (loc, "ExStr")),
                      ln),
                   MLast.ExLid (loc, a))
              in
              let loc = antiquot_loc "str" loc in MLast.ExAnt (loc, r)
        | ExTup (_, el) ->
            MLast.ExApp
              (loc,
               MLast.ExApp
                 (loc,
                  MLast.ExAcc
                    (loc, MLast.ExUid (loc, "MLast"),
                     MLast.ExUid (loc, "ExTup")),
                  ln),
               e_list loop el)
        | ExUid (_, s) ->
            MLast.ExApp
              (loc,
               MLast.ExApp
                 (loc,
                  MLast.ExAcc
                    (loc, MLast.ExUid (loc, "MLast"),
                     MLast.ExUid (loc, "ExUid")),
                  ln),
               MLast.ExStr (loc, s))
        | x -> not_impl "e_expr" x
      in
      loop e
    ;;
    let p_patt x = not_impl "p_patt" x;;
    let p_expr x = not_impl "p_expr" x;;
    let e_sig_item =
      function
        SgVal (_, s, t) ->
          let s =
            try
              let i = String.index s ',' in
              let j = String.index_from s (i + 1) ':' in
              let bp = int_of_string (String.sub s 0 i) in
              let ep = int_of_string (String.sub s (i + 1) (j - i - 1)) in
              let s = String.sub s (j + 1) (String.length s - j - 1) in
              let r =
                call_with Plexer.dollar_for_antiquot_loc false
                  (Grammar.Entry.parse expr_eoi) (Stream.of_string s)
              in
              let loc = antiquot_loc "lid" (Stdpp.make_loc (bp, ep)) in
              MLast.ExAnt (loc, r)
            with Not_found | Failure _ -> MLast.ExStr (loc, s)
          in
          MLast.ExApp
            (loc,
             MLast.ExApp
               (loc,
                MLast.ExApp
                  (loc,
                   MLast.ExAcc
                     (loc, MLast.ExUid (loc, "MLast"),
                      MLast.ExUid (loc, "SgVal")),
                   ln ()),
                s),
             e_type t)
      | x -> not_impl "e_sig_item" x
    ;;
    let p_sig_item =
      function
        SgVal (_, s, t) ->
          let s =
            let a = after_colon s in
            if a = "" then MLast.PaStr (loc, s) else MLast.PaLid (loc, a)
          in
          MLast.PaApp
            (loc,
             MLast.PaApp
               (loc,
                MLast.PaApp
                  (loc,
                   MLast.PaAcc
                     (loc, MLast.PaUid (loc, "MLast"),
                      MLast.PaUid (loc, "SgVal")),
                   MLast.PaAny loc),
                s),
             p_type t)
      | x -> not_impl "p_sig_item" x
    ;;
  end
;;

let check_anti_loc s kind =
  try
    let i = String.index s ':' in
    let j = String.index_from s (i + 1) ':' in
    if String.sub s (i + 1) (j - i - 1) = "lid" then
      String.sub s 0 i ^ String.sub s j (String.length s - j)
    else raise Stream.Failure
  with Not_found -> raise Stream.Failure
;;

let lex = Grammar.glexer Pcaml.gram in
lex.Token.tok_match <-
  function
    "ANTIQUOT", p_prm ->
      (function
         "ANTIQUOT", prm when eq_before_colon p_prm prm -> after_colon prm
       | _ -> raise Stream.Failure)
  | "LIDENT", "" ->
      (function
         "LIDENT", prm -> prm
       | "ANTIQUOT_LOC", prm -> check_anti_loc prm "lid"
       | _ -> raise Stream.Failure)
  | "STRING", "" ->
      (function
         "STRING", prm -> prm
       | "ANTIQUOT_LOC", prm -> check_anti_loc prm "str"
       | _ -> raise Stream.Failure)
  | tok -> Token.default_match tok;;

(* reinit the entry functions to take the new tok_match into account *)
Grammar.iter_entry Grammar.reinit_entry_functions
  (Grammar.Entry.obj Pcaml.expr);;

let apply_entry e me mp =
  let f s =
    call_with Plexer.dollar_for_antiquot_loc true (Grammar.Entry.parse e)
      (Stream.of_string s)
  in
  let expr s = me (f s) in
  let patt s = mp (f s) in Quotation.ExAst (expr, patt)
;;

List.iter (fun (q, f) -> Quotation.add q f)
  ["expr", apply_entry expr_eoi Meta.e_expr Meta.p_expr;
   "patt", apply_entry patt_eoi Meta.e_patt Meta.p_patt;
   "sig_item", apply_entry sig_item_eoi Meta.e_sig_item Meta.p_sig_item];;
