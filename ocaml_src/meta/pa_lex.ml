(* camlp4r *)
(* This file has been generated by program: do not edit! *)

(* #load "pa_extend.cmo" *)
(* #load "q_MLast.cmo" *)

open Pcaml;;

(**)
let var = "buf";;
let add_char loc c cl =
  MLast.ExApp
    (loc,
     MLast.ExApp
       (loc,
        MLast.ExAcc (loc, MLast.ExUid (loc, "B"), MLast.ExLid (loc, "add")),
        cl),
     c)
;;
let get_buf loc cl =
  MLast.ExApp
    (loc, MLast.ExAcc (loc, MLast.ExUid (loc, "B"), MLast.ExLid (loc, "get")),
     cl)
;;
(*
value var = "cl";
value add_char loc c cl = <:expr< [$c$ :: $cl$] >>;
value get_buf loc cl = cl;
*)

let mk_parser loc rl =
  let rl =
    List.map
      (fun (sl, cl, a) ->
         let a =
           let b =
             let b = MLast.ExLid (loc, var) in
             if cl = [] then b else List.fold_right (add_char loc) cl b
           in
           match a with
             Some e -> MLast.ExTup (loc, [e; get_buf loc b])
           | None -> b
         in
         List.rev sl, None, a)
      rl
  in
  Exparser.cparser loc None rl
;;

Grammar.extend
  (let _ = (expr : 'expr Grammar.Entry.e) in
   let grammar_entry_create s =
     Grammar.Entry.create (Grammar.of_entry expr) s
   in
   let rules : 'rules Grammar.Entry.e = grammar_entry_create "rules"
   and rule : 'rule Grammar.Entry.e = grammar_entry_create "rule"
   and symbs : 'symbs Grammar.Entry.e = grammar_entry_create "symbs"
   and lookahead : 'lookahead Grammar.Entry.e =
     grammar_entry_create "lookahead"
   and lookahead_char : 'lookahead_char Grammar.Entry.e =
     grammar_entry_create "lookahead_char"
   and err_kont : 'err_kont Grammar.Entry.e = grammar_entry_create "err_kont"
   and act : 'act Grammar.Entry.e = grammar_entry_create "act" in
   [Grammar.Entry.obj (expr : 'expr Grammar.Entry.e), None,
    [None, None,
     [[Gramext.Stoken ("", "lexer");
       Gramext.Snterm (Grammar.Entry.obj (rules : 'rules Grammar.Entry.e))],
      Gramext.action
        (fun (rl : 'rules) _ (loc : Token.location) ->
           (mk_parser loc rl : 'expr))]];
    Grammar.Entry.obj (rules : 'rules Grammar.Entry.e), None,
    [None, None,
     [[Gramext.Stoken ("", "[");
       Gramext.Slist0sep
         (Gramext.Snterm (Grammar.Entry.obj (rule : 'rule Grammar.Entry.e)),
          Gramext.Stoken ("", "|"));
       Gramext.Stoken ("", "]")],
      Gramext.action
        (fun _ (rl : 'rule list) _ (loc : Token.location) -> (rl : 'rules))]];
    Grammar.Entry.obj (rule : 'rule Grammar.Entry.e), None,
    [None, None,
     [[Gramext.Snterm (Grammar.Entry.obj (symbs : 'symbs Grammar.Entry.e));
       Gramext.Snterm (Grammar.Entry.obj (act : 'act Grammar.Entry.e))],
      Gramext.action
        (fun (a : 'act) (sl, cl : 'symbs) (loc : Token.location) ->
           (sl, cl, a : 'rule))]];
    Grammar.Entry.obj (symbs : 'symbs Grammar.Entry.e), None,
    [None, None,
     [[], Gramext.action (fun (loc : Token.location) -> ([], [] : 'symbs));
      [Gramext.Sself;
       Gramext.Snterm (Grammar.Entry.obj (rules : 'rules Grammar.Entry.e));
       Gramext.Snterm
         (Grammar.Entry.obj (err_kont : 'err_kont Grammar.Entry.e))],
      Gramext.action
        (fun (errk : 'err_kont) (rl : 'rules) (sl, cl : 'symbs)
           (loc : Token.location) ->
           (let e = mk_parser loc rl in
            let s = Exparser.SpNtr (loc, MLast.PaLid (loc, var), e), errk in
            s :: sl, [] :
            'symbs));
      [Gramext.Sself; Gramext.Stoken ("", "?="); Gramext.Stoken ("", "[");
       Gramext.Slist1sep
         (Gramext.Snterm
            (Grammar.Entry.obj (lookahead : 'lookahead Grammar.Entry.e)),
          Gramext.Stoken ("", "|"));
       Gramext.Stoken ("", "]");
       Gramext.Snterm
         (Grammar.Entry.obj (err_kont : 'err_kont Grammar.Entry.e))],
      Gramext.action
        (fun (errk : 'err_kont) _ (pll : 'lookahead list) _ _
           (sl, cl : 'symbs) (loc : Token.location) ->
           (let s = Exparser.SpLhd (loc, pll), errk in s :: sl, cl : 'symbs));
      [Gramext.Sself; Gramext.Stoken ("LIDENT", "");
       Gramext.Snterm
         (Grammar.Entry.obj (err_kont : 'err_kont Grammar.Entry.e))],
      Gramext.action
        (fun (errk : 'err_kont) (i : string) (sl, cl : 'symbs)
           (loc : Token.location) ->
           (let s =
              let buf =
                List.fold_right (add_char loc) cl (MLast.ExLid (loc, var))
              in
              let e = MLast.ExApp (loc, MLast.ExLid (loc, i), buf) in
              Exparser.SpNtr (loc, MLast.PaLid (loc, var), e), errk
            in
            s :: sl, [] :
            'symbs));
      [Gramext.Sself; Gramext.Stoken ("CHAR", ""); Gramext.Stoken ("", "..");
       Gramext.Stoken ("CHAR", "");
       Gramext.Snterm
         (Grammar.Entry.obj (err_kont : 'err_kont Grammar.Entry.e))],
      Gramext.action
        (fun (errk : 'err_kont) (c2 : string) _ (c1 : string)
           (sl, cl : 'symbs) (loc : Token.location) ->
           (let s =
              Exparser.SpTrm
                (loc,
                 MLast.PaAli
                   (loc,
                    MLast.PaRng
                      (loc, MLast.PaChr (loc, c1), MLast.PaChr (loc, c2)),
                    MLast.PaLid (loc, "c")),
                 None),
              errk
            in
            s :: sl, MLast.ExLid (loc, "c") :: cl :
            'symbs));
      [Gramext.Sself; Gramext.Stoken ("CHAR", ""); Gramext.Stoken ("", "/")],
      Gramext.action
        (fun _ (c : string) (sl, cl : 'symbs) (loc : Token.location) ->
           (let s = Exparser.SpTrm (loc, MLast.PaChr (loc, c), None), None in
            s :: sl, cl :
            'symbs));
      [Gramext.Sself; Gramext.Stoken ("CHAR", "")],
      Gramext.action
        (fun (c : string) (sl, cl : 'symbs) (loc : Token.location) ->
           (let s = Exparser.SpTrm (loc, MLast.PaChr (loc, c), None), None in
            s :: sl, MLast.ExChr (loc, c) :: cl :
            'symbs))]];
    Grammar.Entry.obj (lookahead : 'lookahead Grammar.Entry.e), None,
    [None, None,
     [[Gramext.Slist1
         (Gramext.Snterm
            (Grammar.Entry.obj
               (lookahead_char : 'lookahead_char Grammar.Entry.e)))],
      Gramext.action
        (fun (pl : 'lookahead_char list) (loc : Token.location) ->
           (pl : 'lookahead))]];
    Grammar.Entry.obj (lookahead_char : 'lookahead_char Grammar.Entry.e),
    None,
    [None, None,
     [[Gramext.Stoken ("", "_")],
      Gramext.action
        (fun _ (loc : Token.location) -> (MLast.PaAny loc : 'lookahead_char));
      [Gramext.Stoken ("CHAR", "")],
      Gramext.action
        (fun (c : string) (loc : Token.location) ->
           (MLast.PaChr (loc, c) : 'lookahead_char))]];
    Grammar.Entry.obj (err_kont : 'err_kont Grammar.Entry.e), None,
    [None, None,
     [[], Gramext.action (fun (loc : Token.location) -> (None : 'err_kont));
      [Gramext.Stoken ("", "?"); Gramext.Stoken ("STRING", "")],
      Gramext.action
        (fun (s : string) _ (loc : Token.location) ->
           (Some (Some (MLast.ExStr (loc, s))) : 'err_kont));
      [Gramext.Stoken ("", "!")],
      Gramext.action
        (fun _ (loc : Token.location) -> (Some None : 'err_kont))]];
    Grammar.Entry.obj (act : 'act Grammar.Entry.e), None,
    [None, None,
     [[], Gramext.action (fun (loc : Token.location) -> (None : 'act));
      [Gramext.Stoken ("", "->");
       Gramext.Snterm (Grammar.Entry.obj (expr : 'expr Grammar.Entry.e))],
      Gramext.action
        (fun (e : 'expr) _ (loc : Token.location) -> (Some e : 'act))]]]);;
