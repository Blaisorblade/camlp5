(* camlp4r *)
(* This file has been generated by program: do not edit! *)

(* #load "pa_extend.cmo" *)
(* #load "q_MLast.cmo" *)

open Pcaml;;

(**)
let var = "buf";;
let add_char loc c cl =
  MLast.ExApp
    (loc,
     MLast.ExApp
       (loc,
        MLast.ExAcc (loc, MLast.ExUid (loc, "B"), MLast.ExLid (loc, "add")),
        cl),
     c)
;;
let get_buf loc cl =
  MLast.ExApp
    (loc, MLast.ExAcc (loc, MLast.ExUid (loc, "B"), MLast.ExLid (loc, "get")),
     cl)
;;
(*
value var = "cl";
value add_char loc c cl = <:expr< [$c$ :: $cl$] >>;
value get_buf loc cl = cl;
*)

let fresh_c cl =
  let n =
    List.fold_left
      (fun n c ->
         match c with
           MLast.ExLid (_, _) -> n + 1
         | _ -> n)
      0 cl
  in
  if n = 0 then "c" else "c" ^ string_of_int n
;;

let accum_chars loc cl =
  List.fold_right (add_char loc) cl (MLast.ExLid (loc, var))
;;

let mk_parser loc rl =
  let rl =
    List.map
      (fun (sl, cl, a) ->
         let a =
           let b = accum_chars loc cl in
           match a with
             Some e -> e
           | None -> b
         in
         List.rev sl, None, a)
      rl
  in
  Exparser.cparser loc None rl
;;

let isolate_char_patt_list =
  let rec loop pl =
    function
      ([Exparser.SpTrm (_, p, None), None], [_], None) :: rl ->
        let p =
          match p with
            MLast.PaChr (_, _) -> p
          | MLast.PaAli (_, p, MLast.PaLid (_, _)) -> p
          | p -> p
        in
        loop (p :: pl) rl
    | rl -> List.rev pl, rl
  in
  loop []
;;

let isolate_char_patt loc rl =
  match isolate_char_patt_list rl with
    p :: pl, rl ->
      let p = List.fold_left (fun p1 p2 -> MLast.PaOrp (loc, p1, p2)) p pl in
      Some p, rl
  | _ -> None, rl
;;

let gcl = ref [];;

Grammar.extend
  (let _ = (expr : 'expr Grammar.Entry.e) in
   let grammar_entry_create s =
     Grammar.Entry.create (Grammar.of_entry expr) s
   in
   let rules : 'rules Grammar.Entry.e = grammar_entry_create "rules"
   and rule : 'rule Grammar.Entry.e = grammar_entry_create "rule"
   and symb_list : 'symb_list Grammar.Entry.e =
     grammar_entry_create "symb_list"
   and symbs : 'symbs Grammar.Entry.e = grammar_entry_create "symbs"
   and simple_expr : 'simple_expr Grammar.Entry.e =
     grammar_entry_create "simple_expr"
   and lookahead : 'lookahead Grammar.Entry.e =
     grammar_entry_create "lookahead"
   and lookahead_char : 'lookahead_char Grammar.Entry.e =
     grammar_entry_create "lookahead_char"
   and err_kont : 'err_kont Grammar.Entry.e = grammar_entry_create "err_kont"
   and act : 'act Grammar.Entry.e = grammar_entry_create "act" in
   [Grammar.Entry.obj (expr : 'expr Grammar.Entry.e), None,
    [None, None,
     [[Gramext.Stoken ("", "$")],
      Gramext.action
        (fun _ (loc : Token.location) ->
           (let b = accum_chars loc !gcl in get_buf loc b : 'expr));
      [Gramext.Stoken ("", "lexer");
       Gramext.Snterm (Grammar.Entry.obj (rules : 'rules Grammar.Entry.e))],
      Gramext.action
        (fun (rl : 'rules) _ (loc : Token.location) ->
           (let rl =
              match isolate_char_patt loc rl with
                Some p, rl ->
                  let p = MLast.PaAli (loc, p, MLast.PaLid (loc, "c")) in
                  let e = MLast.ExLid (loc, "c") in
                  ([Exparser.SpTrm (loc, p, None), None], [e], None) :: rl
              | None, rl -> rl
            in
            MLast.ExFun
              (loc, [MLast.PaLid (loc, var), None, mk_parser loc rl]) :
            'expr))]];
    Grammar.Entry.obj (rules : 'rules Grammar.Entry.e), None,
    [None, None,
     [[Gramext.Stoken ("", "[");
       Gramext.Slist0sep
         (Gramext.Snterm (Grammar.Entry.obj (rule : 'rule Grammar.Entry.e)),
          Gramext.Stoken ("", "|"));
       Gramext.Stoken ("", "]")],
      Gramext.action
        (fun _ (rl : 'rule list) _ (loc : Token.location) -> (rl : 'rules))]];
    Grammar.Entry.obj (rule : 'rule Grammar.Entry.e), None,
    [None, None,
     [[Gramext.Snterm
         (Grammar.Entry.obj (symb_list : 'symb_list Grammar.Entry.e));
       Gramext.Snterm (Grammar.Entry.obj (act : 'act Grammar.Entry.e))],
      Gramext.action
        (fun (a : 'act) (sl, cl : 'symb_list) (loc : Token.location) ->
           (sl, cl, a : 'rule))]];
    Grammar.Entry.obj (symb_list : 'symb_list Grammar.Entry.e), None,
    [None, None,
     [[Gramext.Snterm (Grammar.Entry.obj (symbs : 'symbs Grammar.Entry.e))],
      Gramext.action
        (fun (sl, cl : 'symbs) (loc : Token.location) ->
           (gcl := cl; sl, cl : 'symb_list))]];
    Grammar.Entry.obj (symbs : 'symbs Grammar.Entry.e), None,
    [None, None,
     [[], Gramext.action (fun (loc : Token.location) -> ([], [] : 'symbs));
      [Gramext.Sself;
       Gramext.Snterm (Grammar.Entry.obj (rules : 'rules Grammar.Entry.e));
       Gramext.Snterm
         (Grammar.Entry.obj (err_kont : 'err_kont Grammar.Entry.e))],
      Gramext.action
        (fun (errk : 'err_kont) (rl : 'rules) (sl, cl : 'symbs)
           (loc : Token.location) ->
           (match isolate_char_patt loc rl with
              Some p, [] ->
                let c = fresh_c cl in
                let s =
                  let p = MLast.PaAli (loc, p, MLast.PaLid (loc, c)) in
                  Exparser.SpTrm (loc, p, None), errk
                in
                s :: sl, MLast.ExLid (loc, c) :: cl
            | x ->
                let rl =
                  match x with
                    Some p, rl ->
                      let r =
                        let p =
                          MLast.PaAli (loc, p, MLast.PaLid (loc, "c"))
                        in
                        let e = MLast.ExLid (loc, "c") in
                        [Exparser.SpTrm (loc, p, None), None], [e], None
                      in
                      r :: rl
                  | None, rl -> rl
                in
                let errk =
                  match List.rev rl with
                    ([], _, _) :: _ -> Some None
                  | _ -> errk
                in
                let sl =
                  if cl = [] then sl
                  else
                    let s =
                      let b = accum_chars loc cl in
                      let e = Exparser.cparser loc None [[], None, b] in
                      Exparser.SpNtr (loc, MLast.PaLid (loc, var), e),
                      Some None
                    in
                    s :: sl
                in
                let s =
                  let e = mk_parser loc rl in
                  Exparser.SpNtr (loc, MLast.PaLid (loc, var), e), errk
                in
                s :: sl, [] :
            'symbs));
      [Gramext.Sself; Gramext.Stoken ("", "?="); Gramext.Stoken ("", "[");
       Gramext.Slist1sep
         (Gramext.Snterm
            (Grammar.Entry.obj (lookahead : 'lookahead Grammar.Entry.e)),
          Gramext.Stoken ("", "|"));
       Gramext.Stoken ("", "]");
       Gramext.Snterm
         (Grammar.Entry.obj (err_kont : 'err_kont Grammar.Entry.e))],
      Gramext.action
        (fun (errk : 'err_kont) _ (pll : 'lookahead list) _ _
           (sl, cl : 'symbs) (loc : Token.location) ->
           (let s = Exparser.SpLhd (loc, pll), errk in s :: sl, cl : 'symbs));
      [Gramext.Sself;
       Gramext.Snterm
         (Grammar.Entry.obj (simple_expr : 'simple_expr Grammar.Entry.e));
       Gramext.Snterm
         (Grammar.Entry.obj (err_kont : 'err_kont Grammar.Entry.e))],
      Gramext.action
        (fun (errk : 'err_kont) (f : 'simple_expr) (sl, cl : 'symbs)
           (loc : Token.location) ->
           (let s =
              let buf = accum_chars loc cl in
              let e = MLast.ExApp (loc, f, buf) in
              Exparser.SpNtr (loc, MLast.PaLid (loc, var), e), errk
            in
            s :: sl, [] :
            'symbs));
      [Gramext.Sself; Gramext.Stoken ("CHAR", ""); Gramext.Stoken ("", "..");
       Gramext.Stoken ("CHAR", "");
       Gramext.Snterm
         (Grammar.Entry.obj (err_kont : 'err_kont Grammar.Entry.e))],
      Gramext.action
        (fun (errk : 'err_kont) (c2 : string) _ (c1 : string)
           (sl, cl : 'symbs) (loc : Token.location) ->
           (let c = fresh_c cl in
            let s =
              let p =
                MLast.PaAli
                  (loc,
                   MLast.PaRng
                     (loc, MLast.PaChr (loc, c1), MLast.PaChr (loc, c2)),
                   MLast.PaLid (loc, c))
              in
              Exparser.SpTrm (loc, p, None), errk
            in
            s :: sl, MLast.ExLid (loc, c) :: cl :
            'symbs));
      [Gramext.Sself; Gramext.Stoken ("", "_"); Gramext.Stoken ("", "/");
       Gramext.Snterm
         (Grammar.Entry.obj (err_kont : 'err_kont Grammar.Entry.e))],
      Gramext.action
        (fun (errk : 'err_kont) _ _ (sl, cl : 'symbs)
           (loc : Token.location) ->
           (let s =
              let p = MLast.PaAny loc in Exparser.SpTrm (loc, p, None), errk
            in
            s :: sl, cl :
            'symbs));
      [Gramext.Sself; Gramext.Stoken ("", "_");
       Gramext.Snterm
         (Grammar.Entry.obj (err_kont : 'err_kont Grammar.Entry.e))],
      Gramext.action
        (fun (errk : 'err_kont) _ (sl, cl : 'symbs) (loc : Token.location) ->
           (let c = fresh_c cl in
            let s =
              let p = MLast.PaLid (loc, c) in
              Exparser.SpTrm (loc, p, None), errk
            in
            s :: sl, MLast.ExLid (loc, c) :: cl :
            'symbs));
      [Gramext.Sself; Gramext.Stoken ("CHAR", ""); Gramext.Stoken ("", "/");
       Gramext.Snterm
         (Grammar.Entry.obj (err_kont : 'err_kont Grammar.Entry.e))],
      Gramext.action
        (fun (errk : 'err_kont) _ (c : string) (sl, cl : 'symbs)
           (loc : Token.location) ->
           (let s = Exparser.SpTrm (loc, MLast.PaChr (loc, c), None), errk in
            s :: sl, cl :
            'symbs));
      [Gramext.Sself; Gramext.Stoken ("CHAR", "");
       Gramext.Snterm
         (Grammar.Entry.obj (err_kont : 'err_kont Grammar.Entry.e))],
      Gramext.action
        (fun (errk : 'err_kont) (c : string) (sl, cl : 'symbs)
           (loc : Token.location) ->
           (let s = Exparser.SpTrm (loc, MLast.PaChr (loc, c), None), errk in
            s :: sl, MLast.ExChr (loc, c) :: cl :
            'symbs))]];
    Grammar.Entry.obj (simple_expr : 'simple_expr Grammar.Entry.e), None,
    [None, None,
     [[Gramext.Stoken ("", "(");
       Gramext.Snterm (Grammar.Entry.obj (expr : 'expr Grammar.Entry.e));
       Gramext.Stoken ("", ")")],
      Gramext.action
        (fun _ (e : 'expr) _ (loc : Token.location) -> (e : 'simple_expr));
      [Gramext.Stoken ("LIDENT", "")],
      Gramext.action
        (fun (i : string) (loc : Token.location) ->
           (MLast.ExLid (loc, i) : 'simple_expr))]];
    Grammar.Entry.obj (lookahead : 'lookahead Grammar.Entry.e), None,
    [None, None,
     [[Gramext.Slist1
         (Gramext.Snterm
            (Grammar.Entry.obj
               (lookahead_char : 'lookahead_char Grammar.Entry.e)))],
      Gramext.action
        (fun (pl : 'lookahead_char list) (loc : Token.location) ->
           (pl : 'lookahead))]];
    Grammar.Entry.obj (lookahead_char : 'lookahead_char Grammar.Entry.e),
    None,
    [None, None,
     [[Gramext.Stoken ("", "_")],
      Gramext.action
        (fun _ (loc : Token.location) -> (MLast.PaAny loc : 'lookahead_char));
      [Gramext.Stoken ("CHAR", "")],
      Gramext.action
        (fun (c : string) (loc : Token.location) ->
           (MLast.PaChr (loc, c) : 'lookahead_char))]];
    Grammar.Entry.obj (err_kont : 'err_kont Grammar.Entry.e), None,
    [None, None,
     [[], Gramext.action (fun (loc : Token.location) -> (None : 'err_kont));
      [Gramext.Stoken ("", "?"); Gramext.Stoken ("STRING", "")],
      Gramext.action
        (fun (s : string) _ (loc : Token.location) ->
           (Some (Some (MLast.ExStr (loc, s))) : 'err_kont));
      [Gramext.Stoken ("", "!")],
      Gramext.action
        (fun _ (loc : Token.location) -> (Some None : 'err_kont))]];
    Grammar.Entry.obj (act : 'act Grammar.Entry.e), None,
    [None, None,
     [[], Gramext.action (fun (loc : Token.location) -> (None : 'act));
      [Gramext.Stoken ("", "->");
       Gramext.Snterm (Grammar.Entry.obj (expr : 'expr Grammar.Entry.e))],
      Gramext.action
        (fun (e : 'expr) _ (loc : Token.location) -> (Some e : 'act))]]]);;
