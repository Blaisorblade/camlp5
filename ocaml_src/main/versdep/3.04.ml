(* camlp5r pa_macro.cmo *)
(* This file has been generated by program: do not edit! *)
(* Copyright (c) INRIA 2007-2010 *)

open Parsetree;;
open Longident;;
open Asttypes;;

(* *)

(* *)

(* *)

(* *)

(* *)

let sys_ocaml_version = "3.04";;

let ov = sys_ocaml_version in
let oi =
  let rec loop i =
    if i = String.length ov then i
    else
      match ov.[i] with
        ' ' | '+' -> i
      | _ -> loop (i + 1)
  in
  loop 0
in
let ov = String.sub ov 0 oi in
if ov <> Pconfig.ocaml_version then
  begin
    flush stdout;
    Printf.eprintf "\n";
    Printf.eprintf "This ocaml and this camlp5 are not compatible:\n";
    Printf.eprintf "- OCaml version is %s\n" sys_ocaml_version;
    Printf.eprintf "- Camlp5 compiled with ocaml %s\n" Pconfig.ocaml_version;
    Printf.eprintf "\n";
    Printf.eprintf "You need to recompile camlp5.\n";
    Printf.eprintf "\n";
    flush stderr;
    failwith "bad version"
  end;;

let ocaml_location (fname, lnum, bolp, bp, ep) =
  {Location.loc_start = bp; Location.loc_end = ep;
   Location.loc_ghost = bp = 0 && ep = 0}
;;

let ocaml_ptyp_poly = None;;

let ocaml_type_declaration params cl tk pf tm loc variance =
  {ptype_params = params; ptype_cstrs = cl; ptype_kind = tk;
   ptype_manifest = tm; ptype_loc = loc; ptype_variance = variance}
;;

let ocaml_ptype_record ltl priv =
  let ltl = List.map (fun (n, m, t, _) -> n, m, t) ltl in Ptype_record ltl
;;

let ocaml_ptype_variant ctl priv =
  let ctl = List.map (fun (c, tl, _) -> c, tl) ctl in Ptype_variant ctl
;;

let ocaml_ptype_private = Ptype_abstract;;

let ocaml_pwith_type params tk pf ct variance loc =
  Pwith_type
    {ptype_params = params; ptype_cstrs = []; ptype_kind = tk;
     ptype_manifest = ct; ptype_variance = variance; ptype_loc = loc}
;;

let ocaml_pexp_lazy = None;;

let ocaml_const_int32 = None;;

let ocaml_const_int64 = None;;

let ocaml_const_nativeint = None;;

let ocaml_pexp_object = None;;

let module_prefix_can_be_in_first_record_label_only = false;;

let ocaml_ppat_lazy = None;;

let ocaml_ppat_record lpl = Ppat_record lpl;;

let ocaml_psig_recmodule = None;;

let ocaml_pstr_recmodule = None;;

let ocaml_pctf_val (s, b, t, loc) = Pctf_val (s, b, Some t, loc);;

let ocaml_pcf_inher ce pb = Pcf_inher (ce, pb);;

let ocaml_pcf_meth (s, b, e, loc) = Pcf_meth (s, b, e, loc);;

let ocaml_pcf_val (s, b, e, loc) = Pcf_val (s, b, e, loc);;

let ocaml_pexp_poly = None;;

(**)

let action_arg s sl =
  function
    Arg.Unit f -> if s = "" then begin f (); Some sl end else None
  | Arg.Set r -> if s = "" then begin r := true; Some sl end else None
  | Arg.Clear r -> if s = "" then begin r := false; Some sl end else None
  | Arg.Rest f -> List.iter f (s :: sl); Some []
  | Arg.String f ->
      if s = "" then
        match sl with
          s :: sl -> f s; Some sl
        | [] -> None
      else begin f s; Some sl end
  | Arg.Int f ->
      if s = "" then
        match sl with
          s :: sl ->
            begin try f (int_of_string s); Some sl with
              Failure "int_of_string" -> None
            end
        | [] -> None
      else
        begin try f (int_of_string s); Some sl with
          Failure "int_of_string" -> None
        end
  | Arg.Float f ->
      if s = "" then
        match sl with
          s :: sl -> f (float_of_string s); Some sl
        | [] -> None
      else begin f (float_of_string s); Some sl end
;;

let arg_symbol _ = None;;
